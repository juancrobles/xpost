/DEVICE <<
    /defaultmatrix [ 1 0 0 1 0 0 ]
>> def

/graphicsdict <<
    /currgstate 12 dict
    /gstackarray 100 array
    /gptr -1
>> def

/gstatetemplate <<
    /currmatrix [ 1 0 0 1 0 0 ]
    /scratchmatrix [ 1 0 0 1 0 0 ]
    /currpath 1 dict
    /flat 1
>> def



% Graphics State Operators -- Device Independent

% -  gsave  -
% push graphics state
/gsave {
graphicsdict begin
    /gptr gptr 1 add def
    gptr gstackarray length ge { error } if
    gstackarray gptr gstate currentgstate
    put
end
} def

% -  grestore  -
% pop graphics state
/grestore {
graphicsdict begin
    gptr -1 gt {
        gstackarray gptr get
        currgstate copy pop
        /gptr gptr 1 sub def
    } if
end
} def

% -  grestoreall  -
% pop to bottommost graphics state
/grestoreall {
graphicsdict begin
    /gptr -1 def
    gstackarray 0 get
    currgstate copy pop
end
} def

% -  initgraphics  -
% reset graphics state parameters
/initgraphics {
    gstate setgstate
} def

% -  gstate  gstate
% create graphics state object
/gstate {
    gstatetemplate dup length dict copy
} def

% gstate  setgstate  -
% set graphics state from gstate
/setgstate {
    graphicsdict /currgstate get copy pop
} def

% gstate  currentgstate  gstate
% copy current graphics state into gstate
/currentgstate {
    graphicsdict /currgstate get exch copy
} def



% Graphics State Operators -- Device Dependent

/currentflat {
    graphicsdict /currgstate get /flat get
} def

/setflat {
    graphicsdict /currgstate get exch /flat exch put
} def


% Coordinate System and Matrix Operators

% -  matrix  matrix
% create identity matrix
/matrix { 6 array identmatrix } def

% -  initmatrix  -
% set CTM to device default
/initmatrix {
    matrix defaultmatrix setmatrix
} def

% matrix  identmatrix  matrix
% fill matrix with identity transform
/identmatrix {
    dup type/arraytype ne { /identmatrix cvx /typecheck signalerror } if
    { 1 0 0 1 0 0 } exch copy
} def

% matrix  defaultmatrix  matrix
% fill matrix with device default matrix
/defaultmatrix {
    dup type/arraytype ne { /defaultmatrix cvx /typecheck signalerror } if
    DEVICE /defaultmatrix get exch copy
} def

% matrix  currentmatrix  matrix
% fill matrix with CTM
/currentmatrix {
    dup type/arraytype ne { /currentmatrix cvx /typecheck signalerror } if
    graphicsdict /currgstate get /currmatrix get exch copy
} def

% matrix  setmatrix  -
% replace CTM by matrix
/setmatrix {
    dup type/arraytype ne { /setmatrix cvx /typecheck signalerror } if
    graphicsdict /currgstate get /currmatrix get copy pop
} def

%        tx ty  translate  -       % translate userspace by (tx, ty)
% tx ty matrix  translate  matrix  % define translation by (tx, ty)
/translate {
    dup type/arraytype ne
        { true 3 1 roll matrix } % no array: create array, concat later
        { false 4 1 roll } % array: do not create, do not concat later
    ifelse % bool tx ty matrix
    dup 0 1 put
    dup 1 0 put
    dup 2 0 put
    dup 3 1 put
    dup 4 5 4 roll put
    dup 5 4 3 roll put
    exch { concat } if
} def

%        sx sy  scale  -       % scale user space by (sx, sy)
% sx sy matrix  scale  matrix  % define scaling by (sx, sy)
/scale {
    dup type/arraytype ne
        { true 3 1 roll matrix }
        { false 4 1 roll }
    ifelse % bool sx sy matrix
    dup 0        % b sx sy mat mat 0
          5 4 roll put % b sy mat
    dup 1 0 put
    dup 2 0 put
    dup 3 4 3 roll put % b mat
    dup 4 0 put
    dup 5 0 put
    exch { concat } if
} def

%        angle  rotate  -       % rotate user space by angle
% angle matrix  rotate  matrix  % define rotation by angle degrees
/rotate {
    dup type /arraytype ne
        { true exch matrix }
        { false 3 1 roll }
    ifelse          % bool ang mat
    dup 0                 % b ang mat mat 0
          3 index cos put % b ang mat
    dup 1 3 index sin put
    dup 2 3 index sin neg put
    dup 3 4 3 roll cos put
    dup 4 0 put
    dup 5 0 put
    exch { concat } if
} def

% matrix  concat  -
% replace CTM by matrix \times CTM
/concat {
    graphicsdict /currgstate get /currmatrix get dup concatmatrix pop
} def

% matrix1 matrix2 matrix3  concatmatrix  matrix3
% fill matrix3 with matrix1 \times matrix2
/concatmatrix {
    3 copy type/arraytype ne exch type/arraytype ne or exch type/arraytype ne or
        { /concatmatrix cvx /typecheck signalerror } if
12 dict begin
    /D exch def
    aload pop 7 6 roll aload pop
    {l k j i h g f e d c b a}{exch def}forall
    a g mul c h mul add
    b g mul d h mul add
    a i mul c j mul add
    b i mul d j mul add
    a k mul c l mul add e add
    b k mul d l mul add f add
    D astore
end
} def

%        x y  transform  x' y'  % transform (x,y) by CTM
% x y matrix  transform  x' y'  % transform (x,y) by matrix
/transform {
12 dict begin
    dup type/arraytype ne { graphicsdict /currgstate get /currmatrix get } if
    aload pop % x y a b c d e f
    {f e d c b a y x}{exch def}forall
    a x mul c y mul add e add
    b x mul d y mul add f add
end
} def

%        dx dy  dtransform  dx' dy'  % transform distance (dx,dy) by CTM
% dx dy matrix  dtransform  dx' dy'  % transform distance (dx,dy) by matrix
/dtransform {
12 dict begin
    dup type/arraytype ne { graphicsdict /currgstate get /currmatrix get } if
    aload pop % x y a b c d e f
    pop pop % x y a b c d
    {d c b a y x}{exch def}forall
    a x mul c y mul add
    b x mul d y mul add
end
} def

%        x' y'  itransform  x y  % inverse transform (x',y') by CTM
% x' y' matrix  itransform  x y  % inverse transform (x',y') by matrix
/itransform {
12 dict begin
    dup type/arraytype ne { graphicsdict /currgstate get /currmatrix get } if
    %graphicsdict /currgstate get /scratchmatrix get copy invertmatrix transform
    aload pop {f e d c b a y x}{exch def}forall
    a d mul b c mul sub
    dup 0 eq { end /itransform cvx /undefinedresult signalerror } if
    1 exch div
    /invdet exch def
    d x mul b y mul sub c f mul add d e mul sub invdet mul
    c x mul neg a y mul add b e mul add a f mul sub invdet mul
end
} def

%        dx' dy'  idtransform  dx dy  % inverse transform distance (dx',dy') by CTM
% dx' dy' matrix  idtransform  dx dy  % inverse transform distance (dx',dy') by matrix
/idtransform {
12 dict begin
    dup type/arraytype ne { graphicsdict /currgstate get /currmatrix get } if
    aload pop % x y a b c d e f
    pop pop % x y a b c d
    {d c b a y x}{exch def}forall
    a d mul b c mul sub
    dup 0 eq { end /idtransform cvx /undefinedresult signalerror } if
    1 exch div
    /invdet exch def
    d x mul b y mul sub invdet mul
    c x mul neg a y mul add invdet mul
end
} def

% matrix1 matrix2  invertmatrix  matrix2
% fill matrix2 with inverse of matrix1
/invertmatrix {
    2 copy type/arraytype ne exch type/arraytype ne or
    { /invertmatrix cvx /typecheck signalerror } if
12 dict begin
    /A exch def
    A aload pop {f e d c b a}{exch def}forall
    a d mul b c mul sub
    dup 0 eq { A end /invertmatrix cvx /undefinedresult signalerror } if
    1 exch div
    /invdet exch def
    d invdet mul
    b neg invdet mul
    c neg invdet mul
    a invdet mul
    c f mul d e mul sub invdet mul
    b e mul a f mul sub invdet mul
    A astore
end
} def



% path == <<
%             0 << subpath0 >>
%             1 << %subpath1
%                   0  << elem0 /move >> %first elem must be /move
%                   1  << elem1 >>
%               >>
%         >>
% A /move element will always start a new subpath
% Any other element appends to the last subpath

% Path Construction Operators

% -  newpath  -
% initialize current path to be empty
/newpath {
    graphicsdict /currgstate get
        /currpath 1 dict put
} def

% -  currentpoint  x y
% return current point coordinates
/currentpoint {
    cpath dup length 0 eq {
        pop /currentpoint cvx /nocurrentpoint signalerror
    }{
        dup length 1 sub get % last-subpath
        dup length 1 sub get % last-elem
        /data get dup length 2 sub 2 getinterval % last data pair
        aload pop itransform
    } ifelse
} def

/cpath { graphicsdict /currgstate get /currpath get } def

/addtopath { % << /data [...] /cmd /... >> <<path>>
    dup length 0 eq {                       % elem path
        1 index /cmd get /move eq {         % elem path
            << 0 4 3 roll >> % new subpath  % <path> <subpath>
            0 exch put                      %
        }{
            /addtopath cvx /nocurrentpoint signalerror
        } ifelse
    }{                                  % elem path
        1 index /cmd get /move eq {     % elem path
            dup length 1 sub get        % elem path last-subpath
            dup length 1 sub get        % elem path last-elem-of-last-subp
            dup dup /cmd get /move eq { % elem path last-elem
                3 1 roll pop            % last-elem elem
                /data get /data exch put
            }{
                pop
                dup length 3 2 roll  % <path> n <elem>
                << 0 3 2 roll >> % new subpath  % <path> n <<0 <elem>>>
            } ifelse
        }{                              % elem path
            dup length 1 sub get        % <elem> <subpath>
            dup length                  % <elem> <subpath> key
            3 2 roll put     
        } ifelse
    } ifelse
} def

% x y  moveto  -
% set current point to (x,y)
/moveto {
    transform
    2 array astore
    << /data 3 2 roll /cmd /move >> cpath addtopath
} def

% dx dy  rmoveto  -
% relative moveto
/rmoveto {
    currentpoint
    3 2 roll add
    3 1 roll add exch
    moveto
} def

% x y  lineto  -
% append straight line to (x,y)
/lineto {
    transform
    2 array astore
    << /data 3 2 roll /cmd /line >> cpath addtopath
} def

% dx dy  rlineto  -
% relative lineto
/rlineto {
    currentpoint
    3 2 roll add
    3 1 roll add exch
    lineto
} def

% x1 y1 x2 y2 x3 y3  curveto  -
% append Bezier cubic section
/curveto {
    3 { 6 2 roll transform } repeat
    6 array astore
    << /data 3 2 roll /cmd /curve >> cpath addtopath
} def

% dx1 dy1 dx2 dy2 dx3 dy3  rcurveto  -
% relative curveto
/rcurveto {
    3 {
        6 2 roll currentpoint
        3 2 roll add
        3 1 roll add exch
    } repeat
    curveto
} def

% -  closepath  -
% connect subpath back to its starting point
/closepath {
    cpath length 0 gt {
        cpath dup length 1 sub get % subpath
        dup dup length 1 sub get % subpath last-elem
        /cmd get /close eq { % subpath
            pop
        }{                   % subpath
            0 get /data get % subpath [data]
            << /data 3 2 roll /cmd /close >> cpath addtopath
        } ifelse
    } if
} def

/flattendict <<
    /move { cpath addtopath }
    /line { cpath addtopath }
    /curve {
        << /data 3 2 roll /data get 4 2 getinterval /cmd /line >>
        cpath addtopath }
    /close { cpath addtopath }
>> def

/flattenpath {
    cpath length 0 gt {
        cpath newpath
        0 1 2 index length 1 sub { % path i
            2 copy get             % path i subpath_i
            dup length 0 gt {
                0 1 2 index length 1 sub { % p i sp_i j
                    2 copy get             % p i sp_i j sp_i_j
                    flattendict 1 index /cmd get get exec
                    pop                    % p i sp_i
                } for
                pop pop
            }{ pop pop } ifelse
        } for
        pop
    } if
} def

% move line curve close  pathforall  -
% enumerate current path
/pathforall {
5 dict begin
    {close curve line move}{exch def}forall
    0 1 cpath length 1 sub {
        /cp exch def
        0 1 cpath cp get % subpath
        length 1 sub {
            cpath cp get exch get % elem
            dup /cmd get /close ne {
                dup /data get % elem [data]
                aload length  % elem d a t a n
                1 add -1 roll % d a t a elem
            } if
            /cmd get cvx exec
        } for
    } for
end
} def


% Painting Operators



initgraphics

%currentfile flushfile
5 5 moveto currentpoint pstack clear
90 matrix rotate pstack clear
10 10 matrix scale pstack clear
300 400 matrix translate pstack clear
matrix matrix matrix concatmatrix pstack clear

2 0 translate
1 1 moveto
.25 .25 scale
90 rotate currentpoint pstack clear
90 rotate currentpoint pstack clear
90 rotate currentpoint pstack clear
90 rotate currentpoint pstack clear

/args{-1 1{-1 roll =}for}def

10 10 lineto
20 20 rlineto
0 0 1 1 2 0 rcurveto
closepath


()=
{ (moveto) 3 args }
{ (lineto) 3 args }
{ (curveto) 7 args }
{ (closepath) 1 args }
4 copy 
pathforall
(pathforall)=

gsave
    newpath
    (newpath)=
    4 copy pathforall
    (pathforall)=
grestore

4 copy pathforall
(pathforall)=

flattenpath
(flattenpath)=
pathforall
(pathforall)=

