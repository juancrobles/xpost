%procedures in systemdict
(loading init.ps...\n) print
systemdict begin

/version (0) def
/run { (r) file cvx exec } def
/Run { dup print flush run } def
/interrupt { stop } def
/true 0 0 eq def
/false 0 0 ne def

%traceon

/=string 128 string def
/=print {
    dup type /stringtype ne {
        //=string cvs
    } if
    print
} def
/strcat {
    2 copy
    length exch length exch 1 index add % a b an bn+an
    string dup 0 6 -1 roll putinterval % b an str
    dup 4 2 roll exch putinterval % (ab)
} def


%dumpnames dumpvm
%traceon
%debugloadon

%(/err.ps)
%(.) [ {
%    (XPOSTDIR) getenv %env
%    exch pop exch pop
%} stopped {cleartomark} if
%exch strcat Run
(err.ps)run


/= {
    //=print exec
    (\n) print
} def

/stack { count dup 1 add copy //= repeat pop } def

/execdict 6 dict def
execdict begin
    /quitflag false def
    /checkquit {
        //execdict /quitflag get
        { exit } if
    } def
    /execdepth 0 def
end

/start {
    /quit {
        %exit
        //execdict /quitflag true put
        interrupt
    } def

    %traceon
    /executive load stopped
    pop //quit % the operator
} def

/prompt {
    (PS) print
    count dup 0 eq { pop } { (<) print //=print exec } ifelse
    //execdict /execdepth get {
        (>) print
    } repeat
    flush
} def

/executive {
    //execdict begin

    /execdepth execdepth 1 add def
    /QUIET where { pop }{
        (Xpost3 Version ) print version print (\n) print
    } ifelse

    { %loop
        /quitflag false def
        //$error /newerror false put
        /prompt load stopped {
            (Error during prompt execution\n) print
            handleerror
            exit
        } if
        {
            mark
            /stmtfile (%statementedit) (r) file def
        } stopped {
            cleartomark
            //$error /newerror get {
                //$error /errorname get 
                /undefinedfilename ne { % ^d at prompt
                    handleerror
                } if
                //$error /newerror false put
                exit
            } if
        }{
            pop stmtfile end
            {
                cvx exec
            } stopped //execdict begin {
                handleerror
                stmtfile closefile
            } if
        } ifelse
        checkquit
    } loop
    /quitflag false def
    //execdict /execdepth 2 copy get 1 sub put

    end
    //$error /doclose false put
    interrupt
} bind
def

end
traceon
%debugloadon
$error/initializing false put
