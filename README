This is XPost3
______________
A work-in-progress Level-2 Postscript interpreter. Currently implements
the complete Level-1 core (minus graphics). Level-2 features implemented:
growing stacks, growing dicts, << /dictionary/syntax >>.

Upon cloning the repository, the commands `make` and `make test`
should compile all the modules and create and run all the tests.
`./itp` will run the "interpreter test", which runs the interactive executive.

The source should be portable across all gcc targets.
Please raise an issue at
    http://code.google.com/p/xpost/issues/list
if you have difficulty compiling. 

[ XPost2 is available in the downloads as a .zip of the source directory.
It was written and tested with Debian Lenny on an Olpc XO-1 laptop.
(Well, it's not the /whole/ source directory, but all text files needed
by the makefile) It is no longer being maintained.
for using:
    http://code.google.com/p/xpost/downloads/detail?name=xpost2g.zip
or, for just reading:
    http://code.google.com/p/xpost/downloads/detail?name=xpost2.pdf ]


XPost3 is being designed along different principles.
Transparency (debugability), simplicity (borrowing certain OOP concepts
like encapsulation), speed (choosing appropriate algorithms), extensibility
(growing stacks. support for multiple contexts). It is being written and
tested with cygwin on a Toshiba Satellite L875D.


  -- Modules --

The various modules were written and tested separately before being 
coupled together to achieve the necessary basic functionality.
Each module retains its unit-test, its main() function, guarded
by #ifdef TESTMODULE. `make test` will compile and execute all the 
unit tests, producing copious output, but importantly exitting with 
an appropriate success or failure code, so the `make test` command will 
fail if any of the tests fail.

    Module TOC
    __________

test   obj     src    header structures CONSTANTS
----   ---     ---     ---   --------------------
m      m.o     m.c     m.h   mfile mtab TABSZ
s      s.o     s.c     s.h   stack STACKSEGSZ
v      v.o     v.c     v.h   saverec_
       f.o     f.c     f.h    file
ob    ob.o    ob.c    ob.h   object
ar    ar.o    ar.c    ar.h    array
st    st.o    st.c    st.h    string
di    di.o    di.c    di.h   dichead dictionary
nm    nm.o    nm.c    nm.h    name
gc    gc.o    gc.c    gc.h    garbage collector
itp          itp.c   itp.h   context
      op.o    op.c    op.h    oper optab operator handler MAXOPS SDSIZE
      ----    ----    ----
      ops.o   ops.c   ops.h    stack operators
      opb.o   opb.c            boolean operators
      opc.o   opc.c            control operators
      opm.o   opm.c            math operators
      opst.o  opst.c  opst.h    string operators
      opar.o  opar.c  opar.h    array operators
      opdi.o  opdi.c  opdi.h    dictionary operators
       ~~~~~~~~~~           ~~~~~~~~~~~~~~~~~~~~~~~
 	    opdim                magic dictionary (* planned)
 	     opdimp               processes (*)
 	 	 opdimc               canvases (*)

The file and operator modules were copied with little modification
from xpost2, and so were not deemed to require separate tests.

        Hierarchy (Inter-relation(?))
        -------------
                itpdata
      gc     context     
        mfile       stack
             mtab     object
                 array
                 dict
                 string
 
The structures are rather closely "coupled" together.
Each piece relying upon appropriate facilities from other modules.
But a hierarchy of a sort does exist. The itpdata structure
directly contains the context and mfile structures in arrays.
The garbage collector is only interested in a single mfile at any
given time. mfiles contain mtabs which contain entities.
stacks live in mfiles, but the context's stacks (operand stack,
execution stack, dictionary stack) are accessed via "pointers"
stored in the context structure. objects live in stacks, but they
can also live in arrays or dicts. arrays and dicts and strings
are of course, all objects themselves.


Virtual Memory
--------------

  -- mfile --

At the heart is the "m" module: the memory-file and memory-tables.
Every mfile starts with an mtab. Every mtab lives in an mfile.
An mfile is a raw memory space cleverly(?) macro-ized to use
either malloc/realloc/free or mmap/mremap/munmap.
This memory space is sub-allocated with a segmented index, the mtabs.

A datum stored in memory is here alternately called an "entity"
(when referring to the abstract data type, ie. the object data itself,
the raw bytes) or an "entry" (when referring to the allocation metadata
in the table (its allocated size, the address of the data).

An execution context has two mfiles: one for global VM, one for local VM.
There will be 3 ways of forking a new context:
 1  Create copies of both global and local VM.
 2  Share global VM, but create a copy of local VM.
 3  Share both global and local VM.

  -- mtab --

At address 0 of the mfile is an mtab, a Memory Table.
An mtab is one segment of a chain of address tables which hold
the allocation info (size, flags) and the "pointer" to the data
itself. All VM "pointers" are integer byte-offsets from the vm
base pointer.

  -- mtab[0] Special Entities --

The first several entries of mtab[0] are "special entities".
All mfiles have (in the mtab[0]) a save stack (VS), a
free-list (FREE) and a context-list (CTXLIST) which contains `cid`s
of all contexts sharing that particular mfile. This was devised
to help encapsulate the context's global state within the mfile
construct. Even the operator table OPTAB is a special entity
and lives in global VM, not "global memory".
(In case somebody needs custom operators, it is possible).

Global VM goes on to hold NAMES, NAMET, BOGUSNAME, and HOLD.
NAMES and NAMET are for the Name String stack and Name Tree,
a ternary search tree. The same old ternary search tree,
this time updated to live in the memory file.

Bogusname is an allocated name string corresponding to the 
Not-Found result. So zero means no and asking what no means
is Bogus. HOLD is a stack to hold arguments popped from the
operand stack before being passed to operator functions. This
facilitates argument passing by cracking the hold stack array
(since the hold stack should be at most one segment. The desired
objects from the operand stack may span a segment boundary, but
in the hold stack, they are rooted (so we the stack as an array,
so we can select (switch) a function call based on the number of
objects).

        Special Entities
        ----------------
           context
    (mfile)gl   (mfile)lo
      mtab        mtab
        FREE        FREE
        VS          VS
        CTXLIST     CTXLIST
        NAMES       (planning to add local names, too)
        NAMET
        BOGUSNAME
        OPTAB       ----
        ----        live-entries (gc) ctx->lo->start
        live-entries (gc) ctx->gl->start

The special entities in the mtab facilitate bookkeeping of the
mtabs themselves (FREE, VS), locating associated contexts (CTXLIST),
and internal context data (possibly shared) (NAMES, NAMET, OPTAB).
If everything works right, the presence of BOGUSNAME should have
no visible effect to the user.



Stacks
------

Patterned after the model of the memory-table chain is the "s" module: 
the segmented stack.

And making use of both of these is the "v" module: the *virtual* part
of the virtual-memory, the save/restore stacks which live in the memory
file.

The three single-letter modules (m, s, & v) are considered the "core"
of the whole thing. I wrote these and then sat on them for over a year
while making revisions to xpost2, periodically re-reading the code
to make sure it still made sense.


Composite Objects
-----------------

Array, String and Dictionary functions now come in 2 flavors,
a "raw" version which expects to have the mfile specified, and
a "friendly" version which interprets the BANK field in the tag
to determine whether to look in the local or global VM.

	Raw array functions begin with "arr".
	Banked array " " " "bar".
	Raw dictionary " " " "dic".
	Banked dictionary " " " "bdc". (not thrilled with this one)
	Raw string " " " "str".
	Banked string " " " "bst".

Perhaps the banked ones should have normal names, and the "raw" ones should
have funky names. (cf. Murphy's Law)


Save and Restore
----------------

The save stack holds save-records with two entities, the source and the 
copy. restore merely has to exchange the addresses of the two entities.
All array and dictionary write operations ensure that the memory is 
saved at the current level before writing.
This should be more efficient than any of my previous drafts. 
"True" copy-on-write and no pointer-chasing.

Arrays ("ar") and dictionaries ("di") are automatically copied before
writing if the save-level has risen, giving cheap 'save's. 'restore'
has an easy job of popping the save-stack and exchanging the addresses
in the memory-tables: cheap 'restore's!!


Garbage Collection
------------------

The garbage collector module ("gc") implements a simple (?)
mark-sweep algorithm. It operates on a per-mfile basis, so global
and local VMs are collected separately, but all contexts sharing
an mfile must be traversed in the /mark/ phase.

I've tried to keep the algorithm very simple, because the memory
interface itself is so complicated. Even conceptually simple operations
like copying a pointer from the free list get pretty involved, eg.

    memcpy(mem->base+z, mem->base+adrent(mem,e), sizeof(unsigned));

This line copies the "pointer" (unsigned) value indicated by the
entry e into the memory "pointed to" by the "pointer" z.

It's there. It compiles. We'll see how well it works as I keep building.
Most allocation calls do a traversal of the free-list, so the
machinery is being exercised even though the testing is not very
comprehensive yet.


Operator Handling
-----------------

Xpost3 continues to use the same bizarre twisted loop to check
the stack contents for a combined typecheck/stackunderflow-error
+ polymorphic variadic dispatch, copying argument from the 
postscript stack to the operator-function's calling frame.
It's all very perverse and clever.

But profiling xpost2 showed a big bottleneck with all this trickery.
So a possible optimization is to replace the operator-signature
type with a dedicated function pointer to a function that 
implements the desired stack-checking. This would factor-out
quite a bit of redundant computation, I think. For instance,
most operators are not defined to accept the `anytype` pattern,
therefore most operators would check the stack faster by omitting
this clause. 

This will likely require some truly heinous name-mangling.


Bringing it all together
------------------------

New itp structure holds context table ctab, and mfile tables ltab and gtab.
New special entry CTXLIST lists all contexts associated with the mfile.

So the garbage collector's root-set for any given mfile is the VS
(the save stack) (only one for each mfile, shared contexts are blocked
during save/restore sections), and the stacks from each associated context.
It has also been made bank-aware. When collecting a global mfile, it
only marks global data; likewise for a local sweep, only mark locals.

Context IDs, `cid`s, are generated sequentially, starting from 1.
They are designed so that `(cid - 1) % MAXCONTEXT` will yield the
index in the ctab of the context. So the allocator increments 
until this formula yields an empty slot. This lets us re-use slots
while still maintaining unique IDs for all processes in the history
(until the `unsigned` wraps TO//DO fix this timebomb -- not a problem,
see http://programmers.stackexchange.com/questions/199635/ ).

Just learned from the PLRM that names should live in local-vm, not global.
But I'm thinking I'll keep a global table for the system names. Since the
optab lives in global-vm, I want operator names to be accessible in the
same mfile. But "user" names should be allocated in local vm. This means
names need to be banked just like composites.


Additional information about xpost
----------------------------------

The development of Xpost has benefited greatly from the support and
advice of fellow programmers on usenet in comp.lang.c, comp.lang.postscript,
comp.unix.programmer. Searching for my email addresses mijoryx@yahoo.com
or luser.droog@gmail.com should yield many discussions, many of which
pertain to xpost or to ideas that influence my programming style.
The classic is "Embarrassing spaghetti code needs stylistic advice".
I suppose the moral to that one is that I can hack up a loogee, but
I clean up nice, too. :)

Also, my questions on Stack Overflow should offer additional background.
http://stackoverflow.com/users/733077/luser-droog?tab=questions
And the answers I've received have been enormously helpful.

~~~~

Also, Exciting News! Possible integration of xpost and LibreOffice.
xpost would provide EPS import for LibreOffice.
LibreOffice would provide graphics support for xpost.
Win-Win.

https://bugs.freedesktop.org/show_bug.cgi?id=67464

I may need to release under a different license. Still learning 
about that part (who ain't??).

