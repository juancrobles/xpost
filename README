This is XPost3
______________
A work-in-progress Level-2 Postscript interpreter.

[ XPost2 is available in the downloads as a .zip of the source directory.
It was written and tested with Debian Lenny on an Olpc XO-1 laptop.
(Well, it's not the /whole/ source directory, but all text files needed
by the makefile) It is no longer being maintained.
for using:
    http://code.google.com/p/xpost/downloads/detail?name=xpost2g.zip
or, for just reading:
    http://code.google.com/p/xpost/downloads/detail?name=xpost2.pdf ]


XPost3 is being designed along different principles.
Transparency (debug-ability), simplicity (borrowing certain
OOP concepts like encapsulation), speed (choosing appropriate
algorithms), extensibility (growing stacks. support for
multiple contexts(?) ). It is being written and tested with cygwin
on a Toshiba Satellite L875D.

The various modules were written and tested separately before being 
coupled together to achieve the necessary basic functionality.
Each module retains its unit-test, its main() function, guarded
by #ifdef TESTMODULE. `make test` will compile and execute all the 
unit tests, producing copious output, but importantly exitting with 
an appropriate success or failure code, so the make command will 
fail if any of the tests fail.

    Modules
    _______

test  obj     src    header structures CONSTANTS
----  ---     ---     ---   --------------------
m     m.o     m.c     m.h   mfile mtab TABSZ
s     s.o     s.c     s.h   stack STACKSEGSZ
v     v.o     v.c     v.h   saverec_
      f.o     f.c     f.h    file
ob   ob.o    ob.c    ob.h   object
ar   ar.o    ar.c    ar.h    array
st   st.o    st.c    st.h    string
di   di.o    di.c    di.h   dichead dictionary
nm   nm.o    nm.c    nm.h    name
gc   gc.o    gc.c    gc.h    garbage collector
itp         itp.c   itp.h   context
     op.o    op.c    op.h    oper optab operator handler MAXOPS SDSIZE
    ops.o   ops.c   ops.h    stack operators
    opb.o   opb.c            boolean operators
    opc.o   opc.c            control operators
    opm.o   opm.c            math operators
   opst.o  opst.c  opst.h    string operators
   opar.o opar.c opar.h    array operators
   opdi.o opdi.c opdi.h    dictionary operators
	   opdim                magic dictionary
	    opdimp               processes
		opdimc               canvases


        Hierarchy (?)
        -------------
                itpdata
      gc     context     
        mfile       stack
             mtab     object
                 array
                 dict
                 string


        Special Entities
        ----------------
           context
    (mfile)gl   (mfile)lo
      mtab        mtab
        FREE        FREE
        VS          VS
        CTXLIST     CTXLIST
        NAMES       (planning to add local names, too)
        NAMET
        BOGUSNAME
        OPTAB       ----
        ----        live-entries (gc)
        live-entries (gc)


Memory
------

At the heart is the "m" module: the memory-file and memory-tables.
Every mfile starts with an mtab. Every mtab lives in an mfile.
An mfile is a raw memory space cleverly(?) macro-ized to use
either malloc/realloc/free or mmap/mremap/munmap.
This memory space is sub-allocated with a segmented index.
A datum stored in memory is here alternately called an "entity"
(when referring to the abstract data type, ie. the object data itself,
the raw bytes) or an "entry" (when referring to the allocation metadata
in the index (its allocated size, the address of the data).

An execution context has two mfiles: one for global VM, one for local VM.
When multiple contexts are implemented, I think the normal forking will
share the global, but create a new local (copying the parent?).

At address 0 of the mfile is an mtab, a Memory Table.
An mtab is one segment of a chain of address tables which hold
the allocation info (size, flags) and the "pointer" to the data
itself. All VM "pointers" are integer byte-offsets from the vm
base pointer.

  -- Special Entities --

The first several entries of mtab[0] are "special entities".
All mfiles have (in the mtab[0]) a save stack (VS), a
free-list (FREE) and a context-list (CTXLIST) which contains `cid`s
of all contexts sharing that particular mfile. This was devised
to help encapsulate the context's global state within the mfile
construct. Even the operator table OPTAB is a special entity
(in case somebody needs custom operators, it is possible).

Global VM goes on to hold NAMES, NAMET, BOGUSNAME, and HOLD.
NAMES and NAMET are for the Name String stack and Name Tree,
a ternary search tree. The same old ternary search tree,
this time updated to live in the memory file.

Bogusname is an allocated name string corresponding to the 
Not-Found result. So zero means no and asking what no means
is Bogus. HOLD is a stack to hold arguments popped from the
operand stack before being passed to operator functions. This
facilitates argument passing by cracking the hold stack array
(since the hold stack should be at most one segment. The desired
objects from the operand stack may span a segment boundary, but
in the hold stack, they are rooted (so we the stack as an array,
so we can select (switch) a function call based on the number of
objects).


Stacks
------

Patterned after the model of the memory-table chain is the "s" module: 
the segmented stack.

And making use of both of these is the "v" module: the *virtual* part
of the virtual-memory, the save/restore stacks which live in the memory
file.

The three single-letter modules (m, s, & v) are considered the "core"
of the whole thing.


Composite Objects
-----------------

Array, String and Dictionary functions now come in 2 flavors,
a "raw" version which expects to have the mfile specified, and
a "friendly" version which interprets the BANK field in the tag
to determine whether to look in the local or global VM.

	Raw array functions begin with "arr".
	Banked array " " " "bar".
	Raw dictionary " " " "dic".
	Banked dictionary " " " "bdc". (not thrilled with this one)
	Raw string " " " "str".
	Banked string " " " "bst".

Perhaps the banked ones should have normal names, and the "raw" ones should
have funky names. (Murphy's Law)


Save and Restore
----------------

The save stack holds save-records with two entities, the source and the 
copy. restore merely has to exchange the addresses of the two entities.
All array and dictionary write operations ensure that the memory is 
saved at the current level before writing.
This should be more efficient than any of my previous drafts. 
"True" copy-on-write and no pointer-chasing.

Arrays ("ar") and dictionaries ("di") are automatically copied before
writing if the save-level has risen, giving cheap 'save's. 'restore'
has an easy job of popping the save-stack and exchanging the addresses
in the memory-tables: cheap 'restore's!!


Garbage Collection
------------------

The garbage collector module ("gc") implements a simple (?)
mark-sweep algorithm. It operates on a per-mfile basis, so global
and local VMs are collected separately, but all contexts sharing
an mfile must be traversed in the /mark/ phase.

I've tried to keep the algorithm very simple, because the memory
interface itself is so complicated. Even conceptually simple operations
like copying a pointer from the free list get pretty involved, eg.

    memcpy(mem->base+z, mem->base+adrent(mem,e), sizeof(unsigned));

This line copies the "pointer" (unsigned) value indicated by the
entry e into the memory "pointed to" by the "pointer" z.

It's there. It compiles. We'll see how well it works as I keep building.
Most allocation calls do a traversal of the free-list, but I've set
the period of the collection triggers very high, since some functions
like markdict() haven't been written yet, so the contents of systemdict
aren't currently safe from collection.


Bringing it all together
------------------------

New itp structure holds context table ctab, and mfile tables ltab and gtab.
New special entry CTXLIST lists all contexts associated with the mfile.

So the garbage collector's root-set for any given mfile is the VS
(the save stack) (only one for each mfile, shared contexts are blocked
during save/restore sections), and the stacks from each associated context.
But it must also be made bank-aware. When collecting a global mfile, it
should only mark global data; likewise for a local sweep, only mark locals.

Context IDs, `cid`s, are generated sequentially, starting from 1.
They are designed so that `(cid - 1) % MAXCONTEXT` will yield the
index in the ctab of the context. So the allocator increments 
until this formula yields an empty slot. This lets us re-use slots
while still maintaining unique IDs for all processes in the history
(until the `unsigned` wraps TO//DO fix this timebomb -- not a problem,
see http://programmers.stackexchange.com/questions/199635/ ).

Just learned from the PLRM that names should live in local-vm, not global.
But I'm thinking I'll keep a global table for the system names. Since the
optab lives in global-vm, I want operator names to be accessible in the
same mfile. But "user" names should be allocated in local vm. This means
names need to be banked just like composites.


