This is the first draft of a description of xpost from the user side.
What can it do? How much of Postscript is written? How much is tested?

All of these are very good questions. Hopefully we'll address some of
them in the following.

Xpost3 is still in the "under-construction" phase. But I'm happy enough
with it that I think it should be considered an "alpha" status product.
The testing is not extensive, but it is in place, and has been used 
throughout the development. In fact the interpreter that can be run
right now is actually just the "interpreter test" of the interpreter
module. But, enough of that. I promised no "internals" here.

It's an important fact that the available interpreter is the interpreter
*test*, because when you clone the repo and run `make` or `make all` 
(which are the same), you'll also need to run `make test` or `make itp`
to create the ./itp executable. Once it's ready to be part of `make all`,
that will herald "beta" status.

== Download and get a PS> prompt ==

Requires a working gnu gcc installation with make and /bin/sh and
everything. Tested on cygwin, should work fine on Linux.

Clone the Mercurial repository with

  hg clone https://luser.droog@code.google.com/p/xpost/ 

Configure and compile all the source objects.

  ./autogen.sh (or ./configure if autogen.sh has already been launched)
  make

  [ The testing portion needs reworking and is not currently
  compiled by make. ........................................

Compile and run the tests (Recommended. But you can also run
`make itp` and launch the interpreter with `./itp`.)

  make test

Double-check exit-status code from the tests.

  echo $?

or `echo $status` in csh.
   ........................................................]

Run the interpreter.

  cd src/bin
  ./itp

^test itp.c
loading init.ps...
loading err.ps...
Xpost3 Version 0
PS>

Type `quit` or send an EOF (ctrl-D or maybe ctrl-Z) to quit
the interpreter.

<operator 1 exch 0x406ea1>bye!

There's an operator dump just before exit. I'd be very curious to
know if anyone ever gets different values for the hex-number
which is the pointer value of the C-function for the exch operator.
I've asked about this on Stack Overflow.

  http://stackoverflow.com/questions/18040735/will-statically-linked-functions-have-the-same-pointer-values-across-runs-on-the

If the values are constant for most systems, then we can consider
the quick-launch idea to be a viable pursuit. For the moment the
risk is such that the whole thing falls into the "premature optimization"
bucket. 


== Examples ==

There are a few example programs demonstrating xpost's functionality
even though it doesn't do any graphics, yet.

binshape.ps  -  draw an infinite output of random 0s and 1s
digit.ps - (doesn't work yet. uses <~ascii85~>, which xpost won't process (yet))
hwbin.ps - hello world using binary radix numbers
hwhex.ps - hello world using hexstring
tab340.ps - the smmaller golfed tablature generator
tab418.ps - the larger golfed tablature generator
tabref.ps - the large reference tablature generator
ubf119.ps - the 119 char universal binary-function lookup table
ubf70.ps - the 70 char universal binary-function lookup table

Some of these were written to make use of Ghostscript's argument
processing option `gs -- prog.ps arg0 arg1 arg2`. But xpost3 doesn't
do that yet, so you'll have to define

  /ARGUMENTS [ (A) (Bm) (F#m) (F#m) ] def

as an array of strings before you `(tab340.ps)run` or whatever.
Check the source to see if it uses ARGUMENTS to know if you need
to set this variable before running.


== Postscript arithmetic ==

Just a brief review of what you should already know if you're trying
to use xpost. Postscript uses a Reverse-Polish Syntax where the 
operator follows the operands.

  a + b      Infix Notation (ALGOL, C)
  ( + a b )  "Cambridge" Polish Notation (Lisp)
  a b +      Reverse Polish Notation (RPN)

Postscript does not use punctuation symbols for the operators,
but short words.

    add sub mul div
    idiv mod            2 operand
    atan exp

    cos sin sqrt
    ln log              1 operand
    abs neg
    floor ceiling
    truncate round

For example, if you define /a, /b, and /c to contain values for
the variables in the formula "ax^2 + bx + c",

%<-- Postscript comments begin with '%' and run till the end of line -->$
    /a 25 def
    /b 10 def
    /c 3 def

and a definition for x,

    /x 12 def

you can calculate the value of the formula like this:

    a x x mul mul  % ax^2
    b x mul        % ax^2 bx
    c   add   add  % ax^2+bx+c

== Stack manipulation ==

To turn this formula into a function, we need to take the input
for the function and define it as x before applying the formula.

    % x  quadratic  ax^2+bx+c
    /quadratic {
        /x exch def
        a x x mul mul
        b x mul
        c add add
    } def

When the function is entered, the input value is on the operand stack.

    number
   |------|

Then we push the (literal) name /x.

      /x
    number
   |------|

Unfortunately, `def` expects them to be in this order:

    number
      /x
   |------|

Hence `exch` is used to reorder the top two elements of the stack.
When reading a postscript sequence like `/name exch def` one way to
think of `exch` is like a pronoun whose antecedent is just below
the name.

    whatev  /x  exch  def
       ^         |
        ---------

The function so far isn't very general. So let's tease out a, b, and
c and make them parameters, too, instead of hard-coded names.

    % a b c x  quadratic  ax^2+bx+c
    /quadratic {
        /x exch def   % a b c
        3 1 roll      % c a b
        x mul         % c a bx
        3 1 roll      % bx c a
        x x mul mul   % bx c ax^2
        add add
    } def

This brings us to `roll`. As you can see from the stack comments,
`3 1 roll` permutes three elements of the stack. The first
number is how many elements to manipulate. And the second number
indicates how many elements to move and in which direction.

    /a /b /c   % a b c
    3 1 roll   % c a b
    3 -1 roll  % a b c
    3 2 roll   % b c a
    3 3 roll   % b c a
    3 0 roll   % b c a
    3 2 roll   % c a b
    3 -1 roll  % a b c


    n j roll

    __ j > 0 __     move top j elements to the bottom of n

    n            TOS
     -------------|
    |       j     |
    |        -----|
    |       |     |
    V       V     |
    a b c d e f g h
   ^       |       |
   |       |-------|
   ^           |
    -<-<-<-<-<-


    __ j < 0 __   move j elements from the bottom of n to the top

    n            TOS
     -------------|
    |     j       |
    |-----        |
    |     |       |
    V     V       |
    a b c d e f g h
   |       |       ^
   |-------|       |
       |           ^
        ->->->->->-

    "Positive J to roll away", "Negative to bring 'em back".

So the next step in revising our function is to remove the /x name 
as well.

  % a b c x  quadratic  ax^2+bx+c
  /quadratic {
      4 2 roll     % c x a b
      1 index mul  % c x a bx
      4 1 roll     % bx c x a
      1 index mul  % bx c x ax
      mul          % bx c ax^2
      add add
  } def

If we apply `bind` to the procedure, all the operator names will
be replaced by the operators themselves, and the function now 
performs no dictionary lookups at all.

  /quadratic load bind ==
{ 4 2 -roll- 1 -index- -mul- 4 1 -roll- 1 -index- -mul- -mul- -add- -add- }

This function will now execute as quickly as possible,
and it will not interact with the current namespace 
and it does not allocate any data.


== Arrays ==

It should be apparent from the last example that a procedure is
just an array, wrapped in curly braces rather than square brackets.

So we could construct the same procedure in the following way.

  /quadratic [
  4 2 /roll load 1 /index load /mul load
  4 1 /roll load 1 /index load /mul load
  /mul load /add load /add load
  ] cvx def

This is similar to the way bind constructs its bound procedure,
by loading the operator objects by name and embedding them in
the array. One must be careful in using the direct method shown
here. Some operators are implemented as procedures and will
not be executed if simply substituted as above. `bind` replaces
only names that refer to operator objects. A more general approach
would inject `exec` calls after sub-procedures.

For example, suppose we want (for some crazy reason) this procedure
to simply print its result, and not leave it on the stack.
There's an operator `=` to do just that. But ... `=` is a procedure!

So, this won't work:
  /quadratic [
  4 2 /roll load 1 /index load /mul load
  4 1 /roll load 1 /index load /mul load
  /mul load /add load /add load
  /= load %<-- NO! Bad! procedure will not execute
  ] cvx def

This will:
  /quadratic [
  4 2 /roll load 1 /index load /mul load
  4 1 /roll load 1 /index load /mul load
  /mul load /add load /add load
  /= load /exec load  %<-- must explicitly execute "procedure" operators
  ] cvx def

You see the convenience of bind. It performs all those loads for you,
but leaves the procedure invocation intact.

  /quadratic {
      4 2 roll 1 index mul
      4 1 roll 1 index mul
      mul add add = } bind def
  /quadratic load ==

{ 4 2 -roll- 1 -index- -mul- 4 1 -roll- 1 -index- -mul- -mul- -add- -add- = }


== Sub-prompts ==

Xpost's %statementedit special file features secondary prompts at each
newline, reminding you of which open constructs are awaiting a terminator.

$ ./itp

^test itp.c
loading init.ps...
loading err.ps...
$error
Xpost3 Version 0
PS>{
{.:}
PS<1>(
(.:)
PS<2>[
PS<3>]
PS<3>pstack
[ ] 
(
)
{ } 
PS<3>{{{
{{{.:}
{{.:}
{.:}
PS<4>

