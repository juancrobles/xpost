%!PS-Adobe-3.0
%%Title: makefile, ar.h, di.h, err.h, f.h, gc.h, itp.h, m.h, nm.h, ob.h
%%For: U-Z1\josh
%%Creator: a2ps version 4.14
%%CreationDate: Mon Sep  9 01:13:59 2013
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 86
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontMatrix get 3 get 1000 mul
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      % <vector> <key> <val>
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def % -

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Get the underline position and thickness if they're defined.
    % Use 1 if they are not defined.
    currentdict /FontInfo 2 copy known
    { get
      /UnderlinePosition 2 copy % <FontInfo> /UP <FontInfo> /UP
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>

      /UnderlineThickness 2 copy % <FontInfo> /UT <FontInfo> /UT
      2 copy known
      { get }{ pop pop 1 } ifelse
      0 exch FontMatrix transform exch pop
      def % <FontInfo>
      pop % -
    }{ pop pop
    } ifelse

    currentdict
  end 
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.493857 def
/cw 4.496314 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   522.321860 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(CFLAGS) l
(= -g -m32 -Wall -Wextra ) p n
(OB) l
(=ob.o m.o err.o) p n
(LDLIBS) l
(=-lm) p n
(SRC) l
(= makefile *.h *.c init.ps err.ps g.ps clip.ps test.ps) p n
(CORE) l
(=s.o st.o ar.o di.o nm.o gc.o v.o f.o) p n
(OP) l
(=op.o ops.o opst.o opar.o opdi.o optok.o opb.o opc.o opt.o \\) p n
(    opm.o opf.o opv.o opx.o oppa.o osunix.o) N
(TESTS_OBJ) l
(=m.o ob.o s.o st.o nm.o v.o gc.o ar.o di.o itp.o) p n
(TESTS) l
(=$\(TESTS_OBJ:.o=\)) p n
() N
(.o.c:) N
() N
(objects) L
(: $\(CORE\) $\(OP\) $\(OB\) $\(TESTS_OBJ\)) p n
() N
(all) L
(: objects) p n
() N
(test) K
(: objects $\(TESTS\)) p n
() S 8 T (\(./ob && ./m && ./s && ./st && ./nm && \\) N
() S 8 T (./v && ./gc && ./ar && ./di && \\) N
() S 8 T (echo ") S
(\(test.ps\)Run quit) str
(" | ./itp\) > testoutput) p n
() S 8 T (tail testoutput) N
() N
(list) L
(:xpost3.ps) p n
() N
(xpost3.ps) L
(:$\(SRC\)) p n
() S 8 T (a2ps -Av --toc -o $@ --delegate=off $\(SRC\)) N
() N
(count) L
(:) p n
() S 8 T (wc -l $\(SRC\)) N
() N
(clean) L
(:) p n
() S 8 T (rm -f *.o *.exe g.mem l.mem x.mem) N
() N
(splint) L
(:) p n
() S 8 T (splint +posixlib -boolops -predboolint +ignoresigns -type +charindex \\) N
(-nestcomment -noeffect -redef -shiftnegative -castfcnptr \\) N
(-shiftimplementation -predboolothers -exportlocal -mustfreefresh ./*.c) N
() N
(m.ps) L
(:m.pic) p n
() S 8 T (pic m.pic|groff > m.ps) N
(m.eps) L
(:m.ps) p n
() S 8 T (ps2eps m.ps) N
(m.png) L
(:m.eps) p n
() S 8 T (convert m.eps m.png) N
(s.ps) L
(:s.pic) p n
() S 8 T (pic s.pic|groff > s.ps) N
(s.eps) L
(:s.ps) p n
() S 8 T (ps2eps s.ps) N
(s.png) L
(:s.eps) p n
() S 8 T (convert s.eps s.png) N
() N
(m) L
(:m.c ob.h ob.o err.o $\(CORE\) itp.o $\(OP\)) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o     ob.o s.o ar.o st.) N
(o v.o di.o gc.o nm.o itp.o $\(OP\) f.o) N
() N
(ob) L
(:ob.c ob.h) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $<) N
() N
(s) L
(:s.c m.o ob.o) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o     ar.o st.) N
(o v.o di.o gc.o nm.o itp.o $\(OP\) f.o) N
() N
(nm) L
(:nm.c m.o ob.o s.o st.o gc.o itp.o $\(OP\)) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o ar.o st.) N
(o v.o di.o gc.o      itp.o $\(OP\) f.o) N
() N
(v) L
(:v.c s.o m.o ob.o gc.o ar.o) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o ar.o st.) N
(makefile) (Page 1/2) (Sep 09, 13 1:13) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(o     di.o gc.o nm.o itp.o $\(OP\) f.o) p n
() N
(gc) L
(:gc.c s.o m.o ob.o gc.o ar.o st.o v.o) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o ar.o st.) N
(o v.o di.o      nm.o itp.o $\(OP\) f.o) N
() N
(st) L
(:st.c m.o gc.o itp.o $\(OP\)) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o ar.o    ) N
(  v.o di.o gc.o nm.o itp.o $\(OP\) f.o) N
() N
(ar) L
(:ar.c s.o m.o ob.o gc.o st.o v.o gc.o itp.o nm.o $\(OP\)) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o st.o v.o) N
( di.o gc.o nm.o      itp.o $\(OP\) f.o) N
() N
(di) L
(:di.c s.o m.o ob.o gc.o ar.o st.o v.o gc.o itp.o nm.o $\(OP\)) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o ar.o st.) N
(o v.o      gc.o nm.o itp.o $\(OP\) f.o) N
() N
(itp) L
(:itp.c s.o m.o ob.o gc.o ar.o st.o v.o gc.o nm.o di.o $\(OP\) f.o err.o) p n
() S 8 T (cc $\(CFLAGS\) -DTESTMODULE $\(LDLIBS\) -o $@ $< err.o m.o ob.o s.o ar.o st.) N
(o v.o di.o gc.o nm.o       $\(OP\) f.o) N
() S 8 T () N
() N
(makefile) (Page 2/2) (Sep 09, 13 1:13) title
border
grestore
(Printed by U-Z1\\josh) rhead
(makefile) (1/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* arrays) c n
(   an array object is 8 bytes,) N
(   consisting of 4 16bit fields common to all composite objects) N
(     tag, type enum and flags) N
(     sz, count of objects in array) N
(     ent, entity number) N
(     off, offset into allocation) N
(   the entity data is a "C" array of objects) N
(   */) N
() p n
(/* consarr - construct an array object) c n
(   in the mtab of specified mfile */) N
(object consarr\(mfile *mem, ) p
(unsigned) k
( sz\);) p n
() N
(/* consbar - construct an array object) c n
(   selecting mfile according to ctx->vmmode */) N
(object consbar\(context *ctx, ) p
(unsigned) k
( sz\);) p n
() N
(/* store value */) c n
(void) k
( arrput\(mfile *mem, object a, integer i, object o\);) p n
(void) k
( barput\(context *ctx, object a, integer i, object o\);) p n
() N
(/* extract value */) c n
(object arrget\(mfile *mem, object a, integer i\);) p n
(object barget\(context *ctx, object a, integer i\);) N
() N
(/* adjust the size and offset fields in the object) c n
(   \(works for strings, too\)) N
( */) N
(object arrgetinterval\(object a, integer s, integer n\);) p n
() N
() N
(ar.h) (Page 1/1) (Jul 30, 13 15:03) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* dictionaries) c n
(   a dictionary object is 8 bytes) N
(   consisting of 4 16bit fields common to composite objects) N
(     tag, type enum and flags) N
(     sz, count of objects in array) N
(     ent, entity number) N
(     off, offset into allocation) N
(   the entity data is a header structure) N
(   followed by header->sz+1 key/value pairs of objects in a linear array) N
(   null keys denote empty slots in the hash table.) N
(   */) N
() p n
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word sz;) N
(    word nused;) N
(    word pad;) N
(} dichead;) N
() N
(/* dicts are implicitly 1 entry larger than declared) c n
(   in order to simplify searching \(terminate on null\) */) N
() p n
(/* DICTABN yields the number of real entries for a dict of size n */) c n
(#define) K
( DICTABN\(n\) \(2 * \(\(n\)+1\)\)) p n
() N
(/* DICTABSZ yields the size in bytes */) c n
(#define) K
( DICTABSZ\(n\) \(DICTABN\(n\) * ) p
(sizeof) K
(\(object\)\)) p n
() N
(/* compare objects \(<,=,>\) :: \(-\(x\),0,+\(x\)\) */) c n
(int) k
( objcmp\(context *ctx, object l, object r\);) p n
() N
(/* construct dictionary) c n
(   in mtab of specified mfile */) N
(object consdic\() p
(/*@dependent@*/) c
( mfile *mem, ) p
(unsigned) k
( sz\);) p n
() N
(/* construct dictionary) c n
(   selected mtab with ctx->vmmode */) N
(object consbdc\(context *ctx, ) p
(unsigned) k
( sz\);) p n
() N
(/* investigate current sizes of dictionary */) c n
(unsigned) k
( diclength\() p
(/*@dependent@*/) c
( mfile *mem, object d\);) p n
(unsigned) k
( dicmaxlength\() p
(/*@dependent@*/) c
( mfile *mem, object d\);) p n
(bool dicfull\() S
(/*@dependent@*/) c
( mfile *mem, object d\);) p n
() N
(void) k
( dumpdic\(mfile *mem, object d\);) p n
() N
(double) k
( doubleextended \(object e\);) p n
(object unextend \(object e\);) N
() N
(/* test dictionary for key */) c n
(bool dicknown\(context *ctx, ) p
(/*@dependent@*/) c
( mfile *mem, object d, object k\);) p n
() N
(/* lookup value */) c n
(object dicget\(context *ctx, ) p
(/*@dependent@*/) c
( mfile *mem, object d, object k\);) p n
(object bdcget\(context *ctx, object d, object k\);) N
() N
(/* store value */) c n
(void) k
( dicput\(context *ctx, ) p
(/*@dependent@*/) c
( mfile *mem, object d, object k, object) p n
( v\);) N
(void) k
( bdcput\(context *ctx, object d, object k, object v\);) p n
() N
(/* undefine key */) c n
(void) k
( bdcundef\(context *ctx, object d, object k\);) p n
() N
(di.h) (Page 1/1) (Aug 24, 13 14:09) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ar.h, di.h) (2/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
(   For a commentary on these macros, see my answer to this SO question) N
(http://stackoverflow.com/questions/6635851/real-world-use-of-x-macros/6636596#66) N
(36596) N
() N
(    error\(\) is the internal error call.) N
(    If the jump-point is set, it does a longjmp back to mainloop, which then) N
(    calls onerror\(\)) N
() N
(    Having unwound the "C" stack already,) N
(    onerror\(\) goes on to schedule a \(PS\) call to err.ps/signalerror and the rest) N
(    of the process proceeds at the postscript level.) N
(   */) N
() p n
(#define) K
( AS_BARE\(a\) a ,) p n
(//#define AS_STR\(a\) #a , //defined in ob.h) c n
() p n
(#define) K
( ERRORS\(_\) \\) p n
(    _\(noerror\) \\) N
(    _\(dictfull\) \\) N
(    _\(dictstackoverflow\) \\) N
(    _\(dictstackunderflow\) \\) N
(    _\(execstackoverflow\) \\) N
(    _\(execstackunderflow\) ) S
(/*5*/) c
(\\) p n
(    _\(handleerror\) \\) N
(    _\(interrupt\) \\) N
(    _\(invalidaccess\) \\) N
(    _\(invalidexit\) \\) N
(    _\(invalidfileaccess\) ) S
(/*10*/) c
(\\) p n
(    _\(invalidfont\) \\) N
(    _\(invalidrestore\) \\) N
(    _\(ioerror\) \\) N
(    _\(limitcheck\) \\) N
(    _\(nocurrentpoint\) ) S
(/*15*/) c
(\\) p n
(    _\(rangecheck\) \\) N
(    _\(stackoverflow\) \\) N
(    _\(stackunderflow\) \\) N
(    _\(syntaxerror\) \\) N
(    _\(timeout\) ) S
(/*20*/) c
(\\) p n
(    _\(typecheck\) \\) N
(    _\(undefined\) \\) N
(    _\(undefinedfilename\) \\) N
(    _\(undefinedresult\) \\) N
(    _\(unmatchedmark\) ) S
(/*25*/) c
(\\) p n
(    _\(unregistered\) \\) N
(    _\(VMerror\)) N
(enum) k
( err { ERRORS\(AS_BARE\) };) p n
(extern) K
( ) p
(char) k
( *errorname[] ) p
(/*= { ERRORS\(AS_STR\) }*/) c
(;) p n
(/* puts\(errorname[\(enum err\)limitcheck]\); */) c n
() p n
(extern) K
( ) p
(volatile) K
( ) p
(char) k
( *errormsg;) p n
() N
(void) k
( error\() p
(unsigned) k
( err, ) p
(char) k
( *msg\);) p n
(void) k
( onerror\(context *ctx, ) p
(unsigned) k
( err\);) p n
() N
(err.h) (Page 1/1) (Aug 14, 13 23:08) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
(   a filetype object uses .mark_.padw to store the ent) N
(   for the FILE *) N
(   */) N
() p n
(FILE) k
( *lineedit\() p
(FILE) k
( *in\);) p n
(FILE) k
( *statementedit\() p
(FILE) k
( *in\);) p n
(object consfile\(mfile *mem, ) S
(/*@NULL@*/) c
( ) p
(FILE) k
( *fp\);) p n
(object fileopen\(mfile *mem, ) S
(char) k
( *fn, ) p
(char) k
( *mode\); ) p n
(FILE) k
( *filefile\(mfile *mem, object f\);) p n
(bool filestatus\(mfile *mem, object f\);) N
(long) k
( filebytesavailable\(mfile *mem, object f\);) p n
(void) k
( fileclose\(mfile *mem, object f\);) p n
(object fileread\(mfile *mem, object f\);) N
(void) k
( filewrite\(mfile *mem, object f, object b\);) p n
() N
() N
(f.h) (Page 1/1) (Aug 17, 13 5:21) title
border
grestore
(Printed by U-Z1\\josh) rhead
(err.h, f.h) (3/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* garbage collector) c n
(   */) N
() p n
(enum) k
( {) p n
(    PERIOD = 200  ) S
(/* number of times to grow before collecting */) c n
(}; ) p n
() N
(/* initialize the FREE special entity which points to the head of the free list ) c n
(*/) N
(void) k
( initfree\(mfile *mem\);) p n
() N
(/* allocate data, re-using garbage if possible */) c n
(unsigned) k
( gballoc\(mfile *mem, ) p
(unsigned) k
( sz\);) p n
() N
(/* explicitly add ent to free list */) c n
(void) k
( mfree\(mfile *mem, ) p
(unsigned) k
( ent\);) p n
() N
(/* perform a collection on mfile */) c n
(void) k
( collect\(mfile *mem\);) p n
() N
(/* reallocate data, preserving \(the maximum of\) original contents */) c n
(unsigned) k
( mfrealloc\(mfile *mem, ) p
(unsigned) k
( oldadr, ) p
(unsigned) k
( oldsize, ) p
(unsigned) k
( newsi) p n
(ze\);) N
() N
(gc.h) (Page 1/1) (Aug 04, 13 4:53) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* the interpreter) c n
(       eval actions) N
(       core interpreter loop) N
(       bank utility function for extracting from the context the mfile relevant ) N
(to an object) N
(   */) N
() p n
(typedef) K
( ) p
(struct) k
( {) p n
(    ) S
(unsigned) k
( id;) p n
(    ) S
(/*@dependent@*/) c
( mfile *gl, *lo;) p n
(    ) S
(unsigned) k
( os, es, ds, hold;  ) p n
(    ) S
(unsigned) k
( ) p
(long) k
( rand_next;) p n
(    ) S
(unsigned) k
( vmmode; ) p n
(    ) S
(unsigned) k
( state;) p n
(    ) S
(unsigned) k
( quit;) p n
(    object currentobject;) N
(} context;) N
() N
(enum) k
( { LOCAL, GLOBAL }; ) p
(//vmmode) c n
(#define) K
( MAXCONTEXT 10) p n
(#define) K
( MAXMFILE 10) p n
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    context ctab[MAXCONTEXT];) N
(    ) S
(unsigned) k
( cid;) p n
(    mfile gtab[MAXMFILE];) N
(    mfile ltab[MAXMFILE];) N
(} itp;) N
() N
() N
(#include) K
( <setjmp.h>) p n
(extern) K
( itp *itpdata;) p n
(extern) K
( ) p
(int) k
( initializing;) p n
(extern) K
( jmp_buf jbmainloop;) p n
(extern) K
( bool jbmainloopset;) p n
() N
(void) k
( initctxlist\(mfile *mem\);) p n
(context *ctxcid\() S
(unsigned) k
( cid\);) p n
(void) k
( initcontext\(context *ctx\);) p n
(void) k
( exitcontext\(context *ctx\);) p n
(/*@dependent@*/) c n
(mfile *bank\(context *ctx, object o\);) p n
() N
(extern) K
( ) p
(int) k
( TRACE;) p n
() N
(void) k
( inititp\(itp *itp\);) p n
(void) k
( exititp\(itp *itp\);) p n
() N
(itp.h) (Page 1/1) (Aug 02, 13 19:32) title
border
grestore
(Printed by U-Z1\\josh) rhead
(gc.h, itp.h) (4/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*  memory \(master\)) c n
(    mfile and mtab) N
(    ) N
(    An mfile is a container representing *half* of virtual memory,) N
(    either local or global. A global-vm mfile has more special entities) N
(    in its mtab than a local-vm mfile.) N
() N
(    An mtab is a chain of address tables \(starting at address 0\)) N
(    that manage the contents of the mfile.) N
() N
(    This file also contains enums that more properly belong in itp.h) N
(    as they direct the global configuration of the interpreter, not just) N
(    the memory interface.) N
(   */) N
() p n
(/* define MMAP and MREMAP for Linux */) c n
(/* define MMAP without MREMAP should work for Irix \(using AUTOGROW\) */) N
(/* no MREMAP under cygwin \(we'll see how AUTOGROW handles...\)*/) N
(/* define neither to use malloc/realloc/free */) N
(//#define MMAP) N
(//#define MREMAP) N
() p n
(#ifdef) K
( MMAP) p n
(#include) K
(<sys/mman.h>) p n
(#  ifdef) K
( MREMAP) p n
(#    define) K
( _GNU_SOURCE ) p
(/* mremap */) c n
(#  endif) K n
(#endif) N
() p n
(/* the "grain" of the mfile size */) c n
(extern) K
( ) p
(unsigned) k
( pgsz ) p
(/*= getpagesize\(\)*/) c
(; ) p
(/*=4096 \(usually on 32bit\)*/) c n
() p n
(typedef) K
( ) p
(struct) k
( {) p n
(    ) S
(int) k
( fd;) p n
(    ) S
(/*@dependent@*/) c
( ) p
(unsigned) k
( ) p
(char) k
( *base;) p n
(    ) S
(unsigned) k
( used;) p n
(    ) S
(unsigned) k
( max;) p n
() N
(    ) S
(//no longer used, all sharing contexts have roots) c n
(    ) p
(//unsigned roots[2]; /* low, high : entries */) c n
() p n
(    ) S
(unsigned) k
( start; ) p
(/* first "live" entry */) c n
(        ) p
(/* the domain of the collector is entries >= start */) c n
(} mfile;) p n
() N
(/* dump metadata and contents */) c n
(void) k
( dumpmfile\(mfile *mem\);) p n
() N
(/* initialize the mfile, possibly from file */) c n
(void) k
( initmem\(mfile *mem, ) p
(char) k
( *fname\);) p n
() N
(/* destroy the mfile, possibly writing to file */) c n
(void) k
( exitmem\(mfile *mem\);) p n
() N
(/* resize the mfile, possibly invalidating all vm pointers */) c n
(mfile *growmem\(mfile *mem, ) p
(unsigned) k
( sz\);) p n
() N
(/* allocate memory, returns offset in memory file */) c n
(unsigned) k
( mfalloc\(mfile *mem, ) p
(unsigned) k
( sz\);) p n
() N
() N
(#define) K
( TABSZ 200) p n
(typedef) K
( ) p
(struct) k
( {) p n
(    ) S
(unsigned) k
( nexttab; ) p
(/* next table in chain */) c n
(    ) p
(unsigned) k
( nextent; ) p
(/* next slot in table, or TABSZ if none */) c n
(    ) p
(struct) k
( {) p n
(        ) S
(unsigned) k
( adr;) p n
(        ) S
(unsigned) k
( sz;) p n
(        ) S
(unsigned) k
( mark;) p n
(m.h) (Page 1/2) (Aug 14, 13 22:06) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    } tab[TABSZ];) p n
(} mtab;) N
() N
() N
(/* fields in mtab.tab[].mark */) c n
(enum) k
( {) p n
(    MARKM = 0xFF000000,) N
(    MARKO = 24,) N
(    RFCTM = 0x00FF0000,) N
(    RFCTO = 16,) N
(    LLEVM = 0x0000FF00,) N
(    LLEVO = 8,) N
(    TLEVM = 0x000000FF,) N
(    TLEVO = 0,) N
(};) N
() N
(/* special entries */) c n
(/* local mfiles set .start to CTXLIST+1,) N
(      and all context stacks are in the root set) N
(   global mfiles set .start to OPTAB+1) N
(      and NAMES is in the root set) N
(      \(and all context /globaldict's?\)) N
( */) N
(enum) k
( {) p n
(    FREE,   ) N
(    VS,) N
(    CTXLIST,) N
(    NAMES,) N
(    NAMET,) N
(    BOGUSNAME,) N
(    OPTAB,  ) S
(/* this 1 global only */) c n
(};) p n
() N
(/* dump mtab details to stdout */) c n
(void) k
( dumpmtab\(mfile *mem, ) p
(unsigned) k
( mtabadr\);) p n
() N
(/* allocate and initialize a new table */) c n
(unsigned) k
( initmtab\(mfile *mem\);) p n
() N
(/* allocate memory, returns table index */) c n
(unsigned) k
( mtalloc\(mfile *mem, ) p
(unsigned) k
( mtabadr, ) p
(unsigned) k
( sz\);) p n
() N
(/* find the table and relative entity index for an absolute entity index */) c n
(void) k
( findtabent\(mfile *mem, ) p
(/*@out@*/) c
( mtab **atab, ) p
(/*@out@*/) c
( ) p
(unsigned) k
( *aent\);) p n
() N
(/* get the address from an entity */) c n
(unsigned) k
( adrent\(mfile *mem, ) p
(unsigned) k
( ent\);) p n
() N
(/* get the size of an entity */) c n
(unsigned) k
( szent\(mfile *mem, ) p
(unsigned) k
( ent\);) p n
() N
(/* fetch a value from a composite object */) c n
(void) k
( get\(mfile *mem,) p n
(        ) S
(unsigned) k
( ent, ) p
(unsigned) k
( offset, ) p
(unsigned) k
( sz,) p n
(        ) S
(/*@out@*/) c
( ) p
(void) k
( *dest\);) p n
() N
(/* put a value into a composite object */) c n
(void) k
( put\(mfile *mem,) p n
(        ) S
(unsigned) k
( ent, ) p
(unsigned) k
( offset, ) p
(unsigned) k
( sz,) p n
(        ) S
(/*@in@*/) c
( ) p
(void) k
( *src\);) p n
() N
(m.h) (Page 2/2) (Aug 14, 13 22:06) title
border
grestore
(Printed by U-Z1\\josh) rhead
(m.h) (5/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* names) c n
(   The name mechanism associates strings with integers,) N
(   using a ternary search tree) N
(   and a stack of string objects) N
(   */) N
() p n
(typedef) K
( ) p
(struct) k
( tst {) p n
(    ) S
(unsigned) k
( val,) p n
(             lo,     ) N
(             eq,) N
(             hi;) N
(} tst;) N
() N
(void) k
( dumpnames\(context *ctx\);) p n
(void) k
( initnames\(context *ctx\);) p n
(object consname\(context *ctx, ) S
(char) k
( *s\);) p n
(object strname\(context *ctx, object n\);) N
() N
() N
(nm.h) (Page 1/1) (Aug 16, 13 0:24) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* objects) c n
(   define the basic 8-byte object structure) N
(   */) N
() p n
(#ifdef) K
( LARGEOBJECT) p n
(typedef) K
( ) p
(unsigned) k
( ) p
(char) k
( byte;) p n
(typedef) K
( uint32_t word;) p n
(typedef) K
( uint64_t dword;) p n
(typedef) K
( uint128_t qword;) p n
(typedef) K
( ) p
(int) k
(64_t integer;) p n
(typedef) K
( ) p
(double) k
( real;) p n
(typedef) K
( dword addr;) p n
(#else) K n
(typedef) S
( ) p
(unsigned) k
( ) p
(char) k
( byte;   ) p
(//assumes ==8bit) c n
(typedef) K
( ) p
(unsigned) k
( ) p
(short) k
( word;  ) p
(//assumes ==16bit) c n
(typedef) K
( ) p
(unsigned) k
( ) p
(long) k
( dword;  ) p
(//assumes >=32bit) c n
(typedef) K
( ) p
(unsigned) k
( ) p
(long) k
( ) p
(long) k
( qword; ) p
(//assumes >=64bit) c n
(typedef) K
( ) p
(int) k
( integer;) p n
(typedef) K
( ) p
(float) k
( real;  ) p
(//assumes 32bit) c n
(typedef) K
( dword addr;  ) p
(//hmm... should probably use this more. :\)) c n
(#endif) K n
() p n
(#define) K
( TYPES\(_\) \\) p n
(    _\(invalid\) \\) N
(    _\(null\)    \\) N
(    _\(mark\)    \\) N
(    _\(integer\) \\) N
(    _\(real\)    \\) N
(    _\(array\)   \\) N
(    _\(dict\)    \\) N
(    _\(file\)    \\) N
(    _\(operator\) \\) N
(    _\(save\)    \\) N
(    _\(name\)    \\) N
(    _\(boolean\) \\) N
(    _\(context\) \\) N
(    _\(extended\) \\) N
(    _\(string\)  \\) N
(/* #def TYPES */) c n
() p n
(#define) K
( AS_TYPE\(_\) \\) p n
(    _ ## type ,) N
(enum) k
( {) p n
(    TYPES\(AS_TYPE\)) N
(    NTYPES) N
(};) N
() N
(#define) K
( AS_STR\(_\) \\) p n
(    #_ ,) N
(#define) K
( AS_TYPE_STR\(_\) \\) p n
(    #_ ") S
(type) str
(" ,) p n
(extern) K n
(char) k
( *types[] ) p
(/*= { TYPES\(AS_TYPE_STR\) "invalid"}*/) c
( ;) p n
() N
(enum) k
( tagdata {) p n
(    TYPEMASK = 0x000F,) N
(    FVALID =   0x0010, ) S
(/* for 'anytype' operator pattern \(7/9/2013: TODO wtf is ) c n
(this??\) */) N
(    FACCESS =  0x0060,) p n
(    FACCESSO = 5,  ) S
(/* bitwise offset of the ACCESS field */) c n
(    FLIT =     0x0080,) p n
(    FBANK =    0x0100, ) S
(/* 0=local, 1=global */) c n
( EXTENDEDINT = 0x0200,) p n
(EXTENDEDREAL = 0x0400,) N
(};) N
() N
(enum) k
( faccess {) p n
(    noaccess    = 0,) N
(    executeonly = 1,) N
(ob.h) (Page 1/3) (Aug 24, 13 14:01) title
border
grestore
(Printed by U-Z1\\josh) rhead
(nm.h, ob.h) (6/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    readonly    = 2,) p n
(    unlimited   = 3,) N
(};) N
() N
(/* To avoid too many structures, many types use .mark_.padw ) c n
(   to hold an unsigned value \(eg. operatortype, nametype, filetype\).) N
(   Of, course if a type needs to use pad0, that's a sign that it needs) N
(   its own struct.) N
(   */) N
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word pad0;) N
(    dword padw;) N
(} mark_;) N
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word pad;) N
(    integer val;) N
(} int_;) N
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word pad;) N
(    real val;) N
(} real_;) N
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word sign_exp;) N
(    dword fraction;) N
(} extended_;) N
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word sz;) N
(    word ent;) N
(    word off;) N
(} comp_;) N
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    word tag;) N
(    word lev;) N
(    dword stk;) N
(} save_;) N
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    dword src;) N
(    dword cpy;) N
(} saverec_; ) S
(/* overlays an object so it can be stacked */) c n
(/* but only on the "save" stack, not user visible. */) N
() p n
(typedef) K
( ) p
(union) K
( {) p n
(    word tag;) N
() N
(    ) S
(//mark_ null_;) c n
(    mark_ mark_;) p n
(    int_ int_;) N
(    real_ real_;) N
(    extended_ extended_;) N
(    comp_ comp_;) N
(    save_ save_;) N
(    saverec_ saverec_;) N
(} object;) N
() N
(int) k
( type\(object o\);) p n
(int) k
( isx\(object o\);) p n
(int) k
( islit\(object o\);) p n
(int) k
( faccess\(object o\);) p n
(ob.h) (Page 2/3) (Aug 24, 13 14:01) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(object setfaccess\(object o, ) p
(int) k
( access\);) p n
(int) k
( isreadable\(object o\);) p n
(int) k
( iswriteable\(object o\);) p n
() N
(#define) K
( DECLARE_SINGLETON\(_\) ) p
(extern) K
( object _;) p n
(#define) K
( DEFINE_SINGLETON\(_\) object _ = { AS_TYPE\(_\) };) p n
(#define) K
( SINGLETONS\(_\) \\) p n
(    _\(invalid\) \\) N
(    _\(null\) \\) N
(    _\(mark\) \\) N
(/* #def SINGLETONS */) c n
() p n
(SINGLETONS\(DECLARE_SINGLETON\)) N
() N
(object consbool\(bool b\);) N
(object consint\(integer i\);) N
(object consreal\(real r\);) N
() N
(object cvx\(object o\);) N
(object cvlit\(object o\);) N
() N
(void) k
( dumpobject\(object o\);) p n
() N
(ob.h) (Page 3/3) (Aug 24, 13 14:01) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ob.h) (7/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* operators) c n
(   This module is the operator interface.) N
(   It defines the operator constructor consoper,) N
(   and the operator handler function opexec.) N
(   initoptab is called to initialize the optab structure itself.) N
(   initop is called to populate the optab structure.) N
() N
(   nb. Since consoper does a linear search through the optab,) N
(   an obvious optimisation would be to factor-out calls to ) N
(   consoper from main-line code. Pre-initialize an object) N
(   somewhere and re-use it where needed. xpost2 did this with) N
(   a global struct of "opcuts" \(operator object shortcuts\),) N
(   but here it would need to be "global", either in global-vm) N
(   or in the context struct.) N
(   One goal of the planned "quick-launch" option is to remove) N
(   these lookups from the initialization, too.) N
() N
(   ----) N
(   An idea to speed-up typechecks, without radical change.) N
(   Add a `int \(*check\)\(\)` function pointer to the signat) N
(   which directly implements the stack-checking performed by) N
(   opexec \(but without the nasty loops\).) N
(   opexec would then call op.sig[i].check\(\) if not null.) N
(   ) N
(   */) N
() p n
(typedef) K
( ) p
(struct) k
( signat {) p n
(    ) S
(void) k
( \(*fp\)\(\);) p n
(    ) S
(int) k
( in;) p n
(    ) S
(unsigned) k
( t;) p n
(    ) S
(int) k
( out;) p n
(} signat;) N
() N
(typedef) K
( ) p
(struct) k
( oper {) p n
(    ) S
(unsigned) k
( name;) p n
(    ) S
(int) k
( n;) p n
(    ) S
(unsigned) k
( sigadr;) p n
(} oper;) N
() N
(enum) k
( typepat { anytype = NTYPES ) p
(/*stringtype + 1*/) c
(,) p n
(    floattype, numbertype, proctype };) N
() N
(#define) K
( MAXOPS 150) p n
(#define) K
( SDSIZE 10) p n
() N
(void) k
( initoptab\(context *ctx\);) p n
(void) k
( dumpoper\(context *ctx, ) p
(int) k
( opcode\);) p n
() N
(object consoper\(context *ctx, ) S
(char) k
( *name, ) p
(/*@null@*/) c
( ) p
(void) k
( \(*fp\)\(\), ) p
(int) k
( out, ) p
(int) k
( ) p n
(in, ...\);) N
() N
(void) k
( opexec\(context *ctx, ) p
(unsigned) k
( opcode\);) p n
() N
(#define) K
( INSTALL \\) p n
(    n.mark_.tag = nametype|FBANK, n.mark_.pad0 = 0, \\) N
(    n.mark_.padw = optab[op.mark_.padw].name, \\) N
(    bdcput\(ctx, sd, n, op\), \\) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\); ) p
(// recalc) c n
() p n
(void) k
( initop\(context *ctx\);) p n
() N
(op.h) (Page 1/1) (Aug 16, 13 14:29) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* array operators */) c n
() p n
(void) k
( arrtomark\(context *ctx\);) p n
(void) k
( initopar\(context *ctx, object sd\);) p n
() N
(opar.h) (Page 1/1) (Jul 22, 13 5:44) title
border
grestore
(Printed by U-Z1\\josh) rhead
(op.h, opar.h) (8/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopb\(context *ctx, object sd\);) p n
() N
(opb.h) (Page 1/1) (Jul 24, 13 0:54) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopc \(context *ctx, object sd\);) p n
() N
(opc.h) (Page 1/1) (Jul 24, 13 0:54) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opb.h, opc.h) (9/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* dictionary operators */) c n
() p n
(extern) K
( ) p
(int) k
( DEBUGLOAD;) p n
() N
(void) k
( Aload\(context *ctx, object K\);) p n
(void) k
( initopdi\(context *ctx, object sd\);) p n
() N
(opdi.h) (Page 1/1) (Jul 24, 13 10:03) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopf \(context *ctx, object sd\);) p n
() N
(opf.h) (Page 1/1) (Jul 24, 13 0:55) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opdi.h, opf.h) (10/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopm \(context *ctx, object sd\);) p n
() N
(opm.h) (Page 1/1) (Jul 24, 13 0:55) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* packedarray operators */) c n
() p n
(void) k
( initoppa\(context *ctx, object sd\);) p n
() N
(oppa.h) (Page 1/1) (Aug 13, 13 14:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opm.h, oppa.h) (11/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* stack operators */) c n
() p n
(void) k
( Apop \(context *ctx, object q\);) p n
(void) k
( AAexch \(context *ctx, object x, object y\);) p n
(void) k
( Adup \(context *ctx, object x\);) p n
(void) k
( IIroll \(context *ctx, object N, object J\);) p n
(void) k
( Zcounttomark \(context *ctx\);) p n
() N
(void) k
( initops\(context *ctx, object sd\);) p n
() N
() N
(ops.h) (Page 1/1) (Jun 09, 13 0:56) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* string operators */) c n
() p n
(void) k
( initopst\(context *ctx, object sd\);) p n
() N
(opst.h) (Page 1/1) (Jun 09, 13 0:57) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ops.h, opst.h) (12/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopt\(context *ctx, object sd\);) p n
() N
(opt.h) (Page 1/1) (Jul 24, 13 0:55) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initoptok\(context *ctx, object sd\);) p n
() N
(optok.h) (Page 1/1) (Aug 04, 13 3:30) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opt.h, optok.h) (13/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopv\(context *ctx, object sd\);) p n
() N
(opv.h) (Page 1/1) (Jul 24, 13 0:56) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( initopx\(context *ctx, object sd\);) p n
() N
(opx.h) (Page 1/1) (Jul 24, 13 0:56) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opv.h, opx.h) (14/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 15
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( echoon \() p
(FILE) k
( *f\);) p n
(void) k
( echooff \() p
(FILE) k
( *f\);) p n
() N
(osunix.h) (Page 1/1) (Jul 15, 13 14:13) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* stacks) c n
(   Stacks consist of a chain of tables, much like mtab chains.) N
(   */) N
() p n
(/* must include ob.h */) c
( ) p n
(/*typedef long long object;*/) c n
() p n
(#define) K
( STACKSEGSZ 20) p n
() N
(typedef) K
( ) p
(struct) k
( {) p n
(    ) S
(unsigned) k
( nextseg;) p n
(    ) S
(unsigned) k
( top;) p n
(    object data[STACKSEGSZ];) N
(} stack;) N
() N
(/* create a stack data structure. returns vm address */) c n
(unsigned) k
( initstack\(mfile *mem\);) p n
() N
(/* dump the contents of a stack to stdout using dumpobject */) c n
(void) k
( dumpstack\(mfile *mem, ) p
(unsigned) k
( stackadr\);) p n
() N
(/* free a stack, and all succeeding segments */) c n
(void) k
( sfree\(mfile *mem, ) p
(unsigned) k
( stackadr\);) p n
() N
(/* count elements on stack */) c n
(unsigned) k
( count\(mfile *mem, ) p
(unsigned) k
( stackadr\);) p n
() N
(/* push an object on top of the stack */) c n
(void) k
( push\(mfile *mem, ) p
(unsigned) k
( stackadr, object o\);) p n
() N
(/* index the stack from the top down, fetching object */) c n
(object top\(mfile *mem, ) p
(unsigned) k
( stackadr, integer i\);) p n
(/* index the stack from the top down, replacing object */) c n
(void) k
( pot\(mfile *mem, ) p
(unsigned) k
( stackadr, integer i, object o\);) p n
() N
(/* index the stack from the bottom up, fetching object */) c n
(object bot\(mfile *mem, ) p
(unsigned) k
( stackadr, integer i\);) p n
(/* index the stack from the bottom up, replacing object */) c n
(void) k
( tob\(mfile *mem, ) p
(unsigned) k
( stacadr, integer i, object o\);) p n
() N
(/* pop the stack. remove and return top object */) c n
(object pop\(mfile *mem, ) p
(unsigned) k
( stackadr\);) p n
(/*int pop\(mfile *mem, unsigned stackadr, object *po\);*/) c
( ) p n
() N
() N
(s.h) (Page 1/1) (Jun 27, 13 5:15) title
border
grestore
(Printed by U-Z1\\josh) rhead
(osunix.h, s.h) (15/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 16
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* strings) c n
(   */) N
() p n
(object consstr\(mfile *mem, ) S
(unsigned) k
( sz, ) p
(/*@NULL@*/) c
( ) p
(char) k
( *ini\);) p n
(object consbst\(context *ctx, ) S
(unsigned) k
( sz, ) p
(/*@NULL@*/) c
( ) p
(char) k
( *ini\);) p n
(/*@dependent@*/) c n
(char) k
( *charstr\(context *ctx, object S\);) p n
(void) k
( strput\(mfile *mem, object s, integer i, integer c\);) p n
(void) k
( bstput\(context *ctx, object s, integer i, integer c\);) p n
(integer strget\(mfile *mem, object s, integer i\);) N
(integer bstget\(context *ctx, object s, integer i\);) N
() N
() N
(st.h) (Page 1/1) (Jun 09, 13 1:04) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* save/restore) c n
(   Each mfile has a special entity \(VS\) which holds the address) N
(   of the "save stack". This stack holds save objects.) N
() N
(   The save object contains an address of a\(nother\) stack,) N
(   this one containing saverec_ structures.) N
(   A saverec_ object contains 2 entity numbers, one the source,) N
(   the other the copy, of the "saved" array or dictionary.) N
() N
(   stashed and stash are the interfaces used by composite objects) N
(   to check-if-copying-is-necessary) N
(   and copy-the-value-and-add-saverec-to-current-savelevel-stack) N
() N
(   mem[mtab[VS].adr] = Master Save stack) N
(   -- save object = { lev=0, stk=... }) N
(   -- save object = { lev=1, stk=... }) N
(      -- saverec) N
(      -- saverec) N
(   -- save object = { lev=2, stk=... }  <-- top of VS, current savelevel stack) N
(      mem[save.save_.stk] = Save Object's stack) N
(      -- saverec) N
(      -- saverec) N
(      -- saverec = { src=foo_ent, cpy=bar_ent }) N
() N
(   */) N
() p n
(void) k
( initsave\(mfile *mem\);) p n
(object save\(mfile *mem\);) N
(unsigned) k
( stashed\(mfile *mem, ) p
(unsigned) k
( ent\);) p n
(unsigned) k
( copy\(mfile *mem, ) p
(unsigned) k
( ent\);) p n
(void) k
( stash\(mfile *mem, ) p
(unsigned) k
( ent\);) p n
(void) k
( restore\(mfile *mem\);) p n
() N
() N
(v.h) (Page 1/1) (Jul 30, 13 15:01) title
border
grestore
(Printed by U-Z1\\josh) rhead
(st.h, v.h) (16/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 17
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
() N
(/* Allocate an entity with gballoc,) c n
(   find the appropriate mtab,) N
(   set the current save level in the "mark" field,) N
(   wrap it up in an object. */) N
(object consarr\(mfile *mem, ) p
(unsigned) k
( sz\) {) p n
(    ) S
(unsigned) k
( ent;) p n
(    ) S
(unsigned) k
( rent;) p n
(    ) S
(unsigned) k
( cnt;) p n
(    mtab *tab;) N
(    object o;) N
(    ) S
(unsigned) k
( i;) p n
(    assert\(mem->base\);) N
() N
(    ) S
(//unsigned ent = mtalloc\(mem, 0, sz * sizeof\(object\)\);) c n
(    ent = gballoc\(mem, \() p
(unsigned) k
(\)\(sz * ) p
(sizeof) K
(\(object\)\)\);) p n
(    tab = \() S
(void) k
( *\)\(mem->base\);) p n
(    rent = ent;) N
(    findtabent\(mem, &tab, &rent\);) N
(    cnt = count\(mem, adrent\(mem, VS\)\);) N
(    tab->tab[rent].mark = \( \(0 << MARKO\) | \(0 << RFCTO\) |) N
(            \(cnt << LLEVO\) | \(cnt << TLEVO\) \);) N
() N
(    ) S
(for) K
( \(i = 0; i < sz; i++\)) p n
(        put\(mem, ent, i, \() S
(unsigned) k
(\)) p
(sizeof) K
(\(object\), &null\);) p n
() N
(    ) S
(//return \(object\){ .comp_.tag = arraytype, .comp_.sz = sz, .comp_.ent = ent,) c n
( .comp_.off = 0};) N
(    o.tag = arraytype | \(unlimited << FACCESSO\);) p n
(    o.comp_.sz = \(word\)sz;) N
(    o.comp_.ent = \(word\)ent;) N
(    o.comp_.off = 0;) N
(    ) S
(return) K
( o;) p n
(} ) N
() N
(/* Select a memory file according to vmmode,) c n
(   call consarr,) N
(   set BANK flag. */) N
(object consbar\(context *ctx, ) p
(unsigned) k
( sz\) {) p n
(    object a = consarr\(ctx->vmmode==GLOBAL?) N
(            ctx->gl: ctx->lo, sz\);) N
(    ) S
(if) K
( \(ctx->vmmode==GLOBAL\)) p n
(        a.tag |= FBANK;) N
(    ) S
(return) K
( a;) p n
(}) N
() N
(/* Copy if necessary,) c n
(   call put. */) N
(void) k
( arrput\(mfile *mem, object a, integer i, object o\) {) p n
(    ) S
(if) K
( \(!stashed\(mem, a.comp_.ent\)\) stash\(mem, a.comp_.ent\);) p n
(    ) S
(if) K
( \(i > a.comp_.sz\)) p n
(        error\(rangecheck, ") S
(arrput) str
("\);) p n
(    put\(mem, a.comp_.ent, \() S
(unsigned) k
(\)\(a.comp_.off + i\), \() p
(unsigned) k
(\)) p
(sizeof) K
(\(object\),) p n
( &o\);) N
(}) N
() N
(/* Select mfile according to BANK flag,) c n
(ar.c) (Page 1/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   call arrput. */) c n
(void) k
( barput\(context *ctx, object a, integer i, object o\) {) p n
(    arrput\() S
(/*bank\(ctx, a\)*/) c
( a.tag&FBANK? ctx->gl: ctx->lo, a, i, o\);) p n
(}) N
() N
(/* call get. */) c n
(object arrget\(mfile *mem, object a, integer i\) {) p n
(    object o;) N
(    get\(mem, a.comp_.ent, \() S
(unsigned) k
(\)\(a.comp_.off +i\), \() p
(unsigned) k
(\)\() p
(sizeof) K
(\(object\)\)) p n
(, &o\);) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(/* Select mfile according to BANK flag,) c n
(   call arrget. */) N
(object barget\(context *ctx, object a, integer i\) {) p n
(    ) S
(return) K
( arrget\(bank\(ctx, a\) ) p
(/*a.tag&FBANK? ctx->gl: ctx->lo*/) c
(, a, i\);) p n
(}) N
() N
(/* adjust the offset and size fields in the object. */) c n
(object arrgetinterval\(object a, integer off, integer sz\) {) p n
(    ) S
(if) K
( \(sz - off > a.comp_.sz\) error\(rangecheck, ") p
(getinterval can only shrink!) str
("\);) p n
(    a.comp_.off += off;) N
(    a.comp_.sz = sz;) N
(    ) S
(return) K
( a;) p n
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <string.h>) p n
() N
(context *ctx;) N
(mfile *mem;) N
() N
(int) k
( main\() p
(void) k
(\) {) p n
(    itpdata = malloc\() S
(sizeof) K
(*itpdata\);) p n
(    memset\(itpdata, 0, ) S
(sizeof) K
(*itpdata\);) p n
(    inititp\(itpdata\);) N
(    ctx = &itpdata->ctab[0];) N
(    mem = ctx->lo;) N
(    ) S
(//initmem\(&mem, "x.mem"\);) c n
(    ) p
(//\(void\)initmtab\(&mem\);) c n
(    ) p
(//initfree\(&mem\);) c n
(    ) p
(//initsave\(&mem\);) c n
() p n
(    ) S
(enum) k
( { SIZE = 10 };) p n
(    printf\(") S
(\\n^test ar.c\\n) str
("\);) p n
(    printf\(") S
(allocating array occupying %zu bytes\\n) str
(", SIZE*) p
(sizeof) K
(\(object\)\);) p n
(    object a = consarr\(mem, SIZE\);) N
() N
(    ) S
(//printf\("the memory table:\\n"\); dumpmtab\(mem, 0\);) c n
() p n
(    printf\(") S
(test array by filling\\n) str
("\);) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i=0; i < SIZE; i++\) {) p n
(        printf\(") S
(%d ) str
(", i+1\);) p n
(        arrput\(mem, a, i, consint\( i+1 \)\);) N
(    }) N
(    puts\(""\);) N
() N
(    printf\(") S
(and accessing.\\n) str
("\);) p n
(    ) S
(for) K
( \(i=0; i < SIZE; i++\) {) p n
(        object t;) N
(        t = arrget\(mem, a, i\);) N
(        printf\(") S
(%d: %d\\n) str
(", i, t.int_.val\);) p n
(    }) N
() N
(    printf\(") S
(the memory table:\\n) str
("\);) p n
(ar.c) (Page 2/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ar.c) (17/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3,1) 18
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    dumpmtab\(mem, 0\);) p n
() N
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
() p n
(ar.c) (Page 3/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <math.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdlib.h> ) p
(/* malloc */) c n
(#include) K
( <stdio.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
() N
(/*) c n
(typedef struct {) N
(    word tag;) N
(    word sz;) N
(    word nused;) N
(    word pad;) N
(} dichead;) N
(*/) N
() p n
(/* Compare two objects for "equality". ) c n
(   return 0 if "equal") N
(          +value if L > R) N
(          -value if L < R) N
( */) N
(int) k
( objcmp\(context *ctx, object L, object R\) {) p n
(    ) S
(if) K
( \(type\(L\) != type\(R\)\) {) p n
(        ) S
(if) K
( \(type\(L\) == integertype && type\(R\) == realtype\) {) p n
(            L = consreal\(L.int_.val\);) N
(            ) S
(goto) K
( cont;) p n
(        }) N
(        ) S
(if) K
( \(type\(R\) == integertype && type\(L\) == realtype\) {) p n
(            R = consreal\(R.int_.val\);) N
(            ) S
(goto) K
( cont;) p n
(        }) N
(        ) S
(if) K
( \(type\(L\) == nametype && type\(R\) == stringtype\) {) p n
(            L = strname\(ctx, L\);) N
(            ) S
(goto) K
( cont;) p n
(        }) N
(        ) S
(if) K
( \(type\(R\) == nametype && type\(L\) == stringtype\) {) p n
(            R = strname\(ctx, R\);) N
(            ) S
(goto) K
( cont;) p n
(        }) N
(        ) S
(return) K
( type\(L\) - type\(R\);) p n
(    }) N
() N
(cont:) N
(    ) S
(switch) K
( \(type\(L\)\) {) p n
(        ) S
(default) K
(:) p n
(            fprintf\(stderr, ") S
(unhandled type \(%s\) in objcmp) str
(", types[type\(L\)]\);) p n
(            error\(unregistered, ""\);) N
(            ) S
(return) K
( -1;) p n
() N
(        ) S
(case) K
( marktype: ) p
(return) K
( 0;) p n
(        ) S
(case) K
( nulltype: ) p
(return) K
( 0;) p n
(        ) S
(case) K
( invalidtype: ) p
(return) K
( 0;) p n
() N
(        ) S
(case) K
( booleantype: ) p
(/*@fallthrough@*/) c n
(        ) p
(case) K
( integertype: ) p
(return) K
( L.int_.val - R.int_.val;) p n
() N
(        ) S
(case) K
( realtype: ) p
(return) K
( \(fabs\(L.real_.val - R.real_.val\) < 0.0001\)?) p n
(di.c) (Page 1/7) (Aug 25, 13 9:51) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ar.c, di.c) (18/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 19
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                                0:) p n
(                                L.real_.val - R.real_.val > 0? 1: -1;) N
(        ) S
(case) K
( extendedtype: {) p n
(                               ) S
(double) k
( l,r;) p n
(                               l = doubleextended\(L\);) N
(                               r = doubleextended\(R\);) N
(                               ) S
(return) K
( \(fabs\(l - r\) < 0.0001\)?) p n
(                                   0:) N
(                                   l - r > 0? 1: -1;) N
(                           }) N
() N
(        ) S
(case) K
( operatortype:  ) p
(return) K
( L.mark_.padw - R.mark_.padw;) p n
() N
(        ) S
(case) K
( nametype: ) p
(return) K
( \(L.tag&FBANK\)==\(R.tag&FBANK\)?) p n
(                                \() S
(signed) k
(\)\(L.mark_.padw - R.mark_.padw\):) p n
(                                    \() S
(signed) k
(\)\(\(L.tag&FBANK\) - \(R.tag&FBANK\)\);) p n
() N
(        ) S
(case) K
( dicttype: ) p
(/*@fallthrough@*/) c
( ) p
(//return !\( L.comp_.ent == R.comp_.ent ) c n
(\);) N
(        ) p
(case) K
( arraytype: ) p
(return) K
( !\( L.comp_.sz == R.comp_.sz) p n
(                                && \(L.tag&FBANK\) == \(R.tag&FBANK\)) N
(                                && L.comp_.ent == R.comp_.ent) N
(                                && L.comp_.off == R.comp_.off \); ) S
(// 0 if all eq) c n
() p n
(        ) S
(case) K
( stringtype: ) p
(return) K
( L.comp_.sz == R.comp_.sz ?) p n
(                                memcmp\(charstr\(ctx, L\), charstr\(ctx, R\), L.comp_) N
(.sz\) :) N
(                                L.comp_.sz - R.comp_.sz;) N
(    }) N
(}) N
() N
(/* more like scrambled eggs */) c n
(unsigned) k
( hash\(object k\) {) p n
(    ) S
(unsigned) k
( h;) p n
(    h = \(type\(k\) << 1\) ) S
(/* ignore flags */) c n
(        + \(k.comp_.sz << 3\)) p n
(        + \(k.comp_.ent << 7\)) N
(        + \(k.comp_.off << 5\);) N
(#ifdef) K
( DEBUGDIC) p n
(    printf\(") S
(\\nhash\() str
("\);) p n
(    dumpobject\(k\);) N
(    printf\(") S
(\)=%d) str
(", h\);) p n
(#endif) K n
(    ) p
(return) K
( h;) p n
(}) N
() N
(/* allocate an entity with gballoc,) c n
(   set the save level in the mark,) N
(   extract the "pointer" from the entity,) N
(   Initialize a dichead in memory,) N
(   just after the head, clear a table of pairs. */) N
(object consdic\(mfile *mem, ) p
(unsigned) k
( sz\) {) p n
(    mtab *tab;) N
(    object d;) N
(    ) S
(unsigned) k
( rent;) p n
(    ) S
(unsigned) k
( cnt;) p n
(    ) S
(unsigned) k
( ad;) p n
(    dichead *dp;) N
(    object *tp;) N
(    ) S
(unsigned) k
( i;) p n
() N
(    assert\(mem->base\);) N
(    d.tag = dicttype | \(unlimited << FACCESSO\);) N
(    d.comp_.sz = sz;) N
(    d.comp_.off = 0;) N
(    ) S
(//d.comp_.ent = mtalloc\(mem, 0, sizeof\(dichead\) + DICTABSZ\(sz\) \);) c n
(    d.comp_.ent = gballoc\(mem, ) p
(sizeof) K
(\(dichead\) + DICTABSZ\(sz\) \);) p n
() N
(    tab = \() S
(void) k
( *\)\(mem->base\);) p n
(di.c) (Page 2/7) (Aug 25, 13 9:51) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    rent = d.comp_.ent;) p n
(    findtabent\(mem, &tab, &rent\);) N
(    cnt = count\(mem, adrent\(mem, VS\)\);) N
(    tab->tab[rent].mark = \( \(0 << MARKO\) | \(0 << RFCTO\) |) N
(            \(cnt << LLEVO\) | \(cnt << TLEVO\) \);) N
() N
(    ad = adrent\(mem, d.comp_.ent\);) N
(    dp = \() S
(void) k
( *\)\(mem->base + ad\); ) p
(/* clear header */) c n
(    dp->tag = dicttype;) p n
(    dp->sz = sz;) N
(    dp->nused = 0;) N
(    dp->pad = 0;) N
() N
(    tp = \() S
(void) k
( *\)\(mem->base + ad + ) p
(sizeof) K
(\(dichead\)\); ) p
(/* clear table */) c n
(    ) p
(for) K
( \(i=0; i < DICTABN\(sz\); i++\)) p n
(        tp[i] = null; ) S
(/* remember our null object is not all-zero! */) c n
(#ifdef) K
( DEBUGDIC) p n
(    printf\(") S
(consdic: ) str
("\); dumpdic\(mem, d\);) p n
(#endif) K n
(    ) p
(return) K
( d;) p n
(}) N
() N
(/* select mfile according to vmmode,) c n
(   call consdic,) N
(   set the BANK flag. */) N
(object consbdc\(context *ctx, ) p
(unsigned) k
( sz\) {) p n
(    object d = consdic\(ctx->vmmode==GLOBAL? ctx->gl: ctx->lo, sz\);) N
(    ) S
(if) K
( \(ctx->vmmode == GLOBAL\)) p n
(        d.tag |= FBANK;) N
(    ) S
(return) K
( d;) p n
(}) N
() N
(/* get the nused field from the dichead */) c n
(unsigned) k
( diclength\(mfile *mem, object d\) {) p n
(    dichead *dp = \() S
(void) k
( *\)\(mem->base + adrent\(mem, d.comp_.ent\)\);) p n
(    ) S
(return) K
( dp->nused;) p n
(}) N
() N
(/* get the sz field from the dichead */) c n
(unsigned) k
( dicmaxlength\(mfile *mem, object d\) {) p n
(    dichead *dp = \() S
(void) k
( *\)\(mem->base + adrent\(mem, d.comp_.ent\)\);) p n
(    ) S
(return) K
( dp->sz;) p n
(}) N
() N
(void) k
( dicgrow\(context *ctx, object d\) {) p n
(    mfile *mem;) N
(    ) S
(unsigned) k
( sz;) p n
(    ) S
(unsigned) k
( newsz;) p n
(    ) S
(unsigned) k
( ad;) p n
(    dichead *dp;) N
(    object *tp;) N
(    object n;) N
(    ) S
(unsigned) k
( i;) p n
(    mem = bank\(ctx, d\);) N
(#ifdef) K
( DEBUGDIC) p n
(    printf\(") S
(DI growing dict\\n) str
("\);) p n
(    dumpdic\(mem, d\);) N
(#endif) K n
(    n = consdic\(mem, newsz = 2 * dicmaxlength\(mem, d\)\);) p n
() N
(    ad = adrent\(mem, d.comp_.ent\);) N
(    dp = \() S
(void) k
( *\)\(mem->base + ad\);) p n
(    sz = \(dp->sz + 1\);) N
(    tp = \() S
(void) k
( *\)\(mem->base + ad + ) p
(sizeof) K
(\(dichead\)\); ) p
(/* copy data */) c n
(    ) p
(for) K
( \( i=0; i < sz; i++\)) p n
(        ) S
(//if \(objcmp\(ctx, tp[2*i], null\) != 0\) {) c n
(        ) p
(if) K
( \(type\(tp[2*i]\) != nulltype\) {) p n
(            dicput\(ctx, mem, n, tp[2*i], tp[2*i+1]\);) N
(        }) N
(di.c) (Page 3/7) (Aug 25, 13 9:51) title
border
grestore
(Printed by U-Z1\\josh) rhead
(di.c) (19/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4-5) 20
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifdef) K
( DEBUGDIC) p n
(    printf\(") S
(n: ) str
("\);) p n
(    dumpdic\(mem, n\);) N
(#endif) K n
() p n
(    {   ) S
(// exchange entities) c n
(        mtab *dtab, *ntab;) p n
(        ) S
(unsigned) k
( dent, nent;) p n
(        ) S
(unsigned) k
( hold;) p n
() N
(        dent = d.comp_.ent;) N
(        nent = n.comp_.ent;) N
(        findtabent\(mem, &dtab, &dent\);) N
(        findtabent\(mem, &ntab, &nent\);) N
() N
(        ) S
(// exchange adrs) c n
(        hold = dtab->tab[dent].adr;) p n
(        dtab->tab[dent].adr = ntab->tab[nent].adr;) N
(        ntab->tab[nent].adr = hold;) N
() N
(        ) S
(// exchange sizes) c n
(        hold = dtab->tab[dent].sz;) p n
(        dtab->tab[dent].sz = ntab->tab[nent].sz;) N
(        ntab->tab[nent].sz = hold;) N
() N
(        mfree\(mem, n.comp_.ent\);) N
(    }) N
(}) N
() N
(/* is it full? \(y/n\) */) c n
(bool dicfull\(mfile *mem, object d\) {) p n
(    ) S
(return) K
( diclength\(mem, d\) == dicmaxlength\(mem, d\);) p n
(}) N
() N
(void) k
( dumpdic\(mfile *mem, object d\) {) p n
(    ) S
(unsigned) k
( ad = adrent\(mem, d.comp_.ent\);) p n
(    dichead *dp = \() S
(void) k
( *\)\(mem->base + ad\);) p n
(    object *tp = \() S
(void) k
( *\)\(mem->base + ad + ) p
(sizeof) K
(\(dichead\)\);) p n
(    ) S
(unsigned) k
( sz = \(dp->sz + 1\);) p n
(    ) S
(unsigned) k
( i;) p n
(    printf\(") S
(\\n) str
("\);) p n
(    ) S
(for) K
( \(i=0; i < sz; i++\) {) p n
(        printf\(") S
(%d:) str
(", i\);) p n
(        ) S
(if) K
( \(type\(tp[2*i]\) != nulltype\) {) p n
(            dumpobject\(tp[2*i]\);) N
(        }) N
(    }) N
(}) N
() N
(//n.b. Caller Must set EXTENDEDINT or EXTENDEDREAL flag) c n
(object consextended \() p
(double) k
( d\) {) p n
(    ) S
(unsigned) k
( ) p
(long) k
( ) p
(long) k
( r = *\() p
(unsigned) k
( ) p
(long) k
( ) p
(long) k
( *\)&d;) p n
(    extended_ e;) N
(    e.tag = extendedtype;) N
(    e.sign_exp = \(r>>52\) & 0x7FF;) N
(    e.fraction = \(r>>20\) & 0xFFFFFFFF;) N
(    ) S
(return) K
( \(object\) e;) p n
(}) N
() N
(double) k
( doubleextended \(object e\) {) p n
(    ) S
(unsigned) k
( ) p
(long) k
( ) p
(long) k
( r;) p n
(    ) S
(double) k
( d;) p n
(    r = \(\() S
(unsigned) k
( ) p
(long) k
( ) p
(long) k
(\)e.extended_.sign_exp << 52\)) p n
(        | \(\() S
(unsigned) k
( ) p
(long) k
( ) p
(long) k
(\)e.extended_.fraction << 20\);) p n
(    d = *\() S
(double) k
( *\)&r;) p n
(    ) S
(return) K
( d;) p n
(}) N
() N
(object unextend \(object e\) {) N
(di.c) (Page 4/7) (Aug 25, 13 9:51) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    object o;) p n
(    ) S
(double) k
( d = doubleextended\(e\);) p n
(    ) S
(if) K
( \(e.tag & EXTENDEDINT\) {) p n
(        o = consint\(d\);) N
(    } ) S
(else) K
( ) p
(if) K
( \(e.tag & EXTENDEDREAL\) {) p n
(        o = consreal\(d\);) N
(    } ) S
(else) K
( {) p n
(        error\(unregistered, ") S
(unextend: invalid extended number object) str
("\);) p n
(    }) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(object clean_key \(context *ctx, object k\) {) N
(    ) S
(switch) K
(\(type\(k\)\) {) p n
(    ) S
(case) K
( stringtype: {) p n
(        ) S
(char) k
( *s = alloca\(k.comp_.sz+1\);) p n
(        memcpy\(s, charstr\(ctx, k\), k.comp_.sz\);) N
(        s[k.comp_.sz] = ') S
(\\0) str
(';) p n
(        k = consname\(ctx, s\);) N
(    }) N
(    ) S
(break) K
(;) p n
(    ) S
(case) K
( integertype:) p n
(        k = consextended\(k.int_.val\);) N
(        k.tag |= EXTENDEDINT;) N
(    ) S
(break) K
(;) p n
(    ) S
(case) K
( realtype:) p n
(        k = consextended\(k.real_.val\);) N
(        k.tag |= EXTENDEDREAL;) N
(    ) S
(break) K
(;) p n
(    }) N
(    ) S
(return) K
( k;) p n
(}) N
() N
(#define) K
( RETURN_TAB_I_IF_EQ_K_OR_NULL    \\) p n
(    ) S
(if) K
( \(objcmp\(ctx, tp[2*i], k\) == 0    \\) p n
(    || objcmp\(ctx, tp[2*i], null\) == 0\) \\) N
(            ) S
(return) K
( tp + \(2*i\);) p n
() N
(/* perform a hash-assisted lookup.) c n
(   returns a pointer to the desired pair \(if found\)\), or a null-pair. */) N
(/*@dependent@*/) S
( ) p
(/*@null@*/) c n
(object *diclookup\(context *ctx, ) p
(/*@dependent@*/) c
( mfile *mem, object d, object k\) ) p n
({) N
(    ) S
(unsigned) k
( ad;) p n
(    dichead *dp;) N
(    object *tp;) N
(    ) S
(unsigned) k
( sz;) p n
(    ) S
(unsigned) k
( h;) p n
(    ) S
(unsigned) k
( i;) p n
() N
(    k = clean_key\(ctx, k\);) N
() N
(    ad = adrent\(mem, d.comp_.ent\);) N
(    dp = \() S
(void) k
( *\)\(mem->base + ad\);) p n
(    tp = \() S
(void) k
( *\)\(mem->base + ad + ) p
(sizeof) K
(\(dichead\)\);) p n
(    sz = \(dp->sz + 1\);) N
() N
(    h = hash\(k\) % sz;) N
(    i = h;) N
(#ifdef) K
( DEBUGDIC) p n
(    printf\(") S
(diclookup\() str
("\);) p n
(    dumpobject\(k\);) N
(    printf\(") S
(\);) str
("\);) p n
(    printf\(") S
(%%%d=%d) str
(",sz, h\);) p n
(#endif) K n
() p n
(    RETURN_TAB_I_IF_EQ_K_OR_NULL) N
(    ) S
(for) K
( \(++i; i < sz; i++\) {) p n
(        RETURN_TAB_I_IF_EQ_K_OR_NULL) N
(di.c) (Page 5/7) (Aug 25, 13 9:51) title
border
grestore
(Printed by U-Z1\\josh) rhead
(di.c) (20/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (6-7) 21
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    }) p n
(    ) S
(for) K
( \(i=0; i < h; i++\) {) p n
(        RETURN_TAB_I_IF_EQ_K_OR_NULL) N
(    }) N
(    ) S
(return) K
( ) p
(NULL) K
(; ) p
(/* i == h : dict is overfull: no null entry */) c n
(}) p n
() N
(/* see if lookup returns a non-null pair. */) c n
(bool dicknown\(context *ctx, ) p
(/*@dependent@*/) c
( mfile *mem, object d, object k\) {) p n
(    object *r;) N
(    r = diclookup\(ctx, mem, d, k\);) N
(    ) S
(if) K
( \(r == ) p
(NULL) K
(\) ) p
(return) K
( false;) p n
(    ) S
(return) K
( type\(*r\) != nulltype;) p n
(}) N
() N
(/* call diclookup,) c n
(   return the value if the key is non-null. */) N
(object dicget\(context *ctx, ) p
(/*@dependent@*/) c
( mfile *mem, object d, object k\) {) p n
(    object *e;) N
(    e = diclookup\(ctx, mem, d, k\);) N
(    ) S
(if) K
( \(e == ) p
(NULL) K
( || type\(e[0]\) == nulltype\) {) p n
(        error\(undefined, ") S
(dicget) str
("\);) p n
(        ) S
(return) K
( null;) p n
(    }) N
(    ) S
(return) K
( e[1];) p n
(}) N
() N
(/* select mfile according to BANK field,) c n
(   call dicget. */) N
(object bdcget\(context *ctx, object d, object k\) {) p n
(    ) S
(return) K
( dicget\(ctx, bank\(ctx, d\) ) p
(/*d.tag&FBANK?ctx->gl:ctx->lo*/) c
(, d, k\);) p n
(}) N
() N
(/* save data if not save at this level,) c n
(   lookup the key,) N
(   if key is null, check if the dict is full,) N
(       increase nused,) N
(       set key,) N
(       update value. */) N
(void) k
( dicput\(context *ctx, mfile *mem, object d, object k, object v\) {) p n
(    object *e;) N
(    dichead *dp;) N
(retry:) N
(    ) S
(if) K
( \(!stashed\(mem, d.comp_.ent\)\) stash\(mem, d.comp_.ent\);) p n
(    e = diclookup\(ctx, mem, d, k\);) N
(    ) S
(if) K
( \(e == ) p
(NULL) K
(\) {) p n
(        ) S
(//error\("dict overfull"\);) c n
(        ) p
(//grow dict!) c n
(        dicgrow\(ctx, d\);) p n
(        ) S
(goto) K
( retry;) p n
(    }) N
(    ) S
(if) K
( \(type\(e[0]\) == invalidtype\) {) p n
(        fprintf\(stderr, ") S
(warning: invalidtype key in dict\\n) str
("\);) p n
(        e[0] = null;) N
(    }) N
(    ) S
(if) K
( \(type\(e[0]\) == nulltype\) {) p n
(        ) S
(if) K
( \(dicfull\(mem, d\)\) {) p n
(            ) S
(//error\("dict full"\);) c n
(            ) p
(//grow dict!) c n
(            dicgrow\(ctx, d\);) p n
(            ) S
(goto) K
( retry;) p n
(        }) N
(        dp = \() S
(void) k
( *\)\(mem->base + adrent\(mem, d.comp_.ent\)\);) p n
(        ++ dp->nused;) N
(        e[0] = clean_key\(ctx, k\);) N
(    }) N
(    e[1] = v;) N
(}) N
() N
(di.c) (Page 6/7) (Aug 25, 13 9:51) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* select mfile according to BANK field,) c n
(   call dicput. */) N
(void) k
( bdcput\(context *ctx, object d, object k, object v\) {) p n
(    dicput\(ctx, bank\(ctx, d\) ) S
(/*d.tag&FBANK?ctx->gl:ctx->lo*/) c
(, d, k, v\);) p n
(}) N
() N
(void) k
( dicundef\(context *ctx, mfile *mem, object d, object k\) {) p n
(    ) S
(if) K
( \(!stashed\(mem, d.comp_.ent\)\) stash\(mem, d.comp_.ent\);) p n
(    ) S
(//find slot for key) c n
(    ) p
(//find last chained key and value with same hash) c n
(        ) p
(//if found: move last key and value to slot) c n
(        ) p
(//not found: write null over key and value) c n
(}) p n
() N
(void) k
( bdcundef\(context *ctx, object d, object k\) {) p n
(    dicundef\(ctx, bank\(ctx, d\), d, k\);) N
(}) N
() N
() N
(#ifdef) K
( TESTMODULE) p n
(#include) K
( <stdio.h>) p n
() N
(//context ctx;) c n
(context *ctx;) p n
() N
(void) k
( init\(\) {) p n
(    ) S
(//initcontext\(&ctx\);) c n
(    itpdata=malloc\() p
(sizeof) K
(*itpdata\);) p n
(    inititp\(itpdata\);) N
(    ctx = &itpdata->ctab[0];) N
(}) N
() N
(int) k
( main\() p
(void) k
(\) {) p n
(    printf\(") S
(\\n^test di.c\\n) str
("\);) p n
(    init\(\);) N
() N
(    object d;) N
(    d = consbdc\(ctx, 12\);) N
(    printf\(") S
(1 2 def\\n) str
("\);) p n
(    bdcput\(ctx, d, consint\(1\), consint\(2\)\);) N
(    printf\(") S
(3 4 def\\n) str
("\);) p n
(    bdcput\(ctx, d, consint\(3\), consint\(4\)\);) N
() N
(    printf\(") S
(1 load =\\n) str
("\);) p n
(    dumpobject\(bdcget\(ctx, d, consint\(1\)\)\);) N
(    ) S
(//dumpobject\(bdcget\(ctx, d, consint\(2\)\)\); // error\("undefined"\);) c n
(    printf\(") p
(\\n3 load =\\n) str
("\);) p n
(    dumpobject\(bdcget\(ctx, d, consint\(3\)\)\);) N
() N
() N
(    ) S
(//dumpmfile\(ctx->gl\);) c n
(    ) p
(//dumpmtab\(ctx->gl, 0\);) c n
(    puts\(""\);) p n
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
(di.c) (Page 7/7) (Aug 25, 13 9:51) title
border
grestore
(Printed by U-Z1\\josh) rhead
(di.c) (21/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 22
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <setjmp.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
() N
(//#define EMITONERROR) c n
() p n
(char) k
( *errorname[] = { ERRORS\(AS_STR\) };) p n
() N
(volatile) K
( ) p
(char) k
( *errormsg = "";) p n
() N
(static) K
( ) p
(int) k
( in_onerror;) p n
() N
(/* placeholder error function */) c n
(/* ultimately, this will do a longjmp back) N
(   to the central loop */) N
(void) k
( error\() p
(unsigned) k
( err, ) p
(char) k
( *msg\) {) p n
(    context *ctx;) N
(    errormsg = msg;) N
(    ) S
(if) K
( \(!initializing && jbmainloopset && !in_onerror\) {) p n
(        longjmp\(jbmainloop, err\);) N
(    }) N
() N
(    ) S
(/* following will become "fallback" code) c n
(       if jmpbuf is not set */) N
(    fprintf\(stderr, ") p
(\\nError: %s) str
(", errorname[err]\);) p n
(    fprintf\(stderr, ") S
(\\nObject: ) str
("\);) p n
(    dumpobject\(itpdata->ctab[0].currentobject\);) N
(    fprintf\(stderr, ") S
(\\nExtra: %s) str
(", msg\);) p n
(    perror\(") S
(\\nlast system error:) str
("\);) p n
() N
(    printf\(") S
(\\nError: %s) str
(", errorname[err]\);) p n
(    printf\(") S
(\\nExtra: %s) str
(", msg\);) p n
() N
(    ctx = &itpdata->ctab[0];) N
(    printf\(") S
(\\nopstack: ) str
("\);) p n
(    dumpstack\(ctx->lo, ctx->os\);) N
(    printf\(") S
(\\nexecstack: ) str
("\);) p n
(    dumpstack\(ctx->lo, ctx->es\);) N
(    printf\(") S
(\\ndictstack: ) str
("\);) p n
(    dumpstack\(ctx->lo, ctx->ds\);) N
() N
(    printf\(") S
(\\nLocal VM: ) str
("\);) p n
(    dumpmfile\(ctx->lo\);) N
(    dumpmtab\(ctx->lo, 0\);) N
(    printf\(") S
(\\nGlobal VM: ) str
("\);) p n
(    dumpmfile\(ctx->gl\);) N
(    dumpmtab\(ctx->gl, 0\);) N
() N
(    printf\(") S
(\\nGlobal Name Stack: ) str
("\);) p n
(    dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\);) N
(    printf\(") S
(\\nLocal Name Stack: ) str
("\);) p n
(    dumpstack\(ctx->lo, adrent\(ctx->lo, NAMES\)\);) N
() N
(    exit\(EXIT_FAILURE\);) N
(}) N
() N
() N
(err.c) (Page 1/2) (Aug 22, 13 23:02) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* called by itp:loop\(\) after longjmp from error\(\) */) c n
(void) k
( onerror\(context *ctx, ) p
(unsigned) k
( err\) {) p n
(    object sd;) N
(    object dollarerror;) N
(    ) S
(char) k
( *errmsg; ) p n
(    assert\(ctx\);) N
(    assert\(ctx->gl\);) N
(    assert\(ctx->gl->base\);) N
(    assert\(ctx->lo\);) N
(    assert\(ctx->lo->base\);) N
() N
(    in_onerror = true;) N
() N
(#ifdef) K
( EMITONERROR) p n
(    fprintf\(stderr, ") S
(err: %s\\n) str
(", errorname[err]\);) p n
(#endif) K n
() p n
(    ) S
(//printf\("1\\n"\);) c n
(    sd = bot\(ctx->lo, ctx->ds, 0\);) p n
(    ) S
(//printf\("2\\n"\);) c n
() p n
(    dollarerror = bdcget\(ctx, sd, consname\(ctx, ") S
($error) str
("\)\);) p n
(    ) S
(//printf\("3\\n"\);) c n
(    errmsg = errormsg;) p n
(    ) S
(//printf\("4\\n"\);) c n
(    bdcput\(ctx, dollarerror,) p n
(            consname\(ctx, ") S
(Extra) str
("\),) p n
(            consbst\(ctx, strlen\(errmsg\), errmsg\)\);) N
(    ) S
(//printf\("5\\n"\);) c n
() p n
(    push\(ctx->lo, ctx->os, ctx->currentobject\);) N
(    ) S
(//printf\("6\\n"\);) c n
(    push\(ctx->lo, ctx->os, cvlit\(consname\(ctx, errorname[err]\)\)\);) p n
(    ) S
(//printf\("7\\n"\);) c n
(    push\(ctx->lo, ctx->es, consname\(ctx, ") p
(signalerror) str
("\)\);) p n
(    ) S
(//printf\("8\\n"\);) c n
() p n
(    in_onerror = false;) N
(}) N
() N
(err.c) (Page 2/2) (Aug 22, 13 23:02) title
border
grestore
(Printed by U-Z1\\josh) rhead
(err.c) (22/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 23
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <errno.h>) p n
(#include) K
( <limits.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/stat.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
() N
(/* filetype objects use a slightly different interpretation) c n
(   of the access flags.) N
(   'unlimited' designates a writable file) N
(   'readonly' designates a readable file) N
(   The only oddity here is that 'unlimited' means "not readable".) N
(   */) N
() p n
(/* construct a file object.) c n
(   set the tag,) N
(   use the "doubleword" field as a "pointer" \(ent\),) N
(   allocate a FILE *,) N
(   install the FILE *,) N
(   return object.  */) N
(object consfile\(mfile *mem, ) p
(/*@NULL@*/) c
( ) p
(FILE) k
( *fp\) {) p n
(    object f;) N
(    f.tag = filetype | \(unlimited << FACCESSO\);) N
(    ) S
(//f.mark_.padw = mtalloc\(mem, 0, sizeof\(FILE *\)\);) c n
(    f.mark_.padw = gballoc\(mem, ) p
(sizeof) K
(\() p
(FILE) k
( *\)\);) p n
(    put\(mem, f.mark_.padw, 0, ) S
(sizeof) K
(\() p
(FILE) k
( *\), &fp\);) p n
(    ) S
(return) K
( f;) p n
(}) N
() N
(/* pinch-off a tmpfile containing one line from file. */) c n
(/*@null@*/) N
(FILE) k
( *lineedit\() p
(FILE) k
( *in\) {) p n
(    ) S
(FILE) k
( *fp;) p n
(    ) S
(int) k
( c;) p n
() N
(    c = fgetc\(in\);) N
(    ) S
(if) K
( \(c == EOF\) error\(undefinedfilename, ") p
(%lineedit) str
("\);) p n
(    fp = tmpfile\(\);) N
(    ) S
(if) K
( \(fp == ) p
(NULL) K
(\) { error\(ioerror, ") p
(tmpfile\(\) returned NULL) str
("\); ) p
(return) K
( ) p
(NULL) K
(; }) p n
(    ) S
(while) K
( \(c != EOF && c != ') p
(\\n) str
('\) {) p n
(        \() S
(void) k
(\)fputc\(c, fp\);) p n
(        c = fgetc\(in\);) N
(    }) N
(    fseek\(fp, 0, SEEK_SET\);) N
(    ) S
(return) K
( fp;) p n
(}) N
() N
(enum) k
( { MAXNEST = 20 };) p n
() N
(/* pinch-off a tmpfile containing one "statement" from file. */) c n
(/*@null@*/) N
(FILE) k
( *statementedit\() p
(FILE) k
( *in\) {) p n
(    ) S
(FILE) k
( *fp;) p n
(    ) S
(int) k
( c;) p n
(    ) S
(char) k
( nest[MAXNEST] = {0}; ) p
(/* any of {\(< waiting for matching >\)} */) c n
(    ) p
(int) k
( defer = -1; ) p
(/* defer is a flag \(-1 == false\)) c n
(                       and an index into nest[] */) N
(    c = fgetc\(in\);) p n
(    ) S
(if) K
( \(c == EOF\) error\(undefinedfilename, ") p
(%statementedit) str
("\);) p n
(    fp = tmpfile\(\);) N
(    ) S
(if) K
( \(fp == ) p
(NULL) K
(\) { error\(ioerror, ") p
(tmpfile\(\) returned NULL) str
("\); ) p
(return) K
( ) p
(NULL) K
(; }) p n
(f.c) (Page 1/4) (Aug 22, 13 4:43) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(do) K
( {) p n
(        ) S
(if) K
( \(defer > -1\) {) p n
(            ) S
(if) K
( \(defer > MAXNEST\) error\(syntaxerror, ") p
(syntaxerror) str
("\);) p n
(            ) S
(switch) K
(\(nest[defer]\) { ) p
(/* what's the innermost nest? */) c n
(            ) p
(case) K
( ') p
({) str
(': ) p
(/* within a proc, can end proc or begin proc, string, hex ) c n
(*/) N
(                ) p
(switch) K
( \(c\) {) p n
(                ) S
(case) K
( ') p
(}) str
(': --defer; ) p
(break) K
(;) p n
(                ) S
(case) K
( ') p
({) str
(':) p n
(                ) S
(case) K
( ') p
(\() str
(':) p n
(                ) S
(case) K
( ') p
(<) str
(': nest[++defer] = c; ) p
(break) K
(;) p n
(                } ) S
(break) K
(;) p n
(            ) S
(case) K
( ') p
(\() str
(': ) p
(/* within a string, can begin or end nested paren */) c n
(                ) p
(switch) K
( \(c\) {) p n
(                ) S
(case) K
( ') p
(\)) str
(': --defer; ) p
(break) K
(;) p n
(                ) S
(case) K
( ') p
(\() str
(': nest[++defer] = c; ) p
(break) K
(;) p n
(                ) S
(case) K
( ') p
(\\\\) str
(': fputc\(c, fp\);) p n
(                           c = fgetc\(in\);) N
(                           ) S
(if) K
( \(c == EOF\) ) p
(goto) K
( done;) p n
(                           ) S
(goto) K
( next;) p n
(                } ) S
(break) K
(;) p n
(            ) S
(case) K
( ') p
(<) str
(': ) p
(/* hexstrings don't nest, can only end it */) c n
(                ) p
(if) K
( \(c == ') p
(>) str
('\) --defer; ) p
(break) K
(;) p n
(            }) N
(        } ) S
(else) K
( ) p
(switch) K
( \(c\) { ) p
(/* undefined, can begin any structure */) c n
(        ) p
(case) K
( ') p
({) str
(':) p n
(        ) S
(case) K
( ') p
(\() str
(':) p n
(        ) S
(case) K
( ') p
(<) str
(': nest[++defer] = c; ) p
(break) K
(;) p n
(        ) S
(case) K
( ') p
(\\\\) str
(': fputc\(c, fp\);) p n
(                   c = fgetc\(in\); ) S
(break) K
(;) p n
(        }) N
(        ) S
(if) K
( \(c == ') p
(\\n) str
('\) {) p n
(            ) S
(if) K
( \(defer == -1\) ) p
(goto) K
( done;) p n
(            { ) S
(/* sub-prompt */) c n
(                ) p
(int) k
( i;) p n
(                ) S
(for) K
( \(i=0; i <= defer; i++\)) p n
(                    putchar\(nest[i]\);) N
(                fputs\(") S
(.:) str
(", stdout\);) p n
(                fflush\() S
(NULL) K
(\);) p n
(            }) N
(        }) N
(next:) N
(        fputc\(c, fp\);) N
(        c = fgetc\(in\);) N
(    } ) S
(while) K
(\(c != EOF\);) p n
(done:) N
(    fseek\(fp, 0, SEEK_SET\);) N
(    ) S
(return) K
( fp;) p n
(}) N
() N
(/* check for "special" filenames,) c n
(   fallback to fopen. */) N
(object fileopen\(mfile *mem, ) p
(char) k
( *fn, ) p
(char) k
( *mode\) {) p n
(    object f;) N
(    f.tag = filetype;) N
() N
(    ) S
(if) K
( \(strcmp\(fn, ") p
(%stdin) str
("\)==0\) {) p n
(        ) S
(if) K
( \(strcmp\(mode, ") p
(r) str
("\)!=0\) error\(invalidfileaccess, ") p
(fileopen) str
("\);) p n
(        f = consfile\(mem, stdin\);) N
(        f.tag &= ~FACCESS;) N
(        f.tag |= \(readonly << FACCESSO\);) N
(    } ) S
(else) K
( ) p
(if) K
( \(strcmp\(fn, ") p
(%stdout) str
("\)==0\) {) p n
(        ) S
(if) K
( \(strcmp\(mode, ") p
(w) str
("\)!=0\) error\(invalidfileaccess, ") p
(fileopen) str
("\);) p n
(        f = consfile\(mem, stdout\);) N
(    } ) S
(else) K
( ) p
(if) K
( \(strcmp\(fn, ") p
(%stderr) str
("\)==0\) {) p n
(        ) S
(if) K
( \(strcmp\(mode, ") p
(w) str
("\)!=0\) error\(invalidfileaccess, ") p
(fileopen) str
("\);) p n
(        f = consfile\(mem, stderr\);) N
(    } ) S
(else) K
( ) p
(if) K
( \(strcmp\(fn, ") p
(%lineedit) str
("\)==0\) {) p n
(        f = consfile\(mem, lineedit\(stdin\)\);) N
(f.c) (Page 2/4) (Aug 22, 13 4:43) title
border
grestore
(Printed by U-Z1\\josh) rhead
(f.c) (23/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 24
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        f.tag &= ~FACCESS;) p n
(        f.tag |= \(readonly << FACCESSO\);) N
(    } ) S
(else) K
( ) p
(if) K
( \(strcmp\(fn, ") p
(%statementedit) str
("\)==0\) {) p n
(        f = consfile\(mem, statementedit\(stdin\)\);) N
(        f.tag &= ~FACCESS;) N
(        f.tag |= \(readonly << FACCESSO\);) N
(    } ) S
(else) K
( {) p n
(        ) S
(FILE) k
( *fp;) p n
(        fp = fopen\(fn, mode\);) N
(        ) S
(if) K
( \(fp == ) p
(NULL) K
(\) {) p n
(            ) S
(switch) K
( \(errno\) {) p n
(            ) S
(case) K
( EACCES: error\(invalidfileaccess, ") p
(fileopen) str
("\); ) p
(break) K
(;) p n
(            ) S
(case) K
( ENOENT: error\(undefinedfilename, ") p
(fileopen) str
("\); ) p
(break) K
(;) p n
(            ) S
(default) K
(: error\(unregistered, ") p
(fileopen) str
("\); ) p
(break) K
(;) p n
(            }) N
(        }) N
(        f = consfile\(mem, fp\);) N
(        ) S
(if) K
( \(strcmp\(mode, ") p
(r) str
("\)==0\){) p n
(            f.tag &= ~FACCESS;) N
(            f.tag |= \(readonly << FACCESSO\);) N
(        }) N
(    }) N
() N
(    f.tag |= FLIT;) N
(    ) S
(return) K
( f;) p n
(}) N
() N
(/* yield the FILE* from a filetype object */) c n
(FILE) k
( *filefile\(mfile *mem, object f\) {) p n
(    ) S
(FILE) k
( *fp;) p n
(    get\(mem, f.mark_.padw, 0, ) S
(sizeof) K
(\() p
(FILE) k
( *\), &fp\);) p n
(    ) S
(return) K
( fp;) p n
(}) N
() N
(/* make sure the FILE* is not null */) c n
(bool filestatus\(mfile *mem, object f\) {) p n
(    ) S
(return) K
( filefile\(mem, f\) != ) p
(NULL) K
(;) p n
(}) N
() N
(/* call fstat. */) c n
(long) k
( filebytesavailable\(mfile *mem, object f\) {) p n
(    ) S
(int) k
( ret;) p n
(    ) S
(FILE) k
( *fp;) p n
(    ) S
(struct) k
( stat sb;) p n
(    fp = filefile\(mem, f\);) N
(    ) S
(if) K
( \(!fp\) ) p
(return) K
( -1;) p n
(    ret = fstat\(fileno\(fp\), &sb\);) N
(    ) S
(if) K
( \(ret != 0\) error\(ioerror, ") p
(fstat did not return 0) str
("\);) p n
(    ) S
(if) K
( \(sb.st_size > LONG_MAX\)) p n
(        ) S
(return) K
( LONG_MAX;) p n
(    ) S
(return) K
( \() p
(long) k
(\)sb.st_size;) p n
(}) N
() N
(/* close the file,) c n
(   NULL the FILE*. */) N
(void) k
( fileclose\(mfile *mem, object f\) {) p n
(    ) S
(FILE) k
( *fp;) p n
(    fp = filefile\(mem, f\);) N
(    ) S
(if) K
( \(fp\) {) p n
(        fclose\(fp\);) N
(        fp = ) S
(NULL) K
(;) p n
(        put\(mem, f.mark_.padw, 0, ) S
(sizeof) K
(\() p
(FILE) k
( *\), &fp\);) p n
(    }) N
(}) N
() N
(/* if the file is valid,) c n
(   read a byte. */) N
(object fileread\(mfile *mem, object f\) {) p n
(    ) S
(if) K
( \(!filestatus\(mem, f\)\) error\(ioerror, ") p
(fileread) str
("\);) p n
(f.c) (Page 3/4) (Aug 22, 13 4:43) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(return) K
( consint\(fgetc\(filefile\(mem, f\)\)\);) p n
(}) N
() N
(/* if the file is valid,) c n
(   write a byte. */) N
(void) k
( filewrite\(mfile *mem, object f, object b\) {) p n
(    ) S
(if) K
( \(!filestatus\(mem, f\)\) error\(ioerror, ") p
(filewrite) str
("\);) p n
(    ) S
(if) K
( \(fputc\(b.int_.val, filefile\(mem, f\)\) == EOF\)) p n
(        error\(ioerror, ") S
(filewrite) str
("\);) p n
(}) N
() N
(f.c) (Page 4/4) (Aug 22, 13 4:43) title
border
grestore
(Printed by U-Z1\\josh) rhead
(f.c) (24/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 25
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
() N
(#ifdef) K
( TESTMODULE) p n
(#include) K
( <stdio.h>) p n
(#endif) K n
() p n
(/* iterate through all tables,) c n
(    clear the MARK in the mark. */) N
(void) k
( unmark\(mfile *mem\) {) p n
(    mtab *tab = \() S
(void) k
( *\)\(mem->base\);) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(for) K
( \(i = mem->start; i < tab->nextent; i++\) {) p n
(        tab->tab[i].mark &= ~MARKM;) N
(    }) N
(    ) S
(while) K
( \(tab->nexttab != 0\) {) p n
(        tab = \() S
(void) k
( *\)\(mem->base + tab->nexttab\);) p n
(        ) S
(for) K
( \(i = 0; i < tab->nextent; i++\) {) p n
(            tab->tab[i].mark &= ~MARKM;) N
(        }) N
(    }) N
(}) N
() N
(/* set the MARK in the mark in the tab[ent] */) c n
(void) k
( markent\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    mtab *tab = \() S
(void) k
( *\)\(mem->base\);) p n
(    findtabent\(mem,&tab,&ent\);) N
(    tab->tab[ent].mark |= MARKM;) N
(}) N
() N
(/* is it marked? */) c n
(int) k
( marked\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    mtab *tab = \() S
(void) k
( *\)\(mem->base\);) p n
(    findtabent\(mem,&tab,&ent\);) N
(    ) S
(return) K
( \(tab->tab[ent].mark & MARKM\) >> MARKO;) p n
(}) N
() N
(void) k
( markobject\(context *ctx, mfile *mem, object o\);) p n
() N
(void) k
( markdict\(context *ctx, mfile *mem, ) p
(unsigned) k
( adr\) {) p n
(    dichead *dp = \() S
(void) k
( *\)\(mem->base + adr\);) p n
(    object *tp = \() S
(void) k
( *\)\(mem->base + adr + ) p
(sizeof) K
(\(dichead\)\);) p n
(    ) S
(int) k
( j;) p n
(    ) S
(for) K
( \(j=0; j < DICTABN\(dp->sz\); j++\) {) p n
(        markobject\(ctx, mem, tp[j]\);) N
(    }) N
(}) N
() N
(/* recursively mark all elements of array */) c n
(void) k
( markarray\(context *ctx, mfile *mem, ) p
(unsigned) k
( adr, ) p
(unsigned) k
( sz\) {) p n
(    object *op = \() S
(void) k
( *\)\(mem->base + adr\);) p n
(    ) S
(unsigned) k
( j;) p n
(    ) S
(for) K
( \(j=0; j < sz; j++\) {) p n
(        markobject\(ctx, mem, op[j]\);) N
(    }) N
(}) N
(gc.c) (Page 1/7) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* traverse the contents of composite objects */) c n
(void) k
( markobject\(context *ctx, mfile *mem, object o\) {) p n
(    ) S
(switch) K
(\(type\(o\)\) {) p n
(    ) S
(case) K
( arraytype:) p n
(#ifdef) K
( TESTMODULE) p n
(    printf\(") S
(markobject: %s %d\\n) str
(", types[type\(o\)], o.comp_.sz\);) p n
(#endif) K n
(        ) p
(if) K
( \(bank\(ctx, o\) != mem\) ) p
(break) K
(;) p n
(        ) S
(if) K
( \(!marked\(mem, o.comp_.ent\)\) {) p n
(            markent\(mem, o.comp_.ent\);) N
(            markarray\(ctx, mem, adrent\(mem, o.comp_.ent\), o.comp_.sz\);) N
(        }) N
(        ) S
(break) K
(;) p n
(    ) S
(case) K
( dicttype:) p n
(#ifdef) K
( TESTMODULE) p n
(    printf\(") S
(markobject: %s %d\\n) str
(", types[type\(o\)], o.comp_.sz\);) p n
(#endif) K n
(        ) p
(if) K
( \(bank\(ctx, o\) != mem\) ) p
(break) K
(;) p n
(        ) S
(if) K
( \(!marked\(mem, o.comp_.ent\)\) {) p n
(            markent\(mem, o.comp_.ent\);) N
(            markdict\(ctx, mem, adrent\(mem, o.comp_.ent\)\);) N
(        }) N
(        ) S
(break) K
(;) p n
(    ) S
(case) K
( stringtype:) p n
(#ifdef) K
( TESTMODULE) p n
(    printf\(") S
(markobject: %s %d\\n) str
(", types[type\(o\)], o.comp_.sz\);) p n
(#endif) K n
(        ) p
(if) K
( \(bank\(ctx, o\) != mem\) ) p
(break) K
(;) p n
(        markent\(mem, o.comp_.ent\);) N
(        ) S
(break) K
(;) p n
(    }) N
(}) N
() N
(/* mark all allocations referred to by objects in stack */) c n
(void) k
( markstack\(context *ctx, mfile *mem, ) p
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    ) S
(unsigned) k
( i;) p n
(#ifdef) K
( TESTMODULE) p n
(    printf\(") S
(marking stack of size %u\\n) str
(", s->top\);) p n
(#endif) K n
(next:) p n
(    ) S
(for) K
( \(i=0; i < s->top; i++\) {) p n
(        markobject\(ctx, mem, s->data[i]\);) N
(    }) N
(    ) S
(if) K
( \(i==STACKSEGSZ\) { ) p
(/* ie. s->top == STACKSEGSZ */) c n
(        s = \() p
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(        ) S
(goto) K
( next;) p n
(    }) N
(}) N
() N
(/* mark all allocations referred to by objects in save object's stack of saverec) c n
(_'s */) N
(void) k
( marksavestack\(context *ctx, mfile *mem, ) p
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    ) S
(unsigned) k
( i;) p n
(    \() S
(void) k
(\)ctx;) p n
(#ifdef) K
( TESTMODULE) p n
(    printf\(") S
(marking save stack of size %u\\n) str
(", s->top\);) p n
(#endif) K n
(next:) p n
(    ) S
(for) K
( \(i=0; i < s->top; i++\) {) p n
(        ) S
(//markobject\(ctx, mem, s->data[i]\);) c n
(        ) p
(//marksavestack\(ctx, mem, s->data[i].save_.stk\);) c n
(        markent\(mem, s->data[i].saverec_.src\);) p n
(        markent\(mem, s->data[i].saverec_.cpy\);) N
(    }) N
(    ) S
(if) K
( \(i==STACKSEGSZ\) { ) p
(/* ie. s->top == STACKSEGSZ */) c n
(        s = \() p
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(gc.c) (Page 2/7) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(gc.c) (25/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 26
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(goto) K
( next;) p n
(    }) N
(}) N
() N
(/* mark all allocations referred to by objects in save stack */) c n
(void) k
( marksave\(context *ctx, mfile *mem, ) p
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    ) S
(unsigned) k
( i;) p n
(#ifdef) K
( TESTMODULE) p n
(    printf\(") S
(marking save stack of size %u\\n) str
(", s->top\);) p n
(#endif) K n
(next:) p n
(    ) S
(for) K
( \(i=0; i < s->top; i++\) {) p n
(        ) S
(//markobject\(ctx, mem, s->data[i]\);) c n
(        marksavestack\(ctx, mem, s->data[i].save_.stk\);) p n
(    }) N
(    ) S
(if) K
( \(i==STACKSEGSZ\) { ) p
(/* ie. s->top == STACKSEGSZ */) c n
(        s = \() p
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(        ) S
(goto) K
( next;) p n
(    }) N
(}) N
() N
(/* free list head is in slot zero) c n
(   sz is 0 so gc will ignore it */) N
(void) k
( initfree\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( ent = mtalloc\(mem, 0, ) p
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(    ) S
(unsigned) k
( val = 0;) p n
(    assert \(ent == FREE\);) N
(    put\(mem, ent, 0, ) S
(sizeof) K
(\() p
(unsigned) k
(\), &val\);) p n
(    ) N
(    ) S
(/*) c n
(       unsigned ent = mtalloc\(mem, 0, 0\);) N
(       mtab *tab = \(void *\)mem->base;) N
(       tab->tab[ent].adr = mfalloc\(mem, sizeof\(unsigned\)\);) N
(   */) N
(}) p n
() N
(/* free this ent! */) c n
(void) k
( mfree\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    ) S
(unsigned) k
( a;) p n
(    ) S
(unsigned) k
( z;) p n
(    ) S
(return) K
(;) p n
(    a = adrent\(mem, ent\);) N
(    ) S
(if) K
( \(szent\(mem, ent\) == 0\) ) p
(return) K
(; ) p
(// ignore zero size allocs) c n
(    z = adrent\(mem, FREE\);) p n
() N
(    ) S
(/* copy the current free-list head to the data area of the ent. */) c n
(    ) p
(// *\(unsigned *\)\(mem->base + adrent\(mem, ent\)\) = mem->avail;) c n
(    memcpy\(mem->base+a, mem->base+z, ) p
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
() N
(    ) S
(/* copy the ent number into the free-list head */) c n
(    ) p
(//mem->avail = ent;) c n
(    memcpy\(mem->base+z, &ent, ) p
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(}) N
() N
(/* discard the free list.) c n
(   iterate through tables,) N
(        if element is unmarked and not zero-sized,) N
(            free it.  */) N
(void) k
( sweep\(mfile *mem\) {) p n
(    mtab *tab;) N
(    ) S
(int) k
( ntab;) p n
(    ) S
(unsigned) k
( z;) p n
(    ) S
(unsigned) k
( i;) p n
() N
(    z = adrent\(mem, FREE\);) N
(    ) S
(//memcpy\(mem->base+z, &\(unsigned\){ 0 }, sizeof\(unsigned\)\);) c n
(    *\() p
(unsigned) k
( *\)\(mem->base+z\) = 0;) p n
(    tab = \() S
(void) k
( *\)\(mem->base\);) p n
(gc.c) (Page 3/7) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ntab = 0;) p n
(    ) S
(for) K
( \(i = mem->start; i < tab->nextent; i++\) {) p n
(        ) S
(if) K
( \(\(tab->tab[i].mark & MARKM\) == 0 && tab->tab[i].sz != 0\)) p n
(            mfree\(mem, i + ntab*TABSZ\);) N
(    }) N
(    ) S
(while) K
( \(tab->nexttab != 0\) {) p n
(        tab = \() S
(void) k
( *\)\(mem->base + tab->nexttab\);) p n
(        ++ntab;) N
(        ) S
(for) K
( \(i = mem->start; i < tab->nextent; i++\) {) p n
(            ) S
(if) K
( \(\(tab->tab[i].mark & MARKM\) == 0 && tab->tab[i].sz != 0\)) p n
(                mfree\(mem, i + ntab*TABSZ\);) N
(        }) N
(        ) S
(if) K
( \(i!=TABSZ\) ) p
(break) K
(;) p n
(    }) N
(}) N
() N
(/* clear all marks,) c n
(   determine GLOBAL/LOCAL and mark all root stacks,) N
(   sweep. */) N
(void) k
( collect\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(unsigned) k
( *cid;) p n
(    context *ctx;) N
() N
(    printf\(") S
(\\ncollect:\\n) str
("\);) p n
() N
(    unmark\(mem\);) N
() N
(    ) S
(/*for\(i=mem->roots[0];i<=mem->roots[1];i++\){markstack\(mem,adrent\(mem,i\)\);}*/) c n
() p n
(    cid = \() S
(void) k
( *\)\(mem->base + adrent\(mem, CTXLIST\)\);) p n
(    ctx = ctxcid\(cid[0]\);) N
(    ) S
(/* markstack\(ctx, mem, adrent\(mem, VS\)\); */) c
( ) p
(// TODO will need a special rout) c n
(ine) N
(    marksave\(ctx, mem, adrent\(mem, VS\)\);) p n
() N
(    ) S
(if) K
( \(mem == ctx->lo\) {) p n
(        ) S
(for) K
( \(i = 0; cid[i]; i++\) {) p n
(            ctx = ctxcid\(cid[i]\);) N
(            markstack\(ctx, mem, ctx->os\);) N
(            markstack\(ctx, mem, ctx->ds\);) N
(            markstack\(ctx, mem, ctx->es\);) N
(        }) N
(    } ) N
() N
(    markstack\(ctx, mem, adrent\(mem, NAMES\)\);) N
() N
(    sweep\(mem\);) N
(}) N
() N
(void) k
( dumpfree\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( e;) p n
(    ) S
(unsigned) k
( z = adrent\(mem, FREE\);;) p n
(    printf\(") S
(freelist: ) str
("\);) p n
(    memcpy\(&e, mem->base+z, ) S
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(    ) S
(while) K
( \(e\) {) p n
(        printf\(") S
(%d\(%d\) ) str
(", e, szent\(mem, e\)\);) p n
(        z = adrent\(mem, e\);) N
(        memcpy\(&e, mem->base+z, ) S
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(    }) N
(}) N
() N
(/* scan the free list for a suitably sized bit of memory,) c n
(   if the allocator falls back to fresh memory PERIOD times,) N
(        it triggers a collection. */) N
(unsigned) k
( gballoc\(mfile *mem, ) p
(unsigned) k
( sz\) {) p n
(    ) S
(unsigned) k
( z = adrent\(mem, FREE\); ) p
(// free pointer) c n
(    ) p
(unsigned) k
( e;                     ) p
(// working pointer) c n
(    ) p
(static) K
( ) p
(int) k
( period = PERIOD;) p n
(gc.c) (Page 4/7) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(gc.c) (26/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 27
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#if) K
( 0) p n
(try_again:) N
(    memcpy\(&e, mem->base+z, ) S
(sizeof) K
(\() p
(unsigned) k
(\)\); ) p
(// e = *z) c n
(    ) p
(while) K
( \(e\) { ) p
(// e is not zero) c n
(        ) p
(if) K
( \(szent\(mem,e\) >= sz\) {) p n
(            memcpy\(mem->base+z,) N
(                    mem->base+adrent\(mem,e\), ) S
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(            ) S
(return) K
( e;) p n
(        }) N
(        z = adrent\(mem,e\);) N
(        memcpy\(&e, mem->base+z, ) S
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(    }) N
(    ) S
(if) K
( \(--period == 0\) {) p n
(        period = PERIOD;) N
(        collect\(mem\);) N
(        ) S
(goto) K
( try_again;) p n
(    }) N
(#endif) K n
(    ) p
(return) K
( mtalloc\(mem, 0, sz\);) p n
(}) N
() N
(/* allocate new entry, copy data, steal its adr, stash old adr, free it */) c n
(unsigned) k
( mfrealloc\(mfile *mem, ) p
(unsigned) k
( oldadr, ) p
(unsigned) k
( oldsize, ) p
(unsigned) k
( newsi) p n
(ze\) {) N
(    mtab *tab = ) S
(NULL) K
(;) p n
(    ) S
(unsigned) k
( newadr;) p n
(    ) S
(unsigned) k
( ent;) p n
(    ) S
(unsigned) k
( rent; ) p
(// relative ent) c n
() p n
(#ifdef) K
( DEBUGFREE) p n
(    printf\(") S
(mfrealloc: ) str
("\);) p n
(    printf\(") S
(initial ) str
("\);) p n
(    dumpfree\(mem\);) N
(#endif) K n
() p n
(    ) S
(/* allocate new entry */) c n
(    rent = ent = mtalloc\(mem, 0, newsize\);) p n
(    findtabent\(mem, &tab, &rent\);) N
() N
(    ) S
(/* steal its adr */) c n
(    newadr = tab->tab[rent].adr;) p n
() N
(    ) S
(/* copy data */) c n
(    memcpy\(mem->base + newadr, mem->base + oldadr, oldsize\);) p n
() N
(    ) S
(/* stash old adr */) c n
(    tab->tab[rent].adr = oldadr;) p n
(    tab->tab[rent].sz = oldsize;) N
() N
(    ) S
(/* free it */) c n
(    mfree\(mem, ent\);) p n
() N
(#ifdef) K
( DEBUGFREE) p n
(    printf\(") S
(final ) str
("\);) p n
(    dumpfree\(mem\);) N
(    printf\(") S
(\\n) str
("\);) p n
(    dumpmtab\(mem, 0\);) N
(    fflush\() S
(NULL) K
(\);) p n
(#endif) K n
() p n
(    ) S
(return) K
( newadr;) p n
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
() N
(context *ctx;) N
(mfile *mem;) N
(unsigned) k
( stac;) p n
() N
(gc.c) (Page 5/7) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
(void init\(void\) {) N
(    initmem\(&mem, "x.mem"\);) N
(    \(void\)initmtab\(&mem\);) N
(    initfree\(&mem\);) N
(    initsave\(&mem\);) N
(    initctxlist\(&mem\);) N
(    mtab *tab = \(void *\)mem.base;) N
(    unsigned ent = mtalloc\(&mem, 0, 0\);) N
(    //findtabent\(&mem, &tab, &ent\);) N
(    stac = tab->tab[ent].adr = initstack\(&mem\);) N
(    //mem.roots[0] = VS;) N
(    //mem.roots[1] = ent;) N
(    mem.start = ent+1;) N
(}) N
(*/) N
() p n
(extern) K
( itp *itpdata;) p n
() N
(void) k
( init\() p
(void) k
(\) {) p n
(    itpdata = malloc\() S
(sizeof) K
(*itpdata\);) p n
(    memset\(itpdata, 0, ) S
(sizeof) K
(*itpdata\);) p n
(    inititp\(itpdata\);) N
(}) N
() N
(int) k
( main\() p
(void) k
(\) {) p n
(    init\(\);) N
(    printf\(") S
(\\n^test gc.c\\n) str
("\);) p n
(    ctx = &itpdata->ctab[0];) N
(    mem = ctx->lo;) N
(    stac = ctx->os;) N
() N
(    push\(mem, stac, consint\(5\)\);) N
(    push\(mem, stac, consint\(6\)\);) N
(    push\(mem, stac, consreal\(7.0\)\);) N
(    object ar;) N
(    ar = consarr\(mem, 3\);) N
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i=0; i < 3; i++\)) p n
(        arrput\(mem, ar, i, pop\(mem, stac\)\);) N
(    push\(mem, stac, ar\);                   ) S
(/* array on stack */) c n
() p n
(    push\(mem, stac, consint\(1\)\);) N
(    push\(mem, stac, consint\(2\)\);) N
(    push\(mem, stac, consint\(3\)\);) N
(    ar = consarr\(mem, 3\);) N
(    ) S
(for) K
( \(i=0; i < 3; i++\)) p n
(        arrput\(mem, ar, i, pop\(mem, stac\)\);) N
(    dumpobject\(ar\);) N
(    ) S
(/* array not on stack */) c n
() p n
(#define) K
( CNT_STR\(x\) ) p
(sizeof) K
(\(x\), x) p n
(    push\(mem, stac, consstr\(mem, CNT_STR\(") S
(string on stack) str
("\)\)\);) p n
() N
(    dumpobject\(consstr\(mem, CNT_STR\(") S
(string not on stack) str
("\)\)\);) p n
() N
(    collect\(mem\);) N
(    push\(mem, stac, consstr\(mem, CNT_STR\(") S
(string on stack) str
("\)\)\);) p n
(    dumpobject\(consstr\(mem, CNT_STR\(") S
(string not on stack) str
("\)\)\);) p n
() N
(    collect\(mem\);) N
(    dumpmfile\(mem\);) N
(    printf\(") S
(stackaedr: %04x\\n) str
(", stac\);) p n
(    dumpmtab\(mem, 0\);) N
(    ) S
(//     ^ent 8 \(8\): adr 3404 0x0d4c, sz [24], mark _) c n
(    ) p
(//     ^ 06  00  00  00  6en 67g 20  6en 6fo 74t 20) c n
(    printf\(") p
(gc: look at the mark field . . . . . . . .^\\n) str
("\);) p n
(    printf\(") S
(also, see that the first 4 bytes of strings not on stack\\n) str
(") p n
(           ") S
(have been obliterated to link-up the free list.\\n) str
("\);) p n
(gc.c) (Page 6/7) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(gc.c) (27/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7,1) 28
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
(gc.c) (Page 7/7) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <setjmp.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(" ) p
(/* context itp MAXCONTEXT MAXMFILE */) c n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(f.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(optok.h) str
(") p n
(#include) K
( ") p
(opdi.h) str
(") p n
() N
(int) k
( TRACE = 0;) p n
(itp *itpdata;) N
(int) k
( initializing = 0;) p n
() N
(#if) K
( 0) p n
(/* allocate a stack as a "special entry",) c n
(   and double-check that it's the right entry */) N
(void) k
( makestack\(mfile *mem, ) p
(unsigned) k
( stk\) {) p n
(    ) S
(unsigned) k
( ent;) p n
(    mtab *tab;) N
(    ent = mtalloc\(mem, 0, 0\); ) S
(/* allocate an entry of zero length */) c n
(    assert\(ent == stk\);) p n
(    tab = \() S
(void) k
( *\)mem->base;) p n
(    tab->tab[ent].adr = initstack\(mem\);) N
(}) N
(#endif) K n
() p n
(unsigned) k
( makestack\(mfile *mem\){) p n
(    ) S
(return) K
( initstack\(mem\);) p n
(}) N
() N
(void) k
( initctxlist\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( ent;) p n
(    mtab *tab;) N
(    ent = mtalloc\(mem, 0, MAXCONTEXT * ) S
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(    assert\(ent == CTXLIST\);) N
(    tab = \() S
(void) k
( *\)mem->base;) p n
(    memset\(mem->base + tab->tab[CTXLIST].adr, 0,) N
(            MAXCONTEXT * ) S
(sizeof) K
(\() p
(unsigned) k
(\)\);) p n
(}) N
() N
(void) k
( addtoctxlist\(mfile *mem, ) p
(unsigned) k
( cid\) {) p n
(    ) S
(int) k
( i;) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( *ctxlist;) p n
(    tab = \() S
(void) k
( *\)mem->base;) p n
(    ctxlist = \() S
(void) k
( *\)\(mem->base + tab->tab[CTXLIST].adr\);) p n
(    ) S
(// find first empty) c n
(    ) p
(for) K
( \(i=0; i < MAXCONTEXT; i++\) {) p n
(        ) S
(if) K
( \(ctxlist[i] == 0\) {) p n
(            ctxlist[i] = cid;) N
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
(    error\(unregistered, ") S
(ctxlist full) str
("\);) p n
(itp.c) (Page 1/8) (Aug 24, 13 14:12) title
border
grestore
(Printed by U-Z1\\josh) rhead
(gc.c, itp.c) (28/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 29
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(mfile *nextgtab\(\) {) N
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i=0; i < MAXMFILE; i++\) {) p n
(        ) S
(if) K
( \(itpdata->gtab[i].base == ) p
(NULL) K
(\) {) p n
(            ) S
(return) K
( &itpdata->gtab[i];) p n
(        }) N
(    }) N
(    error\(unregistered, ") S
(cannot allocate mfile, gtab exhausted) str
("\);) p n
(    exit\(EXIT_FAILURE\);) N
(}) N
() N
(/* set up global vm in the context */) c n
(void) k
( initglobal\(context *ctx\) {) p n
(    ctx->vmmode = GLOBAL;) N
() N
(    ) S
(/* allocate and initialize global vm */) c n
(    ) p
(//ctx->gl = malloc\(sizeof\(mfile\)\);) c n
(    ) p
(//ctx->gl = &itpdata->gtab[0];) c n
(    ctx->gl = nextgtab\(\);) p n
() N
(    initmem\(ctx->gl, ") S
(g.mem) str
("\);) p n
(    \() S
(void) k
(\)initmtab\(ctx->gl\);) p n
(    initfree\(ctx->gl\);) N
(    initsave\(ctx->gl\);) N
(    initctxlist\(ctx->gl\);) N
(    addtoctxlist\(ctx->gl, ctx->id\);) N
() N
(    ctx->gl->start = OPTAB + 1; ) S
(/* so OPTAB is not collected and not scanned. */) c n
(}) p n
() N
(mfile *nextltab\(\) {) N
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i=0; i < MAXMFILE; i++\) {) p n
(        ) S
(if) K
( \(itpdata->ltab[i].base == ) p
(NULL) K
(\) {) p n
(            ) S
(return) K
( &itpdata->ltab[i];) p n
(        }) N
(    }) N
(    error\(unregistered, ") S
(cannot allocate mfile, ltab exhausted) str
("\);) p n
(    exit\(EXIT_FAILURE\);) N
(}) N
() N
(/* set up local vm in the context */) c n
(void) k
( initlocal\(context *ctx\) {) p n
(    ctx->vmmode = LOCAL;) N
() N
(    ) S
(/* allocate and initialize local vm */) c n
(    ) p
(//ctx->lo = malloc\(sizeof\(mfile\)\);) c n
(    ) p
(//ctx->lo = &itpdata->ltab[0];) c n
(    ctx->lo = nextltab\(\);) p n
() N
(    initmem\(ctx->lo, ") S
(l.mem) str
("\);) p n
(    \() S
(void) k
(\)initmtab\(ctx->lo\);) p n
(    initfree\(ctx->lo\);) N
(    initsave\(ctx->lo\);) N
(    initctxlist\(ctx->lo\);) N
(    addtoctxlist\(ctx->lo, ctx->id\);) N
(    ) S
(//ctx->lo->roots[0] = VS;) c n
() p n
(    ctx->os = makestack\(ctx->lo\);) N
(    ctx->es = makestack\(ctx->lo\);) N
(    ctx->ds = makestack\(ctx->lo\);) N
(    ctx->hold = makestack\(ctx->lo\);) N
(    ) S
(//ctx->lo->roots[1] = DS;) c n
(    ) p
(//ctx->lo->start = HOLD + 1; /* so HOLD is not collected and not scanned. */) c n
(    ) p
(//ctx->lo->start = CTXLIST + 1;) c n
(    ctx->lo->start = BOGUSNAME + 1;) p n
(}) N
(itp.c) (Page 2/8) (Aug 24, 13 14:12) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(unsigned) k
( nextid = 0;) p n
(unsigned) k
( initctxid\() p
(void) k
(\) {) p n
(    ) S
(unsigned) k
( startid = nextid;) p n
(    ) S
(while) K
( \( ctxcid\(++nextid\)->state != 0 \) {) p n
(        ) S
(if) K
( \(nextid == startid + MAXCONTEXT\)) p n
(            error\(unregistered, ") S
(ctab full. cannot create new process) str
("\);) p n
(    }) N
(    ) S
(return) K
( nextid;) p n
(}) N
() N
(context *ctxcid\() S
(unsigned) k
( cid\) {) p n
(    ) S
(//TODO reject cid 0) c n
(    ) p
(return) K
( &itpdata->ctab[ \(cid-1\) % MAXCONTEXT ];) p n
(}) N
() N
() N
(/* initialize context */) c n
(void) k
( initcontext\(context *ctx\) {) p n
(    ctx->id = initctxid\(\);) N
(    initlocal\(ctx\);) N
(    initglobal\(ctx\);) N
() N
(    initnames\(ctx\); ) S
(/* NAMES NAMET */) c n
(    ctx->vmmode = GLOBAL;) p n
() N
(    initoptab\(ctx\); ) S
(/* allocate and zero the optab structure */) c n
() p n
(    \() S
(void) k
(\)consname\(ctx, ") p
(maxlength) str
("\); ) p
(/* seed the tree with a word from the middl) c n
(e of the alphabet */) N
(    \() p
(void) k
(\)consname\(ctx, ") p
(getinterval) str
("\); ) p
(/* middle of the start */) c n
(    \() p
(void) k
(\)consname\(ctx, ") p
(setmiterlimit) str
("\); ) p
(/* middle of the end */) c n
() p n
(    initop\(ctx\); ) S
(/* populate the optab \(and systemdict\) with operators */) c n
() p n
(    {) N
(        object gd; ) S
(//globaldict) c n
(        gd = consbdc\(ctx, 100\);) p n
(        bdcput\(ctx, bot\(ctx->lo, ctx->ds, 0\), consname\(ctx, ") S
(globaldict) str
("\), gd\);) p n
(        push\(ctx->lo, ctx->ds, gd\);) N
(    }) N
() N
(    ctx->vmmode = LOCAL;) N
(    \() S
(void) k
(\)consname\(ctx, ") p
(minimal) str
("\); ) p
(/* seed the tree with a word from the middle ) c n
(of the alphabet */) N
(    \() p
(void) k
(\)consname\(ctx, ") p
(interest) str
("\); ) p
(/* middle of the start */) c n
(    \() p
(void) k
(\)consname\(ctx, ") p
(solitaire) str
("\); ) p
(/* middle of the end */) c n
(    {) p n
(        object ud; ) S
(//userdict) c n
(        ud = consbdc\(ctx, 100\);) p n
(        bdcput\(ctx, bot\(ctx->lo, ctx->ds, 0\), consname\(ctx, ") S
(userdict) str
("\), ud\);) p n
(        push\(ctx->lo, ctx->ds, ud\);) N
(    }) N
(}) N
() N
(/* destroy context */) c n
(void) k
( exitcontext\(context *ctx\) {) p n
(    exitmem\(ctx->gl\);) N
(    exitmem\(ctx->lo\);) N
(}) N
() N
(/*) c n
(   fork new process with private global and private local vm) N
(   \(spawn jobserver\)) N
(   */) N
(unsigned) k
( fork1\(context *ctx\) {) p n
(    ) S
(unsigned) k
( newcid;) p n
(    context *newctx;) N
(itp.c) (Page 3/8) (Aug 24, 13 14:12) title
border
grestore
(Printed by U-Z1\\josh) rhead
(itp.c) (29/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4-5) 30
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    newcid = initctxid\(\);) p n
(    newctx = ctxcid\(newcid\);) N
(    initlocal\(ctx\);) N
(    initglobal\(ctx\);) N
(    ctx->vmmode = LOCAL;) N
(    ) S
(return) K
( newcid;) p n
(}) N
() N
(/*) c n
(   fork new process with shared global vm and private local vm) N
(   \(new "application"?\)) N
(   */) N
(unsigned) k
( fork2\(context *ctx\) {) p n
(    ) S
(unsigned) k
( newcid;) p n
(    context *newctx;) N
(    newcid = initctxid\(\);) N
(    newctx = ctxcid\(newcid\);) N
(    initlocal\(ctx\);) N
(    newctx->gl = ctx->gl;) N
(    addtoctxlist\(newctx->gl, newcid\);) N
(    push\(newctx->lo, newctx->ds, bot\(ctx->lo, ctx->ds, 0\)\); ) S
(// systemdict) c n
(    ) p
(return) K
( newcid;) p n
(}) N
() N
(/*) c n
(   fork new process with shared global and shared local vm) N
(   \(lightweight process\)) N
(   */) N
(unsigned) k
( fork3\(context *ctx\) {) p n
(    ) S
(unsigned) k
( newcid;) p n
(    context *newctx;) N
(    newcid = initctxid\(\);) N
(    newctx = ctxcid\(newcid\);) N
(    newctx->lo = ctx->lo;) N
(    addtoctxlist\(newctx->lo, newcid\);) N
(    newctx->gl = ctx->gl;) N
(    addtoctxlist\(newctx->gl, newcid\);) N
(    push\(newctx->lo, newctx->ds, bot\(ctx->lo, ctx->ds, 0\)\); ) S
(// systemdict) c n
(    ) p
(return) K
( newcid;) p n
(}) N
() N
() N
(/* initialize itp */) c n
(void) k
( inititp\(itp *itp\){) p n
(    initcontext\(&itp->ctab[0]\);) N
(    itp->cid = itp->ctab[0].id;) N
(}) N
() N
(/* destroy itp */) c n
(void) k
( exititp\(itp *itp\){) p n
(    exitcontext\(&itp->ctab[0]\);) N
(}) N
() N
() N
(/* return the global or local memory file for the composite object */) c n
(/*@dependent@*/) N
(mfile *bank\(context *ctx, object o\) {) p n
(    ) S
(return) K
( o.tag&FBANK? ctx->gl : ctx->lo;) p n
(}) N
() N
() N
(/* function type for interpreter action pointers */) c n
(typedef) K
( ) p
(void) k
( evalfunc\(context *ctx\);) p n
() N
(/* quit the interpreter */) c n
(void) k
( evalquit\(context *ctx\) { ++ctx->quit; }) p n
() N
(/* pop the execution stack */) c n
(void) k
( evalpop\(context *ctx\) { \() p
(void) k
(\)pop\(ctx->lo, ctx->es\); }) p n
(itp.c) (Page 4/8) (Aug 24, 13 14:12) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* pop the execution stack onto the operand stack */) c n
(void) k
( evalpush\(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os,) N
(            pop\(ctx->lo, ctx->es\) \);) N
(}) N
() N
(/* load executable name */) c n
(void) k
( evalload\(context *ctx\) {) p n
(    object s = strname\(ctx, top\(ctx->lo, ctx->es, 0\)\);) N
(    ) S
(if) K
( \(TRACE\)) p n
(        printf\(") S
(evalload <name \\"%*s\\">) str
(", s.comp_.sz, charstr\(ctx, s\)\);) p n
() N
(    push\(ctx->lo, ctx->os,) N
(            pop\(ctx->lo, ctx->es\)\);) N
(    assert\(ctx->gl->base\);) N
(    opexec\(ctx, consoper\(ctx, ") S
(load) str
(", ) p
(NULL) K
(,0,0\).mark_.padw\);) p n
(    ) S
(if) K
( \(isx\(top\(ctx->lo, ctx->os, 0\)\)\) {) p n
(        push\(ctx->lo, ctx->es,) N
(                pop\(ctx->lo, ctx->os\)\);) N
(    }) N
(}) N
() N
(/* execute operator */) c n
(void) k
( evaloperator\(context *ctx\) {) p n
(    object op = pop\(ctx->lo, ctx->es\);) N
(    ) S
(if) K
( \(TRACE\)) p n
(        dumpoper\(ctx, op.mark_.padw\);) N
(    opexec\(ctx, op.mark_.padw\);) N
(}) N
() N
(/* extract head \(&tail\) of array */) c n
(void) k
( evalarray\(context *ctx\) {) p n
(    object a = pop\(ctx->lo, ctx->es\);) N
(    object b;) N
(    ) S
(switch) K
( \(a.comp_.sz\) {) p n
(    ) S
(default) K
( ) p
(/* > 1 */) c
(:) p n
(        push\(ctx->lo, ctx->es, arrgetinterval\(a, 1, a.comp_.sz - 1\) \);) N
(        ) S
(/*@fallthrough@*/) c n
(    ) p
(case) K
( 1:) p n
(        b = barget\(ctx, a, 0\);) N
(        ) S
(if) K
( \(type\(b\) == arraytype\)) p n
(            push\(ctx->lo, ctx->os, b\);) N
(        ) S
(else) K n
(            push\(ctx->lo, ctx->es, b\);) p n
(        ) S
(/*@fallthrough@*/) c n
(    ) p
(case) K
( 0: ) p
(/* drop */) c
(;) p n
(    }) N
(}) N
() N
(/* extract token from string */) c n
(void) k
( evalstring\(context *ctx\) {) p n
(    object b,t,s;) N
(    s = pop\(ctx->lo, ctx->es\);) N
(    push\(ctx->lo, ctx->os, s\);) N
(    assert\(ctx->gl->base\);) N
(    opexec\(ctx, consoper\(ctx, ") S
(token) str
(",) p
(NULL) K
(,0,0\).mark_.padw\);) p n
(    b = pop\(ctx->lo, ctx->os\);) N
(    ) S
(if) K
( \(b.int_.val\) {) p n
(        t = pop\(ctx->lo, ctx->os\);) N
(        s = pop\(ctx->lo, ctx->os\);) N
(        push\(ctx->lo, ctx->es, s\);) N
(        push\(ctx->lo, type\(t\)==arraytype? ctx->os: ctx->es, t\);) N
(    }) N
(}) N
() N
(/* extract token from file */) c n
(void) k
( evalfile\(context *ctx\) {) p n
(    object b,f,t;) N
(itp.c) (Page 5/8) (Aug 24, 13 14:12) title
border
grestore
(Printed by U-Z1\\josh) rhead
(itp.c) (30/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (6-7) 31
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    f = pop\(ctx->lo, ctx->es\);) p n
(    push\(ctx->lo, ctx->os, f\);) N
(    assert\(ctx->gl->base\);) N
(    opexec\(ctx, consoper\(ctx, ") S
(token) str
(",) p
(NULL) K
(,0,0\).mark_.padw\);) p n
(    b = pop\(ctx->lo, ctx->os\);) N
(    ) S
(if) K
( \(b.int_.val\) {) p n
(        t = pop\(ctx->lo, ctx->os\);) N
(        push\(ctx->lo, ctx->es, f\);) N
(        push\(ctx->lo, type\(t\)==arraytype? ctx->os: ctx->es, t\);) N
(    }) N
(}) N
() N
(/* interpreter actions for executable types */) c n
(evalfunc *evalinvalid = evalquit;) p n
(evalfunc *evalmark = evalpush;) N
(evalfunc *evalnull = evalpop;) N
(evalfunc *evalinteger = evalpush;) N
(evalfunc *evalboolean = evalpush;) N
(evalfunc *evalreal = evalpush;) N
(evalfunc *evalsave = evalpush;) N
(evalfunc *evaldict = evalpush;) N
(evalfunc *evalextended = evalquit;) N
() N
(evalfunc *evalcontext = evalpush;) N
(//evalfunc *evalfile = evalpush;) c n
(evalfunc *evalname = evalload;) p n
() N
(/* install the evaltype functions \(possibly via pointers\) in the jump table */) c n
(evalfunc *evaltype[NTYPES + 1];) p n
(#define) K
( AS_EVALINIT\(_\) evaltype[ _ ## type ] = eval ## _ ;) p n
(void) k
( initevaltype\() p
(void) k
(\) {) p n
(    TYPES\(AS_EVALINIT\)) N
(}) N
() N
() N
(void) k
( eval\(context *ctx\) {) p n
(    object t = top\(ctx->lo, ctx->es, 0\);) N
(    ctx->currentobject = t;) N
(    assert\(ctx\);) N
(    assert\(ctx->lo\);) N
(    assert\(ctx->lo->base\);) N
(    assert\(ctx->gl\);) N
(    assert\(ctx->gl->base\);) N
() N
(    ) S
(if) K
( \(TRACE\) {) p n
(        printf\(") S
(\\neval\\n) str
("\);) p n
(        printf\(") S
(Executing: ) str
("\);) p n
(        dumpobject\(t\);) N
(        printf\(") S
(\\n) str
("\);) p n
(        printf\(") S
(Stack: ) str
("\);) p n
(        dumpstack\(ctx->lo, ctx->os\);) N
(        printf\(") S
(\\n) str
("\);) p n
(        printf\(") S
(Dict Stack: ) str
("\);) p n
(        dumpstack\(ctx->lo, ctx->ds\);) N
(        printf\(") S
(\\n) str
("\);) p n
(        printf\(") S
(Exec Stack: ) str
("\);) p n
(        dumpstack\(ctx->lo, ctx->es\);) N
(        printf\(") S
(\\n) str
("\);) p n
(    }) N
() N
(    ) S
(if) K
( \( isx\(t\) \) ) p
(/* if executable */) c n
(        evaltype[type\(t\)]\(ctx\);) p n
(    ) S
(else) K n
(        evalpush\(ctx\);) p n
(}) N
() N
(jmp_buf jbmainloop;) N
(bool jbmainloopset = false;) N
() N
(itp.c) (Page 6/8) (Aug 24, 13 14:12) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( mainloop\(context *ctx\) {) p n
(    ) S
(volatile) K
( ) p
(int) k
( err; ) p n
() N
(    ) S
(if) K
( \(\(err = setjmp\(jbmainloop\)\)\) {) p n
(        onerror\(ctx, err\);) N
(    }) N
(    jbmainloopset = true;) N
() N
(    ) S
(while) K
(\(!ctx->quit\)) p n
(        eval\(ctx\);) N
() N
(    jbmainloopset = false;) N
(}) N
() N
() N
(void) k
( dumpctx\(context *ctx\) {) p n
(    dumpmfile\(ctx->gl\);) N
(    dumpmtab\(ctx->gl, 0\);) N
(    dumpmfile\(ctx->lo\);) N
(    dumpmtab\(ctx->lo, 0\);) N
(    dumpnames\(ctx\);) N
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
() N
(context *ctx;) N
(#define) K
( CNT_STR\(s\) ) p
(sizeof) K
(\(s\)-1, s) p n
() N
(void) k
( init\() p
(void) k
(\) {) p n
(    pgsz = getpagesize\(\);) N
(    initializing = 1;) N
(    initevaltype\(\);) N
() N
(    null = cvlit\(null\);) N
(    itpdata = malloc\() S
(sizeof) K
(*itpdata\);) p n
(    ) S
(if) K
( \(!itpdata\) error\(unregistered, ") p
(itpdata=malloc failed) str
("\);) p n
(    memset\(itpdata, 0, ) S
(sizeof) K
(*itpdata\);) p n
(    inititp\(itpdata\);) N
(    ctx = &itpdata->ctab[0];) N
(}) N
() N
(void) k
( xit\(\) {) p n
(    exititp\(itpdata\);) N
(    exit\(0\);) N
(}) N
() N
() N
(int) k
( main\() p
(void) k
(\) {) p n
(    printf\(") S
(\\n^test itp.c\\n) str
("\);) p n
() N
(    ) S
(//TRACE=1;) c n
(    init\(\);) p n
() N
(    ) S
(//dumpoper\(ctx, 19\);) c n
(    ) p
(//dumpctx\(ctx\);   /* double-check pre-initialized memory */) c n
(    ) p
(//xit\(\);) c n
() p n
(    ) S
(/* load init.ps and err.ps */) c n
(    assert\(ctx->gl->base\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(quit) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvx\(consbst\(ctx, CNT_STR\(") S
(\(init.ps\) \(r\) file cvx exec) str
("\)\)\)\);) p n
(    ctx->quit = 0;) N
(    mainloop\(ctx\);) N
() N
(    ) S
(/* Run! */) c n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") p
(quit) str
(", ) p
(NULL) K
(,0,0\)\); ) p n
(    push\(ctx->lo, ctx->es, cvx\(consname\(ctx, ") S
(start) str
("\)\)\); ) p
(/* `start` proc defined i) c n
(n init.ps */) N
(    initializing = 0;) p n
(itp.c) (Page 7/8) (Aug 24, 13 14:12) title
border
grestore
(Printed by U-Z1\\josh) rhead
(itp.c) (31/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (8,1) 32
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ctx->quit = 0;) p n
(    mainloop\(ctx\);) N
() N
(    dumpoper\(ctx, 1\); ) S
(// is this pointer value constant?) c n
() p n
(    printf\(") S
(bye!\\n) str
("\); fflush\() p
(NULL) K
(\);) p n
(    xit\(\);) N
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
(itp.c) (Page 8/8) (Aug 24, 13 14:12) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(#include) K
( <assert.h>) p n
(#include) K
( <ctype.h> ) p
(/* isprint */) c n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdlib.h> ) p
(/* exit free malloc realloc */) c n
(#include) K
( <stdio.h> ) p
(/* fprintf printf perror */) c n
(#include) K
( <string.h> ) p
(/* memset */) c n
(#include) K
( <unistd.h> ) p
(/* getpagesize */) c n
() p n
(#include) K
( <sys/stat.h> ) p
(/* open */) c n
(#include) K
( <fcntl.h> ) p
(/* open */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
() N
(unsigned) k
( pgsz ) p
(/*= getpagesize\(\)*/) c
( = 4096;) p n
() N
(/*) c n
(typedef struct {) N
(    unsigned char *base;) N
(    unsigned used;) N
(    unsigned max;) N
(} mfile;) N
(*/) N
() p n
(/* dump mfile details to stdout */) c n
(void) k
( dumpmfile\(mfile *mem\){) p n
(    ) S
(unsigned) k
( u, v;) p n
(    printf\(") S
({mfile: base = %p, ) str
(") p n
(            ") S
(used = 0x%x \(%u\), ) str
(") p n
(            ") S
(max = 0x%x \(%u\), ) str
(") p n
(            ) S
(//"roots = [%d %d], ") c n
(            ") p
(start = %d}\\n) str
(",) p n
(            mem->base,) N
(            mem->used, mem->used,) N
(            mem->max, mem->max,) N
(            ) S
(//mem->roots[0], mem->roots[1],) c n
(            mem->start\);) p n
(    ) S
(for) K
( \(u=0; u < mem->used; u++\) {) p n
(        ) S
(if) K
( \(u%16 == 0\) {) p n
(            ) S
(if) K
( \(u != 0\) {) p n
(                ) S
(for) K
( \(v= u-16; v < u; v++\) {) p n
(                    \() S
(void) k
(\)putchar\(isprint\(mem->base[v]\)? mem->base[v] : ') p
(.) str
('\);) p n
(                }) N
(            }) N
(            printf\(") S
(\\n%06u %04x: ) str
(", u, u\);) p n
(        }) N
(        printf\(") S
(%02x ) str
(", \() p
(unsigned) k
(\) mem->base[u]\);) p n
(    }) N
(    ) S
(if) K
( \(\(u-1\)%16 != 0\) { ) p
(//did not print in the last iteration of the loop) c n
(        ) p
(for) K
( \(v= u; v%16 != 0; v++\) printf\(") p
(   ) str
("\);) p n
(        ) S
(for) K
( \(v= u - \(u%16\); v < u; v++\) {) p n
(            \() S
(void) k
(\)putchar\(isprint\(mem->base[v]\)? mem->base[v] : ') p
(.) str
('\);) p n
(        }) N
(    }) N
(    \() S
(void) k
(\)puts\(""\);) p n
(}) N
() N
(/* memfile exists in path */) c n
(int) k
( getmemfile\() p
(char) k
( *fname\){) p n
(    ) S
(int) k
( fd;) p n
(    fd = open\() N
(            fname, ) S
(//"x.mem",) c n
(            O_RDWR | O_CREAT,) p n
(            S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH \);) N
(    ) S
(if) K
( \(fd == -1\)) p n
(        perror\(fname\);) N
(m.c) (Page 1/6) (Aug 30, 13 4:28) title
border
grestore
(Printed by U-Z1\\josh) rhead
(itp.c, m.c) (32/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 33
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(return) K
( fd;) p n
(}) N
() N
(/* initialize the memory file */) c n
(void) k
( initmem\(mfile *mem, ) p
(char) k
( *fname\){) p n
(    ) S
(int) k
( fd = -1;) p n
(    ) S
(struct) k
( stat buf;) p n
(    size_t sz = pgsz;) N
() N
(    ) S
(if) K
( \(fname\) {) p n
(        fd = getmemfile\(fname\);) N
(    }) N
(    mem->fd = fd;) N
(    ) S
(if) K
( \(fd != -1\){) p n
(        ) S
(if) K
( \(fstat\(fd, &buf\) == 0\) {) p n
(            sz = buf.st_size;) N
(            ) S
(if) K
( \(sz < pgsz\) sz = pgsz;) p n
(        }) N
(    }) N
() N
(#ifdef) K
( MMAP) p n
(    mem->base = mmap\() S
(NULL) K
(,) p n
(            sz,) N
(            PROT_READ|PROT_WRITE,) N
(            MAP_SHARED ) S
(//MAP_PRIVATE) c n
(# ifndef) K
( MREMAP) p n
(            |MAP_AUTOGROW) N
(# endif) K n
(            | \(fd == -1? MAP_ANONYMOUS : 0\) , fd, 0\);) p n
(    ) S
(if) K
( \(mem->base == MAP_FAILED\) { ) p
(// .) c n
(#else) K n
(    mem->base = malloc\(sz\);) p n
(    ) S
(if) K
( \(mem->base == ) p
(NULL) K
(\) { ) p
(// ..) c n
(#endif) K n
(        error\(VMerror, ") p
(VM error: failed to allocate mfile data) str
("\);) p n
(        exit\(EXIT_FAILURE\);) N
(    } ) S
(// . ..) c n
(    mem->used = 0;) p n
(    mem->max = sz;) N
(#ifndef) K
( MMAP) p n
(    ) S
(/* read file into malloc'd memory */) c n
(    ) p
(if) K
( \(fd != -1\)) p n
(        read\(fd, mem->base, sz\);) N
(#endif) K n
(}) p n
() N
(/* destroy the memory file */) c n
(void) k
( exitmem\(mfile *mem\){) p n
(#ifdef) K
( MMAP) p n
(    msync\(mem->base, mem->used, MS_SYNC\);) N
(    munmap\(mem->base, mem->max\);) N
(#else) K n
(    ) p
(if) K
( \(mem->fd != -1\) {) p n
(        \() S
(void) k
(\)lseek\(mem->fd, 0, SEEK_SET\);) p n
(        write\(mem->fd, mem->base, mem->used\);) N
(    }) N
(    free\(mem->base\);) N
(#endif) K n
(    mem->base = ) p
(NULL) K
(;) p n
(    mem->used = 0;) N
(    mem->max = 0;) N
() N
(    ) S
(if) K
( \(mem->fd != -1\) {) p n
(        ) S
(/* int ftruncate\(int fd, off_t length\); */) c n
(        ) p
(/* The truncate\(\) and ftruncate\(\) functions cause the) c n
(           regular file named by path or referenced by fd to) N
(           be truncated to a size of precisely length bytes. */) N
(        close\(mem->fd\);) p n
(    }) N
(m.c) (Page 2/6) (Aug 30, 13 4:28) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(/* reallocate and possibly move mem->base */) c n
(mfile *growmem\(mfile *mem, ) p
(unsigned) k
( sz\){) p n
(    ) S
(void) k
( *tmp;) p n
(    printf\(") S
(growmem: %p %u + %u\\n) str
(", mem, mem->max, sz\);) p n
(    ) S
(if) K
( \(sz < pgsz\) sz = pgsz;) p n
(    ) S
(else) K
( sz = \(sz/pgsz + 1\) * pgsz;) p n
(    sz += mem->max;) N
(#ifdef) K
( MMAP) p n
(# ifdef) K
( MREMAP) p n
(    tmp = mremap\(mem->base, mem->max, sz, MREMAP_MAYMOVE\);) N
(# else) K n
(    tmp = mem->base; ) p
(/* without mremap, rely on MAP_AUTOGROW */) c n
(# endif) K n
(    ) p
(if) K
( \(tmp == MAP_FAILED\)) p n
(#else) K n
(    tmp = realloc\(mem->base, sz\);) p n
(    ) S
(if) K
( \(tmp == ) p
(NULL) K
(\)) p n
(#endif) K n
(        error\(VMerror, ") p
(unable to grow memory) str
("\);) p n
(    mem->base = tmp;) N
(    mem->max = sz;) N
(    ) S
(return) K
( mem;) p n
(}) N
() N
(/* allocate memory, returns offset in memory file) c n
(   possible growmem.) N
(   MUST recalculate all pointers derived from mem->base) N
(        after this function) N
( */) N
(unsigned) k
( mfalloc\(mfile *mem, ) p
(unsigned) k
( sz\){) p n
(    ) S
(unsigned) k
( adr = mem->used;) p n
(    ) S
(if) K
( \(sz\) {) p n
(        ) S
(if) K
( \(sz + mem->used >=) p n
(                mem->max\) mem = growmem\(mem,sz\);) N
(        mem->used += sz;) N
(        memset\(mem->base+adr, 0, sz\);  ) S
(//bzero\(mem->base+adr, sz\);) c n
(        ) p
(/* bus error with mremap\(SHARED,ANON\)! */) c n
(    }) p n
(    ) S
(return) K
( adr;) p n
(}) N
() N
() N
(#if) K
( 0) p n
(#define) K
( TABSZ 1000) p n
(typedef) K
( ) p
(struct) k
( {) p n
(    ) S
(unsigned) k
( nexttab; ) p
(/* next table in chain */) c n
(    ) p
(unsigned) k
( nextent; ) p
(/* next slot in table, or TABSZ if none */) c n
(    ) p
(struct) k
( {) p n
(        ) S
(unsigned) k
( adr;) p n
(        ) S
(unsigned) k
( sz;) p n
(        ) S
(/* add fields here for ref counts or marks */) c n
(    } tab[TABSZ];) p n
(} mtab;) N
(#endif) K n
() p n
(/* dump mtab details to stdout */) c n
(void) k
( dumpmtab\(mfile *mem, ) p
(unsigned) k
( mtabadr\){) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(unsigned) k
( e;) p n
(    mtab *tab;) N
(    e = 0;) N
() N
(next_table:) N
(    tab = \() S
(void) k
( *\)\(mem->base + mtabadr\);) p n
(    printf\(") S
(nexttab: 0x%04x\\n) str
(", tab->nexttab\);) p n
(    printf\(") S
(nextent: %u\\n) str
(", tab->nextent\);) p n
(    ) S
(for) K
( \(i=0; i<tab->nextent; i++, e++\) {) p n
(m.c) (Page 3/6) (Aug 30, 13 4:28) title
border
grestore
(Printed by U-Z1\\josh) rhead
(m.c) (33/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4-5) 34
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(unsigned) k
( u;) p n
(        printf\(") S
(ent %d \(%d\): adr %u 0x%04x, sz [%u], mark %s rfct %d llev %d tlev %d\\n) str
(",) p n
(                e, i,) N
(                tab->tab[i].adr, tab->tab[i].adr,) N
(                tab->tab[i].sz,) N
(                tab->tab[i].mark & MARKM ?") S
(#) str
(":") p
(_) str
(",) p n
(                \(tab->tab[i].mark & RFCTM\) >> RFCTO,) N
(                \(tab->tab[i].mark & LLEVM\) >> LLEVO,) N
(                \(tab->tab[i].mark & TLEVM\) >> TLEVO \);) N
(        ) S
(for) K
( \(u=0; u < tab->tab[i].sz; u++\) {) p n
(            printf\(") S
( %02x%c) str
(",) p n
(                    \() S
(unsigned) k
(\)mem->base[ tab->tab[i].adr + u ],) p n
(                    isprint\(\() S
(unsigned) k
(\)mem->base[ tab->tab[i].adr + u ]\) ?) p n
(                        \() S
(unsigned) k
(\)mem->base[ tab->tab[i].adr + u ] :) p n
(                        ') S
( ) str
('\);) p n
(        }) N
(        \() S
(void) k
(\)puts\(""\);) p n
(    }) N
(    ) S
(if) K
( \(tab->nextent == TABSZ\) {) p n
(        mtabadr = tab->nexttab;) N
(        ) S
(goto) K
( next_table;) p n
(    }) N
(        ) S
(//dumpmtab\(mem, tab->nexttab\);) c n
(}) p n
() N
() N
(/* allocate and initialize a new table */) c n
(unsigned) k
( initmtab\(mfile *mem\){) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( adr;) p n
(    adr = mfalloc\(mem, ) S
(sizeof) K
(\(mtab\)\);) p n
(    tab = \() S
(void) k
( *\)\(mem->base + adr\);) p n
(    tab->nexttab = 0;) N
(    tab->nextent = 0;) N
(    ) S
(return) K
( adr;) p n
(}) N
() N
(/* allocate memory, returns table index) c n
(   possible growmem.) N
(   MUST recalculate all pointers derived from mem->base) N
(        after this function) N
( */) N
(unsigned) k
( mtalloc\(mfile *mem, ) p
(unsigned) k
( mtabadr, ) p
(unsigned) k
( sz\){) p n
(    ) S
(unsigned) k
( ent;) p n
(    ) S
(unsigned) k
( adr;) p n
(    mtab *tab = \() S
(void) k
( *\)\(mem->base + mtabadr\);) p n
(    ) S
(int) k
( ntab = 0;) p n
(    ) S
(while) K
( \(tab->nextent >= TABSZ\) {) p n
(        tab = \() S
(void) k
( *\)\(mem->base + tab->nexttab\);) p n
(        ++ntab;) N
(    }) N
() N
(    ent = tab->nextent;) N
(    ++tab->nextent;) N
() N
(    adr = mfalloc\(mem, sz\);) N
(    ent += ntab*TABSZ; ) S
(//recalc) c n
(    findtabent\(mem, &tab, &ent\); ) p
(//recalc) c n
(    tab->tab[ent].adr = adr;) p n
(    tab->tab[ent].sz = sz;) N
() N
(    ) S
(if) K
( \(tab->nextent == TABSZ\){) p n
(        ) S
(unsigned) k
( newtab = initmtab\(mem\);) p n
(        ent += ntab*TABSZ; ) S
(//recalc) c n
(        findtabent\(mem, &tab, &ent\); ) p
(//recalc) c n
(        tab->nexttab = newtab;) p n
(    }) N
(    ) S
(return) K
( ent + ntab*TABSZ;) p n
(}) N
(m.c) (Page 4/6) (Aug 30, 13 4:28) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* find the table and relative entity index for an absolute entity index */) c n
(void) k
( findtabent\(mfile *mem, ) p
(/*@out@*/) c
( mtab **atab, ) p
(/*@in@*/) c
( ) p
(unsigned) k
( *aent\) {) p n
(    *atab = \() S
(void) k
( *\)\(mem->base\); ) p
(// just use mtabadr=0) c n
(    ) p
(while) K
( \(*aent >= TABSZ\) {) p n
(        *aent -= TABSZ;) N
(        ) S
(if) K
( \(\(*atab\)->nexttab == 0\) {) p n
(            error\(unregistered, ") S
(ent doesn't exist) str
("\);) p n
(        }) N
(        *atab = \() S
(void) k
( *\)\(mem->base + \(*atab\)->nexttab\);) p n
(    }) N
(}) N
() N
(/* get the address from an entity */) c n
(unsigned) k
( adrent\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    mtab *tab;) S
(// = \(void *\)\(mem->base\); // just use mtabadr=0) c n
(    assert\(mem\);) p n
(    assert\(mem->base\);) N
(    findtabent\(mem,&tab,&ent\);) N
(    assert\(tab\);) N
(    ) S
(return) K
( tab->tab[ent].adr;) p n
(}) N
() N
(/* get the size of an entity */) c n
(unsigned) k
( szent\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    mtab *tab;) S
(// = \(void *\)\(mem->base\); // just use mtabadr=0) c n
(    assert\(mem\);) p n
(    findtabent\(mem,&tab,&ent\);) N
(    ) S
(return) K
( tab->tab[ent].sz;) p n
(}) N
() N
(/* fetch a value from a composite object */) c n
(void) k
( get\(mfile *mem,) p n
(        ) S
(unsigned) k
( ent, ) p
(unsigned) k
( offset, ) p
(unsigned) k
( sz,) p n
(        ) S
(/*@out@*/) c
( ) p
(void) k
( *dest\){) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( mtabadr = 0;) p n
(    tab = \() S
(void) k
( *\)\(mem->base + mtabadr\);) p n
(    ) S
(while) K
( \(ent >= TABSZ\) {) p n
(        mtabadr = tab->nexttab;) N
(        tab = \() S
(void) k
( *\)\(mem->base + mtabadr\);) p n
(        ent -= TABSZ;) N
(    }) N
() N
(    ) S
(if) K
( \(offset*sz ) p
(/*+ sz*/) c
( > tab->tab[ent].sz\)) p n
(        error\(rangecheck, ") S
(get: out of bounds) str
("\);) p n
() N
(    memcpy\(dest, mem->base + tab->tab[ent].adr + offset*sz, sz\);) N
(}) N
() N
(/* put a value into a composite object */) c n
(void) k
( put\(mfile *mem,) p n
(        ) S
(unsigned) k
( ent, ) p
(unsigned) k
( offset, ) p
(unsigned) k
( sz,) p n
(        ) S
(/*@in@*/) c
( ) p
(void) k
( *src\){) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( mtabadr = 0;) p n
(    tab = \() S
(void) k
( *\)\(mem->base + mtabadr\);) p n
(    ) S
(while) K
( \(ent >= TABSZ\){) p n
(        mtabadr = tab->nexttab;) N
(        tab = \() S
(void) k
( *\)\(mem->base + mtabadr\);) p n
(        ent -= TABSZ;) N
(    }) N
() N
(    ) S
(if) K
( \(offset*sz ) p
(/*+ sz*/) c
( > tab->tab[ent].sz\)) p n
(        error\(rangecheck, ") S
(put: out of bounds) str
("\);) p n
() N
(    memcpy\(mem->base + tab->tab[ent].adr + offset*sz, src, sz\);) N
(}) N
() N
(m.c) (Page 5/6) (Aug 30, 13 4:28) title
border
grestore
(Printed by U-Z1\\josh) rhead
(m.c) (34/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (6,1) 35
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifdef) K
( TESTMODULE) p n
() N
(mfile mem;) N
() N
(/* initialize everything */) c n
(void) k
( init\() p
(void) k
(\){) p n
(    pgsz = getpagesize\(\);) N
(    initmem\(&mem, ") S
(x.mem) str
("\);) p n
(    \() S
(void) k
(\)initmtab\(&mem\); ) p
(/* create mtab at address zero */) c n
(}) p n
() N
(void) k
( xit\() p
(void) k
(\){) p n
(    exitmem\(&mem\);) N
(}) N
() N
(int) k
( main\(\){) p n
(    init\(\);) N
(    ) S
(unsigned) k
( ent;) p n
(    ) S
(int) k
( seven = 7;) p n
(    ) S
(int) k
( ret;) p n
() N
(    printf\(") S
(\\n^test m.c\\n) str
("\);) p n
(    ) S
(//printf\("getmemfile: %d\\n", getmemfile\(\)\);) c n
() p n
(    ent = mtalloc\(&mem, 0, ) S
(sizeof) K
( seven\);) p n
(    put\(&mem, ent, 0, ) S
(sizeof) K
( seven, &seven\);) p n
(    get\(&mem, ent, 0, ) S
(sizeof) K
( seven, &ret\);) p n
(    printf\(") S
(put %d, got %d\\n) str
(", seven, ret\);) p n
() N
(    ) S
(unsigned) k
( ent2;) p n
(    ent2 = mtalloc\(&mem, 0, 8*) S
(sizeof) K
( seven\);) p n
(    put\(&mem, ent2, 6, ) S
(sizeof) K
( seven, &seven\);) p n
(    get\(&mem, ent2, 6, ) S
(sizeof) K
( seven, &ret\);) p n
(    printf\(") S
(put %d in slot 7, got %d\\n) str
(", seven, ret\);) p n
(    ) S
(//get\(&mem, ent2, 9, sizeof seven, &ret\);) c n
(    ) p
(//printf\("attempted to retrieve element 10 from an 8-element array, got %d\\n) c n
(", ret\);) N
() p n
(    ) S
(unsigned) k
( ent3;) p n
(    ) S
(char) k
( str[] = ") p
(beads in buddha's necklace) str
(";) p n
(    ) S
(char) k
( sret[) p
(sizeof) K
( str];) p n
(    ent3 = mtalloc\(&mem, 0, strlen\(str\)+1\);) N
(    put\(&mem, ent3, 0, ) S
(sizeof) K
( str, str\);) p n
(    get\(&mem, ent3, 0, ) S
(sizeof) K
( str, sret\);) p n
(    printf\(") S
(stored and retrieved %s\\n) str
(", sret\);) p n
() N
(    dumpmtab\(&mem, 0\);) N
(    xit\(\);) N
(    ) S
(return) K
( 0;) p n
(}) N
(#endif) K n
(m.c) (Page 6/6) (Aug 30, 13 4:28) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
() N
(#define) K
( CNT_STR\(s\) ) p
(sizeof) K
(\(s\)-1, s) p n
() N
(void) k
( dumpnames\(context *ctx\) {) p n
(    ) S
(unsigned) k
( stk;) p n
(    ) S
(unsigned) k
( cnt, i;) p n
(    ) S
(char) k
( *s;) p n
(    stk = adrent\(ctx->gl, NAMES\);) N
(    cnt = count\(ctx->gl, stk\);) N
(    printf\(") S
(global names:\\n) str
("\);) p n
(    ) S
(for) K
( \(i=0; i < cnt; i++\){) p n
(        s = charstr\(ctx, bot\(ctx->gl, stk, i\)\);) N
(        printf\(") S
(%d: %s\\n) str
(", i, s\);) p n
(    }) N
(    stk = adrent\(ctx->lo, NAMES\);) N
(    cnt = count\(ctx->lo, stk\);) N
(    printf\(") S
(local names:\\n) str
("\);) p n
(    ) S
(for) K
( \(i=0; i < cnt; i++\) {) p n
(        s = charstr\(ctx, bot\(ctx->lo, stk, i\)\);) N
(        printf\(") S
(%d: %s\\n) str
(", i, s\);) p n
(    }) N
(}) N
() N
(void) k
( initnames\(context *ctx\) {) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( ent;) p n
(    ) S
(unsigned) k
( t;) p n
(    ) S
(unsigned) k
( mode;) p n
() N
(    mode = ctx->vmmode;) N
(    ctx->vmmode = GLOBAL;) N
(    ent = mtalloc\(ctx->gl, 0, 0\); ) S
(//gl:NAMES) c n
(    assert\(ent == NAMES\);) p n
(    ent = mtalloc\(ctx->gl, 0, 0\); ) S
(//gl:NAMET) c n
(    assert\(ent == NAMET\);) p n
() N
(    t = initstack\(ctx->gl\);) N
(    tab = \() S
(void) k
( *\)ctx->gl->base; ) p
(//recalc pointer) c n
(    tab->tab[NAMES].adr = t;) p n
(    tab->tab[NAMET].adr = 0;) N
(    push\(ctx->gl, adrent\(ctx->gl, NAMES\), consbst\(ctx, CNT_STR\(") S
(_not_a_name_) str
("\)\)\);) p n
(    assert \(top\(ctx->gl, adrent\(ctx->gl, NAMES\), 0\).comp_.ent == BOGUSNAME\);) N
() N
(    ctx->vmmode = LOCAL;) N
(    ent = mtalloc\(ctx->lo, 0, 0\); ) S
(//lo:NAMES) c n
(    assert\(ent == NAMES\);) p n
(    ent = mtalloc\(ctx->lo, 0, 0\); ) S
(//lo:NAMET) c n
(    assert\(ent == NAMET\);) p n
() N
(    t = initstack\(ctx->lo\);) N
(    tab = \() S
(void) k
( *\)ctx->lo->base; ) p
(//recalc pointer) c n
(    tab->tab[NAMES].adr = t;) p n
(    tab->tab[NAMET].adr = 0;) N
(    push\(ctx->lo, adrent\(ctx->lo, NAMES\), consbst\(ctx, CNT_STR\(") S
(_not_a_name_) str
("\)\)\);) p n
(    assert \(top\(ctx->lo, adrent\(ctx->lo, NAMES\), 0\).comp_.ent == BOGUSNAME\);) N
() N
(nm.c) (Page 1/4) (Aug 17, 13 5:11) title
border
grestore
(Printed by U-Z1\\josh) rhead
(m.c, nm.c) (35/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 36
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ctx->vmmode = mode;) p n
(}) N
() N
(unsigned) k
( tstsearch\(mfile *mem, ) p
(unsigned) k
( tadr, ) p
(char) k
( *s\) {) p n
(    ) S
(while) K
( \(tadr\) {) p n
(        tst *p = \() S
(void) k
( *\)\(mem->base + tadr\);) p n
(        ) S
(if) K
( \(\() p
(unsigned) k
(\)*s < p->val\) {) p n
(            tadr = p->lo;) N
(        } ) S
(else) K
( ) p
(if) K
( \(\() p
(unsigned) k
(\)*s == p->val\) {) p n
(            ) S
(if) K
( \(*s++ == 0\) ) p
(return) K
( p->eq; ) p
(/* payload when val == '\\0' */) c n
(            tadr = p->eq;) p n
(        } ) S
(else) K
( {) p n
(            tadr = p->hi;) N
(        }) N
(    }) N
(    ) S
(return) K
( 0;) p n
(}) N
() N
(unsigned) k
( tstinsert\(mfile *mem, ) p
(unsigned) k
( tadr, ) p
(char) k
( *s\) {) p n
(    tst *p;) N
(    ) S
(unsigned) k
( t; ) p
(//temporary) c n
(    ) p
(if) K
( \(!tadr\) {) p n
(        tadr = mfalloc\(mem, ) S
(sizeof) K
(\(tst\)\);) p n
(        p = \() S
(void) k
( *\)\(mem->base + tadr\);) p n
(        p->val = *s;) N
(        p->lo = p->eq = p->hi = 0;) N
(    }) N
(    p = \() S
(void) k
( *\)\(mem->base + tadr\);) p n
(    ) S
(if) K
( \(\() p
(unsigned) k
(\)*s < p->val\) {) p n
(        t = tstinsert\(mem, p->lo, s\);) N
(        p = \() S
(void) k
( *\)\(mem->base + tadr\); ) p
(//recalc pointer) c n
(        p->lo = t;) p n
(    } ) S
(else) K
( ) p
(if) K
( \(\() p
(unsigned) k
(\)*s == p->val\) {) p n
(        ) S
(if) K
( \(*s\) {) p n
(            t = tstinsert\(mem, p->eq, ++s\);) N
(            p = \() S
(void) k
( *\)\(mem->base + tadr\); ) p
(//recalc pointer) c n
(            p->eq = t;) p n
(        }) S
(else) K
( {) p n
(            p->eq = count\(mem, adrent\(mem, NAMES\)\); ) S
(/* payload when val == '\\0' ) c n
(*/) N
(        }) p n
(    } ) S
(else) K
( {) p n
(        t = tstinsert\(mem, p->hi, s\);) N
(        p = \() S
(void) k
( *\)\(mem->base + tadr\); ) p
(//recalc pointer) c n
(        p->hi = t;) p n
(    }) N
(    ) S
(return) K
( tadr;) p n
(}) N
() N
(unsigned) k
( addname\(context *ctx, ) p
(char) k
( *s\) {) p n
(    mfile *mem = ctx->vmmode==GLOBAL?ctx->gl:ctx->lo;) N
(    ) S
(unsigned) k
( names = adrent\(mem, NAMES\);) p n
(    ) S
(unsigned) k
( u = count\(mem, names\);) p n
(    ) S
(//dumpmfile\(ctx->gl\);) c n
(    ) p
(//dumpmtab\(ctx->gl, 0\);) c n
(    ) p
(//unsigned vmmode = ctx->vmmode;) c n
(    ) p
(//ctx->vmmode = GLOBAL;) c n
(    push\(mem, names, consbst\(ctx, strlen\(s\), s\)\);) p n
(    ) S
(//ctx->vmmode = vmmode;) c n
(    ) p
(return) K
( u;) p n
(}) N
() N
(object consname\(context *ctx, ) S
(char) k
( *s\) {) p n
(    ) S
(unsigned) k
( u;) p n
(    ) S
(unsigned) k
( t;) p n
(    object o;) N
(    u = tstsearch\(ctx->lo, adrent\(ctx->lo, NAMET\), s\);) N
(    ) S
(if) K
( \(!u\) {) p n
(        u = tstsearch\(ctx->gl, adrent\(ctx->gl, NAMET\), s\);) N
(nm.c) (Page 2/4) (Aug 17, 13 5:11) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(if) K
( \(!u\) {) p n
(            mfile *mem = ctx->vmmode==GLOBAL?ctx->gl:ctx->lo;) N
(            mtab *tab = \() S
(void) k
( *\)mem->base;) p n
(            t = tstinsert\(mem, tab->tab[NAMET].adr, s\);) N
(            tab = \() S
(void) k
( *\)mem->base; ) p
(//recalc pointer) c n
(            tab->tab[NAMET].adr = t;) p n
(            u = addname\(ctx, s\); ) S
(// obeys vmmode) c n
(            o.mark_.tag = nametype | \(ctx->vmmode==GLOBAL?FBANK:0\);) p n
(            o.mark_.pad0 = 0;) N
(            o.mark_.padw = u;) N
(        } ) S
(else) K
( {) p n
(            o.mark_.tag = nametype | FBANK; ) S
(// global) c n
(            o.mark_.pad0 = 0;) p n
(            o.mark_.padw = u;) N
(        }) N
(    } ) S
(else) K
( {) p n
(        o.mark_.tag = nametype; ) S
(// local) c n
(        o.mark_.pad0 = 0;) p n
(        o.mark_.padw = u;) N
(        }) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(object strname\(context *ctx, object n\) {) N
(    mfile *mem = bank\(ctx, n\);) N
(    ) S
(unsigned) k
( names = adrent\(mem, NAMES\);) p n
(    object str = bot\(mem, names, n.mark_.padw\);) N
(    ) S
(//str.tag |= FBANK;) c n
(    ) p
(return) K
( str;) p n
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <unistd.h>) p n
() N
(/*) c n
(void init\(context *ctx\) {) N
(    pgsz = getpagesize\(\);) N
(    ctx->gl = malloc\(sizeof\(mfile\)\);) N
(    initmem\(ctx->gl, "x.mem"\);) N
(    \(void\)initmtab\(ctx->gl\); // create mtab at address zero) N
(    //\(void\)mtalloc\(ctx->gl, 0, 0\); //FREE) N
(    initfree\(ctx->gl\);) N
(    \(void\)mtalloc\(ctx->gl, 0, 0\); //VS) N
(    initctxlist\(ctx->gl\);) N
() N
(    initnames\(ctx\);) N
(}) N
(context ctx;) N
(*/) N
() p n
(context *ctx;) N
() N
(void) k
( init\() p
(void) k
(\) {) p n
(    itpdata = malloc\() S
(sizeof) K
(*itpdata\);) p n
(    memset\(itpdata, 0, ) S
(sizeof) K
(*itpdata\);) p n
(    inititp\(itpdata\);) N
(    ctx = &itpdata->ctab[0];) N
(    ctx->vmmode = GLOBAL;) N
(}) N
() N
(int) k
( main\() p
(void) k
(\) {) p n
(    printf\(") S
(\\n^test nm\\n) str
("\);) p n
(    ) S
(//init\(&ctx\);) c n
(    init\(\);) p n
(    ctx->vmmode = LOCAL;) N
() N
(    printf\(") S
(pop ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(pop) str
("\)\);) p n
(nm.c) (Page 3/4) (Aug 17, 13 5:11) title
border
grestore
(Printed by U-Z1\\josh) rhead
(nm.c) (36/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4,1) 37
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    printf\(") p
(NAMES at %u\\n) str
(", adrent\(ctx->gl, NAMES\)\);) p n
(    ) S
(//dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\); puts\(""\);) c n
() p n
(    printf\(") S
(apple ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(apple) str
("\)\);) p n
(    dumpobject\(consname\(ctx, ") S
(apple) str
("\)\);) p n
(    ) S
(//printf\("NAMES at %u\\n", adrent\(ctx->gl, NAMES\)\);) c n
(    ) p
(//dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\); puts\(""\);) c n
() p n
(    printf\(") S
(banana ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(banana) str
("\)\);) p n
(    dumpobject\(consname\(ctx, ") S
(banana) str
("\)\);) p n
(    ) S
(//printf\("NAMES at %u\\n", adrent\(ctx->gl, NAMES\)\);) c n
(    ) p
(//dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\); puts\(""\);) c n
() p n
(    printf\(") S
(currant ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(currant) str
("\)\);) p n
(    dumpobject\(consname\(ctx, ") S
(currant) str
("\)\);) p n
(    ) S
(//printf\("NAMES at %u\\n", adrent\(ctx->gl, NAMES\)\);) c n
(    ) p
(//dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\); puts\(""\);) c n
() p n
(    printf\(") S
(apple ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(apple) str
("\)\);) p n
(    printf\(") S
(banana ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(banana) str
("\)\);) p n
(    printf\(") S
(currant ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(currant) str
("\)\);) p n
(    printf\(") S
(date ) str
("\);) p n
(    ) S
(//printf\("NAMES at %u\\n", adrent\(ctx->gl, NAMES\)\);) c n
(    dumpobject\(consname\(ctx, ") p
(date) str
("\)\);) p n
(    ) S
(//printf\("NAMES at %u\\n", adrent\(ctx->gl, NAMES\)\);) c n
(    dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\); puts\(""\);) p n
(    ) S
(//printf\("NAMES at %u\\n", adrent\(ctx->gl, NAMES\)\);) c n
(    printf\(") p
(elderberry ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(elderberry) str
("\)\);) p n
() N
(    printf\(") S
(pop ) str
("\);) p n
(    dumpobject\(consname\(ctx, ") S
(pop) str
("\)\);) p n
() N
(    ) S
(//dumpmfile\(ctx->gl\);) c n
(    ) p
(//dumpmtab\(ctx->gl, 0\);) c n
(    puts\(""\);) p n
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
(nm.c) (Page 4/4) (Aug 17, 13 5:11) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(//#define TESTMODULE) c n
() p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( ") p
(ob.h) str
(") p n
() N
(char) k
( *types[] = { TYPES\(AS_TYPE_STR\) ") p
(invalid) str
("};) p n
() N
(int) k
( isx\(object o\) {) p n
(    ) S
(return) K
( !\(o.tag &FLIT\);) p n
(}) N
() N
(int) k
( islit\(object o\) {) p n
(    ) S
(return) K
( o.tag & FLIT;) p n
(}) N
() N
(int) k
( faccess\(object o\) {) p n
(    ) S
(return) K
( \(o.tag & FACCESS\) >> FACCESSO;) p n
(}) N
() N
(object setfaccess\(object o, ) S
(int) k
( access\) {) p n
(    o.tag &= ~FACCESS;) N
(    o.tag |= \(access << FACCESSO\);) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(int) k
( isreadable\(object o\) {) p n
(    ) S
(if) K
( \(type\(o\) == filetype\) {) p n
(        ) S
(return) K
( faccess\(o\) == readonly;) p n
(    } ) S
(else) K
( {) p n
(        ) S
(return) K
( faccess\(o\) >= readonly;) p n
(    }) N
(}) N
() N
(int) k
( iswriteable\(object o\) {) p n
(    ) S
(return) K
( faccess\(o\) == unlimited;) p n
(}) N
() N
(int) k
( type\(object o\) {) p n
(    ) S
(return) K
( o.tag & TYPEMASK;) p n
(}) N
() N
(object cvx\(object o\){) N
(    o.tag &= ~FLIT;) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(object cvlit\(object o\) {) N
(    o.tag |= FLIT;) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(// null, mark) c n
(SINGLETONS\(DEFINE_SINGLETON\)) p n
() N
(object consbool\(bool b\) {) N
(    object o;) N
(    o.int_.tag = booleantype | \(unlimited << FACCESSO\);) N
(    o.int_.pad = 0;) N
(    o.int_.val = b;) N
(    ) S
(return) K
( cvlit\(o\);) p n
(}) N
() N
(object consint\(integer i\){) N
(    object o;) N
(    o.int_.tag = integertype | \(unlimited << FACCESSO\);) N
(    o.int_.pad = 0;) N
(    o.int_.val = i;) N
(    ) S
(return) K
( cvlit\(o\);) p n
(ob.c) (Page 1/2) (Aug 23, 13 1:00) title
border
grestore
(Printed by U-Z1\\josh) rhead
(nm.c, ob.c) (37/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2,1) 38
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(object consreal\(real r\){) N
(    object o;) N
(    o.real_.tag = realtype | \(unlimited << FACCESSO\);) N
(    o.real_.pad = 0;) N
(    o.real_.val = r;) N
(    ) S
(return) K
( cvlit\(o\);) p n
(}) N
() N
(void) k
( dumpcompobject\(object o\){) p n
(    printf\(") S
( %c %u %u %u %u>) str
(",) p n
(            o.comp_.tag&FBANK? ') S
(G) str
(': ') p
(L) str
(',) p n
(            \() S
(unsigned) k
( ) p
(int) k
(\)o.comp_.tag,) p n
(            \() S
(unsigned) k
( ) p
(int) k
(\)o.comp_.sz,) p n
(            \() S
(unsigned) k
( ) p
(int) k
(\)o.comp_.ent,) p n
(            \() S
(unsigned) k
( ) p
(int) k
(\)o.comp_.off\);) p n
(}) N
() N
(void) k
( dumpobject\(object o\){) p n
(    ) S
(switch) K
(\(type\(o\)\) {) p n
(        ) S
(default) K
(:) p n
(        ) S
(case) K
( invalidtype: printf\(") p
(<invalid object %04x %04x %04x %04x >) str
(",) p n
(                                  o.comp_.tag, o.comp_.sz, o.comp_.ent, o.comp_.) N
(off\); ) S
(break) K
(;) p n
() N
(        ) S
(case) K
( nulltype: printf\(") p
(<null>) str
("\); ) p
(break) K
(;) p n
(        ) S
(case) K
( marktype: printf\(") p
(<mark>) str
("\); ) p
(break) K
(;) p n
(        ) S
(case) K
( booleantype: printf\(") p
(<boolean %s>) str
(", o.int_.val?") p
(true) str
(":") p
(false) str
("\); ) p
(break) K
(;) p n
(        ) S
(case) K
( integertype: printf\(") p
(<integer %d>) str
(", \() p
(int) k
(\)o.int_.val\); ) p
(break) K
(;) p n
(        ) S
(case) K
( realtype: printf\(") p
(<real %f>) str
(", \() p
(float) k
(\)o.real_.val\); ) p
(break) K
(;) p n
() N
(        ) S
(case) K
( stringtype: printf\(") p
(<string) str
("\); dumpcompobject\(o\); ) p
(break) K
(;) p n
(        ) S
(case) K
( arraytype: printf\(") p
(<array) str
("\); dumpcompobject\(o\); ) p
(break) K
(;) p n
(        ) S
(case) K
( dicttype: printf\(") p
(<dict) str
("\); dumpcompobject\(o\); ) p
(break) K
(;) p n
() N
(        ) S
(case) K
( nametype: printf\(") p
(<name %c %u %u %u>) str
(",) p n
(                               o.mark_.tag&FBANK? ') S
(G) str
(':') p
(L) str
(',) p n
(                               \() S
(int) k
(\)o.mark_.tag,) p n
(                               \() S
(int) k
(\)o.mark_.pad0,) p n
(                               \() S
(int) k
(\)o.mark_.padw\); ) p
(break) K
(;) p n
(        ) S
(case) K
( operatortype: printf\(") p
(<operator %u>) str
(", \() p
(int) k
(\)o.mark_.padw\); ) p
(break) K
(;) p n
(        ) S
(case) K
( filetype: printf\(") p
(<file>) str
("\); ) p
(break) K
(;) p n
(        ) S
(case) K
( savetype: printf\(") p
(<save>) str
("\); ) p
(break) K
(;) p n
(        ) S
(case) K
( contexttype: printf\(") p
(<context>) str
("\); ) p
(break) K
(;) p n
(    }) N
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
(int) k
( main\(\) {) p n
(    printf\(") S
(\\n^test ob module\\n) str
("\);) p n
(    object i = consint\(5\);) N
(    object j = consint\(3579\);) N
(    object q = consreal\(12.0\);) N
(    object r = consreal\(.0370\);) N
(    object b = consbool\(true\);) N
(    object c = consbool\(false\);) N
(    dumpobject\(null\);) N
(    dumpobject\(mark\);) N
(    dumpobject\(i\);) N
(    dumpobject\(j\);) N
(    dumpobject\(q\);) N
(    dumpobject\(r\);) N
(    dumpobject\(b\);) N
(    dumpobject\(c\);) N
(    puts\(""\);) N
(    ) S
(return) K
( 0;) p n
(} ) N
(#endif) K n
(ob.c) (Page 2/2) (Aug 23, 13 1:00) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <stdarg.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(object promote\(object o\) { ) S
(return) K
( consreal\(o.int_.val\); }) p n
() N
(/*) c n
(typedef struct signat {) N
(   void \(*fp\)\(\);) N
(   int in;) N
(   unsigned t;) N
(   int out;) N
(} signat;) N
() N
(typedef struct oper {) N
(    unsigned name;) N
(    int n; // number of sigs) N
(    unsigned sigadr;) N
(} oper;) N
() N
(enum typepat \( anytype = stringtype + 1,) N
(    floattype, numbertype, proctype };) N
() N
(#define MAXOPS 20) N
(*/) N
() p n
(int) k
( noop = 0;) p n
() N
(void) k
( initoptab \(context *ctx\) {) p n
(    ) S
(unsigned) k
( ent = mtalloc\(ctx->gl, 0, MAXOPS * ) p
(sizeof) K
(\(oper\)\);) p n
(    mtab *tab = \() S
(void) k
( *\)\(ctx->gl\);) p n
(    assert\(ent == OPTAB\);) N
(    findtabent\(ctx->gl, &tab, &ent\);) N
(    tab->tab[ent].sz = 0; ) S
(// so gc will ignore it) c n
(    ) p
(//printf\("ent: %d\\nOPTAB: %d\\n", ent, \(int\)OPTAB\);) c n
(}) p n
() N
(void) k
( dumpoper\(context *ctx, ) p
(int) k
( opcode\) {) p n
(    oper *optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    oper op = optab[opcode];) N
(    mark_ nm = { nametype | FBANK, 0, op.name };) N
(    object str = strname\(ctx, \(object\)nm\);) N
(    ) S
(char) k
( *s = charstr\(ctx, str\);) p n
(    signat *sig = \() S
(void) k
( *\)\(ctx->gl->base + op.sigadr\);) p n
(    printf\(") S
(<operator %d %*s %p>) str
(", opcode, str.comp_.sz, s, \() p
(void) k
( *\)sig[0].fp \);) p n
(}) N
() N
(object consoper\(context *ctx, ) S
(char) k
( *name, ) p
(/*@null@*/) c
( ) p
(void) k
( \(*fp\)\(\), ) p
(int) k
( out,) p n
(        ) S
(int) k
( in, ...\) {) p n
(    object nm;) N
(    object o;) N
(    ) S
(int) k
( opcode;) p n
(    ) S
(int) k
( i;) p n
(    ) S
(unsigned) k
( si;) p n
(    ) S
(unsigned) k
( t;) p n
(    ) S
(unsigned) k
( vmmode;) p n
(op.c) (Page 1/5) (Aug 17, 13 5:03) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ob.c, op.c) (38/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 39
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    signat *sp;) p n
(    oper *optab;) N
(    oper op;) N
() N
(    ) S
(//fprintf\(stderr, "name: %s\\n", name\);) c n
(    assert\(ctx->gl->base\);) p n
() N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    ) S
(if) K
( \(!\(in < STACKSEGSZ\)\) {) p n
(        printf\(") S
(!\(in < STACKSEGSZ\) in consoper\(%s, %d. %d\)\\n) str
(", name, out, in\);) p n
(        exit\(EXIT_FAILURE\);) N
(    }) N
(    ) S
(//assert\(in < STACKSEGSZ\); // or else opexec can't call it using HOLD) c n
() p n
(    vmmode=ctx->vmmode;) N
(    ctx->vmmode = GLOBAL;) N
(    nm = consname\(ctx, name\);) N
(    ctx->vmmode = vmmode;) N
(    ) S
(for) K
( \(opcode = 0; optab[opcode].name != nm.mark_.padw; opcode++\) {) p n
(        ) S
(if) K
( \(opcode == noop\) ) p
(break) K
(;) p n
(    }) N
() N
(    ) S
(/* install a new signature \(prototype\) */) c n
(    ) p
(if) K
( \(fp\) {) p n
(        ) S
(if) K
( \(opcode == noop\) { ) p
(/* a new operator */) c n
(            ) p
(unsigned) k
( adr;) p n
(            ) S
(if) K
( \(noop == MAXOPS-1\) error\(unregistered, ") p
(optab too small!\\n) str
("\);) p n
(            adr = mfalloc\(ctx->gl, ) S
(sizeof) K
(\(signat\)\);) p n
(            optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\); ) p
(// recalc) c n
(            op.name = nm.mark_.padw;) p n
(            op.n = 1;) N
(            op.sigadr = adr;) N
(            optab[opcode] = op;) N
(            ++noop;) N
(            si = 0;) N
(        } ) S
(else) K
( { ) p
(/* increase sig table by 1 */) c n
(            t = mfrealloc\(ctx->gl,) p n
(                    optab[opcode].sigadr,) N
(                    optab[opcode].n * ) S
(sizeof) K
(\(signat\),) p n
(                    \(optab[opcode].n + 1\) * ) S
(sizeof) K
(\(signat\)\);) p n
(            optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\); ) p
(// recalc) c n
(            optab[opcode].sigadr = t;) p n
() N
(            si = optab[opcode].n++; ) S
(/* index of last sig */) c n
(        }) p n
() N
(        sp = \() S
(void) k
( *\)\(ctx->gl->base + optab[opcode].sigadr\);) p n
(        sp[si].t = mfalloc\(ctx->gl, in\);) N
(        optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\); ) p
(// recalc) c n
(        sp = \() p
(void) k
( *\)\(ctx->gl->base + optab[opcode].sigadr\); ) p
(// recalc) c n
(        {) p n
(            va_list args;) N
(            byte *b = \() S
(void) k
( *\)\(ctx->gl->base + sp[si].t\);) p n
(            va_start\(args, in\);) N
(            ) S
(for) K
( \(i = in-1; i >= 0; i--\) {) p n
(                b[i] = va_arg\(args, ) S
(int) k
(\);) p n
(            }) N
(            va_end\(args\);) N
(            sp[si].in = in;) N
(            sp[si].out = out;) N
(            sp[si].fp = fp;) N
(        }) N
(    } ) S
(else) K
( ) p
(if) K
( \(opcode == noop\) {) p n
(        error\(unregistered, ") S
(operator not found\\n) str
("\);) p n
(    }) N
() N
(    o.tag = operatortype;) N
(    o.mark_.padw = opcode;) N
(op.c) (Page 2/5) (Aug 17, 13 5:03) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(return) K
( o;) p n
(}) N
() N
(qword digest\(context *ctx, mfile *mem, ) S
(unsigned) k
( stacadr\) {) p n
(    qword a = 0;) N
(    ) S
(int) k
( i;) p n
(    \() S
(void) k
(\)ctx;) p n
(    ) S
(for) K
( \(i=0; i < 8; i++\) {) p n
(        byte t = type\(top\(mem, stacadr, i\)\);) N
(        ) S
(if) K
( \(t == invalidtype\) ) p
(break) K
(;) p n
(        a |= \(qword\)t << \(\() S
(unsigned) k
(\)i * 8\);) p n
(    }) N
(    ) S
(return) K
( a;) p n
(}) N
() N
(/* copy top n elements to holding stack & pop them */) c n
(void) k
( holdn \(context *ctx, mfile *mem, ) p
(unsigned) k
( stacadr, ) p
(int) k
( n\) {) p n
(    stack *hold;) N
(    ) S
(int) k
( j;) p n
(    assert\(n < TABSZ\);) N
(    hold = \() S
(void) k
( *\)\(ctx->lo->base + ctx->hold ) p
(/*adrent\(ctx->lo, HOLD\)*/) c
(\);) p n
(    hold->top = 0; ) S
(/* clear HOLD */) c n
(    ) p
(for) K
( \(j=n; j--;\) {) p n
(    ) S
(//j = n;) c n
(    ) p
(//while \(j\) {) c n
(        ) p
(//j--;) c n
(        push\(ctx->lo, ctx->hold, top\(mem, stacadr, j\)\);) p n
(    }) N
(    ) S
(for) K
( \(j=n; j--;\) {) p n
(    ) S
(//j = n;) c n
(    ) p
(//while \(j\) {) c n
(        \() p
(void) k
(\)pop\(mem, stacadr\);) p n
(        ) S
(//j--;) c n
(    }) p n
(}) N
() N
(void) k
( opexec\(context *ctx, ) p
(unsigned) k
( opcode\) {) p n
(    oper *optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    oper op = optab[opcode];) N
(    signat *sp = \() S
(void) k
( *\)\(ctx->gl->base + op.sigadr\);) p n
(    ) S
(int) k
( i,j;) p n
(    bool pass;) N
(    ) S
(int) k
( err = unregistered;) p n
(    ) S
(char) k
( *errmsg = ") p
(unspecified error) str
(";) p n
(    stack *hold;) N
(    ) S
(int) k
( ct;) p n
() N
(    ct = count\(ctx->lo, ctx->os\);) N
(    ) S
(if) K
( \(op.n == 0\) error\(unregistered, ") p
(opexec) str
("\);) p n
(    ) S
(for) K
( \(i=0; i < op.n; i++\) { ) p
(/* try each signature */) c n
(        byte *t;) p n
(        ) S
(if) K
( \(ct < sp[i].in\) {) p n
(            pass = false;) N
(            err = stackunderflow;) N
(            errmsg = ") S
(opexec) str
(";) p n
(            ) S
(continue) K
(;) p n
(        }) N
(        pass = true;) N
(        t = \() S
(void) k
( *\)\(ctx->gl->base + sp[i].t\);) p n
(        ) S
(for) K
( \(j=0; j < sp[i].in; j++\) {) p n
(            object el = top\(ctx->lo, ctx->os, j\);) N
(            ) S
(if) K
( \(t[j] == anytype\) ) p
(continue) K
(;) p n
(            ) S
(if) K
( \(t[j] == type\(el\)\) ) p
(continue) K
(;) p n
(            ) S
(if) K
( \(t[j] == numbertype) p n
(                    && \(type\(el\) == integertype) N
(                        || type\(el\) == realtype\) \) ) S
(continue) K
(;) p n
(            ) S
(if) K
( \(t[j] == floattype\) {) p n
(                ) S
(if) K
( \(type\(el\) == integertype\) {) p n
(                    pot\(ctx->lo, ctx->os, j, el = promote\(el\)\);) N
(op.c) (Page 3/5) (Aug 17, 13 5:03) title
border
grestore
(Printed by U-Z1\\josh) rhead
(op.c) (39/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4-5) 40
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                    ) p
(continue) K
(;) p n
(                }) N
(                ) S
(if) K
( \(type\(el\) == realtype\) ) p
(continue) K
(;) p n
(            }) N
(            ) S
(if) K
( \(t[j] == proctype) p n
(                    && type\(el\) == arraytype) N
(                    && isx\(el\)\) ) S
(continue) K
(;) p n
(            pass = false;) N
(            err = typecheck;) N
(            errmsg = ") S
(opexec) str
(";) p n
(            ) S
(break) K
(;) p n
(        }) N
(        ) S
(if) K
( \(pass\) ) p
(goto) K
( call;) p n
(    }) N
(    error\(err, errmsg\);) N
(    ) S
(return) K
(;) p n
() N
(call:) N
(    holdn\(ctx, ctx->lo, ctx->os, sp[i].in\);) N
(    hold = \() S
(void) k
( *\)\(ctx->lo->base + ctx->hold ) p
(/*adrent\(ctx->lo, HOLD\)*/) c
( \);) p n
() N
(    ) S
(switch) K
(\(sp[i].in\) {) p n
(        ) S
(case) K
( 0: sp[i].fp\(ctx\); ) p
(break) K
(;) p n
(        ) S
(case) K
( 1: sp[i].fp\(ctx, hold->data[0]\); ) p
(break) K
(;) p n
(        ) S
(case) K
( 2: sp[i].fp\(ctx, hold->data[0], hold->data[1]\); ) p
(break) K
(;) p n
(        ) S
(case) K
( 3: sp[i].fp\(ctx, hold->data[0], hold->data[1], hold->data[2]\); ) p
(brea) K n
(k) S
(;) p n
(        ) S
(case) K
( 4: sp[i].fp\(ctx, hold->data[0], hold->data[1], hold->data[2],) p n
(                        hold->data[3]\); ) S
(break) K
(;) p n
(        ) S
(case) K
( 5: sp[i].fp\(ctx, hold->data[0], hold->data[1], hold->data[2],) p n
(                        hold->data[3], hold->data[4]\); ) S
(break) K
(;) p n
(        ) S
(case) K
( 6: sp[i].fp\(ctx, hold->data[0], hold->data[1], hold->data[2],) p n
(                        hold->data[3], hold->data[4], hold->data[5]\); ) S
(break) K
(;) p n
(        ) S
(default) K
(: error\(unregistered, ") p
(opexec) str
("\);) p n
(    }) N
(}) N
() N
(#include) K
( ") p
(ops.h) str
(") p n
(#include) K
( ") p
(opst.h) str
(") p n
(#include) K
( ") p
(opar.h) str
(") p n
(#include) K
( ") p
(opdi.h) str
(") p n
(#include) K
( ") p
(opb.h) str
(") p n
(#include) K
( ") p
(opc.h) str
(") p n
(#include) K
( ") p
(opt.h) str
(") p n
(#include) K
( ") p
(optok.h) str
(") p n
(#include) K
( ") p
(opm.h) str
(") p n
(#include) K
( ") p
(opf.h) str
(") p n
(#include) K
( ") p
(opv.h) str
(") p n
(#include) K
( ") p
(opx.h) str
(") p n
(#include) K
( ") p
(oppa.h) str
(") p n
() N
(void) k
( breakhere\(context *ctx\) {) p n
(    \() S
(void) k
(\)ctx;) p n
(    ) S
(return) K
(;) p n
(}) N
() N
(void) k
( initop\(context *ctx\) {) p n
(    object op;) N
(    object n;) N
(    object sd;) N
(    mtab *tab;) N
(    ) S
(unsigned) k
( ent;) p n
(    oper *optab;) N
() N
(    sd = consbdc\(ctx, SDSIZE\);) N
(    bdcput\(ctx, sd, consname\(ctx, ") S
(systemdict) str
("\), sd\);) p n
(    push\(ctx->lo, ctx->ds, sd\);) N
(    tab = ) S
(NULL) K
(;) p n
(    ent = sd.comp_.ent;) N
(op.c) (Page 4/5) (Aug 17, 13 5:03) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    findtabent\(ctx->gl, &tab, &ent\);) p n
(    tab->tab[ent].sz = 0; ) S
(// make systemdict immune to collection) c n
() p n
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(#ifdef) K
( DEBUGOP) p n
(    dumpdic\(ctx->gl, sd\); fflush\() S
(NULL) K
(\);) p n
(    puts\(""\);) N
(#endif) K n
() p n
(    initops\(ctx, sd\);) N
() N
(//#ifdef DEBUGOP) c n
(    ) p
(//printf\("\\nops:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(//#endif) N
() p n
(    op = consoper\(ctx, ") S
(breakhere) str
(", breakhere, 0, 0\); INSTALL;) p n
() N
(    initopst\(ctx, sd\);) N
(    ) S
(//printf\("\\nopst:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopar\(ctx, sd\);) N
(    ) S
(//printf\("\\nopar:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopdi\(ctx, sd\);) N
(    ) S
(//printf\("\\nopdi:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopb\(ctx, sd\);) N
(    ) S
(//printf\("\\nopb:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopc\(ctx, sd\);) N
(    ) S
(//printf\("\\nopc:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopt\(ctx, sd\);) N
(    ) S
(//printf\("\\nopt:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initoptok\(ctx, sd\);) N
(    ) S
(//printf\("\\noptok:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopm\(ctx, sd\);) N
(    ) S
(//printf\("\\nopm:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopf\(ctx, sd\);) N
(    ) S
(//printf\("\\nopf:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopv\(ctx, sd\);) N
(    ) S
(//printf\("\\nopv:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initopx\(ctx, sd\);) N
(    ) S
(//printf\("\\nopx:\\n"\); dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
() p n
(    initoppa\(ctx, sd\);) N
() N
(    ) S
(//push\(ctx->lo, ctx->ds, sd\); // push systemdict on dictstack) c n
() p n
(#ifdef) K
( DEBUGOP) p n
(    printf\(") S
(final sd:\\n) str
("\);) p n
(    dumpstack\(ctx->lo, ctx->ds\);) N
(    dumpdic\(ctx->gl, sd\); fflush\() S
(NULL) K
(\);) p n
(#endif) K n
(}) p n
() N
() N
() N
(op.c) (Page 5/5) (Aug 17, 13 5:03) title
border
grestore
(Printed by U-Z1\\josh) rhead
(op.c) (40/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 41
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(ops.h) str
(") p n
() N
(/* helper function */) c n
(void) k
( a_copy\(context *ctx, object S, object D\) {) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(for) K
( \(i = 0; i < S.comp_.sz; i++\)) p n
(        barput\(ctx, D, i, barget\(ctx, S, i\)\);) N
(}) N
() N
(/* int  array  array) c n
(   create array of length int */) N
(void) k
( Iarray\(context *ctx, object I\) {) p n
(    push\(ctx->lo, ctx->os, cvlit\(consbar\(ctx, I.int_.val\)\)\);) N
(}) N
() N
(/* -  [  mark) c n
(   start array construction */) N
(/* [ is defined in systemdict as a marktype object */) N
() p n
(/* mark obj0..objN-1  ]  array) c n
(   end array construction */) N
(void) k
( arrtomark\(context *ctx\) {) p n
(    ) S
(int) k
( i;) p n
(    object a, v;) N
(    Zcounttomark\(ctx\);) N
(    i = pop\(ctx->lo, ctx->os\).int_.val;) N
(    a = consbar\(ctx, i\);) N
(    ) S
(for) K
( \( ; i > 0; i--\){) p n
(        v = pop\(ctx->lo, ctx->os\);) N
(        barput\(ctx, a, i-1, v\);) N
(    }) N
(    \() S
(void) k
(\)pop\(ctx->lo, ctx->os\); ) p
(// pop mark) c n
(    push\(ctx->lo, ctx->os, cvlit\(a\)\);) p n
(}) N
() N
(/* array  length  int) c n
(   number of elements in array */) N
(void) k
( Alength\(context *ctx, object A\) {) p n
(    push\(ctx->lo, ctx->os, consint\(A.comp_.sz\)\);) N
(}) N
() N
(/* array index  get  any) c n
(   get array element indexed by index */) N
(void) k
( Aget\(context *ctx, object A, object I\) {) p n
(    push\(ctx->lo, ctx->os, barget\(ctx, A, I.int_.val\)\);) N
(}) N
() N
(/* array index any  put  -) c n
(   put any into array at index */) N
(void) k
( Aput\(context *ctx, object A, object I, object O\) {) p n
(    barput\(ctx, A, I.int_.val, O\);) N
(}) N
() N
(/* array index count  getinterval  subarray) c n
(opar.c) (Page 1/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   subarray of array starting at index for count elements */) c n
(void) k
( Agetinterval\(context *ctx, object A, object I, object L\) {) p n
(    push\(ctx->lo, ctx->os, arrgetinterval\(A, I.int_.val, L.int_.val\)\);) N
(}) N
() N
(/* array1 index array2  putinterval  -) c n
(   replace subarray of array1 starting at index by array2 */) N
(void) k
( Aputinterval\(context *ctx, object D, object I, object S\) {) p n
(    ) S
(if) K
( \(I.int_.val + S.comp_.sz > D.comp_.sz\) error\(rangecheck, ") p
(putinterval) str
("\);) p n
(    a_copy\(ctx, S, arrgetinterval\(D, I.int_.val, S.comp_.sz\)\);) N
(}) N
() N
(/* array  aload  a0..aN-1 array) c n
(   push all elements of array on stack */) N
(void) k
( Aaload\(context *ctx, object A\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i = 0; i < A.comp_.sz; i++\)) p n
(        push\(ctx->lo, ctx->os, barget\(ctx, A, i\)\);) N
(    push\(ctx->lo, ctx->os, A\);) N
(}) N
() N
(/* any0..anyN-1 array  astore  array) c n
(   pop elements from stack into array */) N
(void) k
( Aastore\(context *ctx, object A\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i = A.comp_.sz - 1; i >= 0; i--\)) p n
(        barput\(ctx, A, i, pop\(ctx->lo, ctx->os\)\);) N
(    push\(ctx->lo, ctx->os, A\);) N
(}) N
() N
(/* array1 array2  copy  subarray2) c n
(   copy elements of array1 to initial subarray of array2 */) N
(void) k
( Acopy\(context *ctx, object S, object D\) {) p n
(    ) S
(if) K
( \(D.comp_.sz < S.comp_.sz\) error\(rangecheck, ") p
(Acopy) str
("\);) p n
(    a_copy\(ctx, S, D\);) N
(    push\(ctx->lo, ctx->os, arrgetinterval\(D, 0, S.comp_.sz\)\);) N
(}) N
() N
(/* array proc  forall  -) c n
(   execute proc for each element of array */) N
(void) k
( Aforall\(context *ctx, object A, object P\) {) p n
(    ) S
(if) K
( \(A.comp_.sz == 0\) ) p
(return) K
(;) p n
(    assert\(ctx->gl->base\);) N
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(forall) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(    push\(ctx->lo, ctx->es, cvlit\(arrgetinterval\(A, 1, A.comp_.sz - 1\)\)\);) N
(    ) S
(if) K
( \(isx\(A\)\) push\(ctx->lo, ctx->es, consoper\(ctx, ") p
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, P\);) N
(    push\(ctx->lo, ctx->os, barget\(ctx, A, 0\)\);) N
(}) N
() N
(void) k
( initopar\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    op = consoper\(ctx, ") S
(array) str
(", Iarray, 1, 1,) p n
(            integertype\); INSTALL;) N
(    bdcput\(ctx, sd, consname\(ctx, ") S
([) str
("\), mark\);) p n
(    op = consoper\(ctx, ") S
(]) str
(", arrtomark, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(length) str
(", Alength, 1, 1,) p n
(            arraytype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(get) str
(", Aget, 1, 2,) p n
(            arraytype, integertype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(put) str
(", Aput, 0, 3,) p n
(            arraytype, integertype, anytype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(getinterval) str
(", Agetinterval, 1, 3,) p n
(            arraytype, integertype, integertype\); INSTALL;) N
(opar.c) (Page 2/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opar.c) (41/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3,1) 42
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    op = consoper\(ctx, ") p
(putinterval) str
(", Aputinterval, 0, 3,) p n
(            arraytype, integertype, arraytype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(aload) str
(", Aaload, 1, 1,) p n
(            arraytype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(astore) str
(", Aastore, 1, 1,) p n
(            arraytype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(copy) str
(", Acopy, 1, 2,) p n
(            arraytype, arraytype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(forall) str
(", Aforall, 0, 2,) p n
(            arraytype, proctype\); INSTALL;) N
(}) N
() N
(opar.c) (Page 3/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* relational, boolean, and bitwise operators */) c n
() p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
(#include) K
( <alloca.h>) p n
(#include) K
( <stdbool.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(/* any1 any2  eq  bool) c n
(   test equal */) N
(void) k
( Aeq \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(objcmp\(ctx,x,y\) == 0\)\);) N
(}) N
() N
(/* any1 any2  ne  bool) c n
(   test not equal */) N
(void) k
( Ane \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(objcmp\(ctx,x,y\) != 0\)\);) N
(}) N
() N
(/* any1 any2  ge  bool) c n
(   test greater or equal */) N
(void) k
( Age \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(objcmp\(ctx,x,y\) >= 0\)\);) N
(}) N
() N
(/* any1 any2  gt  bool) c n
(   test greater than */) N
(void) k
( Agt \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(objcmp\(ctx,x,y\) > 0\)\);) N
(}) N
() N
(/* any1 any2  le  bool) c n
(   test less or equal */) N
(void) k
( Ale \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(objcmp\(ctx,x,y\) <= 0\)\);) N
(}) N
() N
(/* any1 any2  lt  bool) c n
(   test less than */) N
(void) k
( Alt \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(objcmp\(ctx,x,y\) < 0\)\);) N
(}) N
() N
(/* bool1|int1 bool2|int2  and  bool3|int3) c n
(   logical|bitwise and */) N
(void) k
( Band \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(x.int_.val & y.int_.val\)\);) N
(}) N
() N
(void) k
( Iand \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consint\(x.int_.val & y.int_.val\)\);) N
(}) N
() N
(/* bool1|int1  not  bool2|int2) c n
(   logical|bitwise not */) N
(void) k
( Bnot \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consbool\( ! x.int_.val \)\);) N
(}) N
() N
(void) k
( Inot \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consint\( ~ x.int_.val \)\);) N
(opb.c) (Page 1/2) (Aug 17, 13 4:56) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opar.c, opb.c) (42/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2,1) 43
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(/* bool1|int1 bool2|int2  or  bool3|int3) c n
(   logical|bitwise inclusive or */) N
(void) k
( Bor \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(x.int_.val | y.int_.val\)\);) N
(}) N
() N
(void) k
( Ior \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consint\(x.int_.val | y.int_.val\)\);) N
(}) N
() N
(/* bool1|int1 bool2|int2  xor  bool3|int3) c n
(   exclusive or */) N
(void) k
( Bxor \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(x.int_.val ^ y.int_.val\)\);) N
(}) N
() N
(void) k
( Ixor \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consint\(x.int_.val ^ y.int_.val\)\);) N
(}) N
() N
(// true) c n
() p n
(// false) c n
() p n
(/* int1 shift  bitshift  int2) c n
(   bitwise shift of int1 \(positive is left\) */) N
(void) k
( Ibitshift \(context *ctx, object x, object y\) {) p n
(    ) S
(if) K
( \(y.int_.val >= 0\)) p n
(        push\(ctx->lo, ctx->os, consint\(x.int_.val << y.int_.val\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consint\() p n
(                    \() S
(unsigned) k
( ) p
(long) k
(\)x.int_.val >> -y.int_.val\)\);) p n
(}) N
() N
(void) k
( initopb\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(eq) str
(", Aeq, 1, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(ne) str
(", Ane, 1, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(ge) str
(", Age, 1, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(gt) str
(", Agt, 1, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(le) str
(", Ale, 1, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(lt) str
(", Alt, 1, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(and) str
(", Band, 1, 2, booleantype, booleantype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(and) str
(", Iand, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(not) str
(", Bnot, 1, 1, booleantype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(not) str
(", Inot, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(or) str
(", Bor, 1, 2, booleantype, booleantype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(or) str
(", Ior, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(xor) str
(", Bxor, 1, 2, booleantype, booleantype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(xor) str
(", Ixor, 1, 2, integertype, integertype\); INSTALL;) p n
(    bdcput\(ctx, sd, consname\(ctx, ") S
(true) str
("\), consbool\(true\)\);) p n
(    bdcput\(ctx, sd, consname\(ctx, ") S
(false) str
("\), consbool\(false\)\);) p n
(    op = consoper\(ctx, ") S
(bitshift) str
(", Ibitshift, 1, 2, integertype, integertype\); INST) p n
(ALL;) N
() N
(    ) S
(/* dumpdic\(ctx->gl, sd\); fflush\(NULL\); */) c n
(}) p n
(opb.c) (Page 2/2) (Aug 17, 13 4:56) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* control operators */) c n
() p n
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h> ) p
(/* printf */) c n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(void) k
( Aexec \(context *ctx, object O\) {) p n
(    push\(ctx->lo, ctx->es, O\);) N
(}) N
() N
(void) k
( BPif \(context *ctx, object B, object P\) {) p n
(    ) S
(if) K
( \(B.int_.val\)) p n
(        push\(ctx->lo, ctx->es, P\);) N
(}) N
() N
(void) k
( BPPifelse \(context *ctx, object B, object Then, object Else\) {) p n
(    ) S
(if) K
( \(B.int_.val\)) p n
(        push\(ctx->lo, ctx->es, Then\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->es, Else\);) p n
(}) N
() N
(void) k
( IIIPfor \(context *ctx, object init, object incr, object lim, object P\) {) p n
(    integer i = init.int_.val;) N
(    integer j = incr.int_.val;) N
(    integer n = lim.int_.val;) N
(    bool up = j > 0;) N
(    ) S
(if) K
( \(up? i > n : i < n\) ) p
(return) K
(;) p n
(    assert\(ctx->gl->base\);) N
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(for) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(    push\(ctx->lo, ctx->es, lim\);) N
(    push\(ctx->lo, ctx->es, incr\);) N
(    push\(ctx->lo, ctx->es, consint\(i + j\)\);) N
(    push\(ctx->lo, ctx->es, P\);) N
(    push\(ctx->lo, ctx->es, init\);) N
(}) N
() N
(void) k
( RRRPfor \(context *ctx, object init, object incr, object lim, object P\) {) p n
(    real i = init.real_.val;) N
(    real j = incr.real_.val;) N
(    real n = lim.real_.val;) N
(    bool up = j > 0;) N
(    ) S
(if) K
( \(up? i > n : i < n\) ) p
(return) K
(;) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(for) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(    push\(ctx->lo, ctx->es, lim\);) N
(    push\(ctx->lo, ctx->es, incr\);) N
(    push\(ctx->lo, ctx->es, consreal\(i + j\)\);) N
(    push\(ctx->lo, ctx->es, P\);) N
(    push\(ctx->lo, ctx->es, init\);) N
(}) N
() N
(void) k
( IPrepeat \(context *ctx, object n, object P\) {) p n
(    ) S
(if) K
( \(n.int_.val <= 0\) ) p
(return) K
(;) p n
(opc.c) (Page 1/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opb.c, opc.c) (43/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 44
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") p
(repeat) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(    push\(ctx->lo, ctx->es, consint\(n.int_.val - 1\)\);) N
(    push\(ctx->lo, ctx->es, P\);) N
(}) N
() N
(void) k
( Ploop \(context *ctx, object P\) {) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(loop) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(    push\(ctx->lo, ctx->es, P\);) N
(}) N
() N
(void) k
( Zexit \(context *ctx\) {) p n
(    object opfor = consoper\(ctx, ") S
(for) str
(", ) p
(NULL) K
(,0,0\);) p n
(    object oprepeat = consoper\(ctx, ") S
(repeat) str
(", ) p
(NULL) K
(,0,0\);) p n
(    object oploop = consoper\(ctx, ") S
(loop) str
(", ) p
(NULL) K
(,0,0\);) p n
(    object opforall = consoper\(ctx, ") S
(forall) str
(", ) p
(NULL) K
(,0,0\);) p n
(    object x;) N
() N
(#if) K
( 0) p n
(    printf\(") S
(\\nexit\\n) str
("\);) p n
(    dumpobject\(opfor\);) N
(    dumpobject\(oprepeat\);) N
(    dumpobject\(oploop\);) N
(    dumpobject\(opforall\);) N
() N
(    dumpstack\(ctx->lo, ctx->os\);) N
(    dumpstack\(ctx->lo, ctx->es\);) N
(    printf\(") S
(\\n) str
("\);) p n
(#endif) K n
() p n
(    ) S
(while) K
( \(1\) {) p n
(        x = pop\(ctx->lo, ctx->es\);) N
(        ) S
(//dumpobject\(x\);) c n
(        ) p
(if) K
( \( \(objcmp\(ctx, x, opfor\)    == 0\)) p n
(          || \(objcmp\(ctx, x, oprepeat\) == 0\)) N
(          || \(objcmp\(ctx, x, oploop\)   == 0\)) N
(          || \(objcmp\(ctx, x, opforall\) == 0\)) N
(           \) {) N
(            ) S
(break) K
(;) p n
(        }) N
(    }) N
() N
(#if) K
( 0) p n
(    printf\(") S
(result:) str
("\);) p n
(    dumpstack\(ctx->lo, ctx->es\);) N
(#endif) K n
(}) p n
() N
(/* The stopped context is a boolean 'false' on the exec stack,) c n
(   so normal execution simply falls through and pushes the ) N
(   false onto the operand stack. 'stop' then merely has to ) N
(   search for 'false' and push a 'true'.  */) N
() p n
(void) k
( Zstop\(context *ctx\) {) p n
(    object f = consbool\(false\);) N
(    ) S
(int) k
( c = count\(ctx->lo, ctx->es\);) p n
(    object x;) N
(    ) S
(while) K
( \(c--\) {) p n
(        x = pop\(ctx->lo, ctx->es\);) N
(        ) S
(if) K
(\(objcmp\(ctx, f, x\) == 0\) {) p n
(            push\(ctx->lo, ctx->os, consbool\(true\)\);) N
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
(    error\(unregistered, ") S
(no stopped context in 'stop') str
("\);) p n
(}) N
(opc.c) (Page 2/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( Astopped\(context *ctx, object o\) {) p n
(    push\(ctx->lo, ctx->es, consbool\(false\)\);) N
(    push\(ctx->lo, ctx->es, o\);) N
(}) N
() N
(void) k
( Zcountexecstack\(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, consint\(count\(ctx->lo, ctx->es\)\)\);) N
(}) N
() N
(void) k
( Aexecstack\(context *ctx, object A\) {) p n
(    ) S
(int) k
( z = count\(ctx->lo, ctx->es\);) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i=0; i < z; i++\)) p n
(        barput\(ctx, A, i, bot\(ctx->lo, ctx->es, i\)\);) N
(    push\(ctx->lo, ctx->os, arrgetinterval\(A, 0, z\)\);) N
(}) N
() N
(//TODO start) c n
() p n
(void) k
( Zquit\(context *ctx\) {) p n
(    ctx->quit = 1;) N
(}) N
() N
(void) k
( initopc \(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(exec) str
(", Aexec, 0, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(if) str
(", BPif, 0, 2, booleantype, proctype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(ifelse) str
(", BPPifelse, 0, 3, booleantype, proctype, proctype\)) p n
(; INSTALL;) N
(    op = consoper\(ctx, ") S
(for) str
(", IIIPfor, 0, 4, \\) p n
(            integertype, integertype, integertype, proctype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(for) str
(", RRRPfor, 0, 4, \\) p n
(            floattype, floattype, floattype, proctype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(repeat) str
(", IPrepeat, 0, 2, integertype, proctype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(loop) str
(", Ploop, 0, 1, proctype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(exit) str
(", Zexit, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(stop) str
(", Zstop, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(stopped) str
(", Astopped, 0, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(countexecstack) str
(", Zcountexecstack, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(execstack) str
(", Aexecstack, 1, 1, arraytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(quit) str
(", Zquit, 0, 0\); INSTALL;) p n
(    ) S
(/*) c n
(    op = consoper\(ctx, "eq", Aeq, 1, 2, anytype, anytype\); INSTALL;) N
(    //dumpdic\(ctx->gl, sd\); fflush\(NULL\);) N
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\);) N
(    */) N
() p n
(}) N
() N
() N
(opc.c) (Page 3/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opc.c) (44/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 45
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(ops.h) str
(") p n
() N
(int) k
( DEBUGLOAD = 0;) p n
(void) k
( Awhere\(context *ctx, object K\); ) p
(/* forward decl */) c n
() p n
(/* int  dict  dict) c n
(   create dictionary with capacity for int elements */) N
(void) k
( Idict\(context *ctx, object I\) {) p n
(    push\(ctx->lo, ctx->os, cvlit\(consbdc\(ctx, I.int_.val\)\)\);) N
(}) N
() N
(/* -  <<  mark) c n
(   start dictionary construction */) N
() p n
(/* mark k_1 v_1 ... k_N v_N  >>  dict) c n
(   construct dictionary from pairs on stack */) N
(void) k
( dictomark\(context *ctx\) {) p n
(    ) S
(int) k
( i;) p n
(    object d, k, v;) N
(    Zcounttomark\(ctx\);) N
(    i = pop\(ctx->lo, ctx->os\).int_.val;) N
(    d = consbdc\(ctx, i\);) N
(    ) S
(for) K
( \( ; i > 0; i -= 2\){) p n
(        v = pop\(ctx->lo, ctx->os\);) N
(        k = pop\(ctx->lo, ctx->os\);) N
(        bdcput\(ctx, d, k, v\);) N
(    }) N
(    \() S
(void) k
(\)pop\(ctx->lo, ctx->os\); ) p
(// pop mark) c n
(    push\(ctx->lo, ctx->os, d\);) p n
(}) N
() N
(/* dict  length  int) c n
(   number of key-value pairs in dict */) N
(void) k
( Dlength\(context *ctx, object D\) {) p n
(    push\(ctx->lo, ctx->os, consint\(diclength\() N
(                    bank\(ctx, D\) ) S
(/*D.tag&FBANK?ctx->gl:ctx->lo*/) c
(,) p n
(                    D\)\)\);) N
(}) N
() N
(/* dict  maxlength  int) c n
(   capacity of dict */) N
(void) k
( Dmaxlength\(context *ctx, object D\) {) p n
(    push\(ctx->lo, ctx->os, consint\(dicmaxlength\() N
(                    bank\(ctx, D\) ) S
(/*D.tag&FBANK?ctx->gl:ctx->lo*/) c
(,) p n
(                    D\)\)\);) N
(}) N
() N
(/* dict  begin  -) c n
(   push dict on dict stack */) N
(void) k
( Dbegin\(context *ctx, object D\) {) p n
(    push\(ctx->lo, ctx->ds, D\);) N
(}) N
() N
(opdi.c) (Page 1/5) (Aug 24, 13 14:28) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* -  end  -) c n
(   pop dict stack */) N
(void) k
( Zend\(context *ctx\) {) p n
(    ) S
(if) K
( \(count\(ctx->lo, ctx->ds\) <= 3\)) p n
(        error\(dictstackunderflow, ") S
(end) str
("\);) p n
(    \() S
(void) k
(\)pop\(ctx->lo, ctx->ds\);) p n
(}) N
() N
(/* key value  def  -) c n
(   associate key with value in current dict */) N
(void) k
( Adef\(context *ctx, object K, object V\) {) p n
(    ) S
(//object D = top\(ctx->lo, ctx->ds, 0\);) c n
(    ) p
(//dumpdic\(bank\(ctx, D\), D\); puts\(""\);) c n
(    bdcput\(ctx, top\(ctx->lo, ctx->ds, 0\), K, V\);) p n
(    ) S
(//puts\("!def!"\);) c n
(    ) p
(//dumpdic\(bank\(ctx, D\), D\); puts\(""\);) c n
(}) p n
() N
(/* key  load  value) c n
(   search dict stack for key and return associated value */) N
(void) k
( Aload\(context *ctx, object K\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(int) k
( z = count\(ctx->lo, ctx->ds\);) p n
(    ) S
(if) K
( \(DEBUGLOAD\) {) p n
(        printf\(") S
(\\nload:) str
("\);) p n
(        dumpobject\(K\);) N
(        dumpstack\(ctx->lo, ctx->ds\);) N
(    }) N
() N
(    ) S
(for) K
( \(i = 0; i < z; i++\) {) p n
(        object D = top\(ctx->lo,ctx->ds,i\);) N
() N
(    ) S
(if) K
( \(DEBUGLOAD\) {) p n
(        dumpdic\(bank\(ctx, D\), D\);) N
(        \() S
(void) k
(\)puts\(""\);) p n
(    }) N
() N
(        ) S
(if) K
( \(dicknown\(ctx, bank\(ctx, D\), D, K\)\) {) p n
(            push\(ctx->lo, ctx->os, bdcget\(ctx, D, K\)\);) N
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
() N
(    ) S
(if) K
( \(DEBUGLOAD\) {) p n
(        dumpmfile\(ctx->lo\);) N
(        dumpmtab\(ctx->lo, 0\);) N
(        dumpmfile\(ctx->gl\);) N
(        dumpmtab\(ctx->gl, 0\);) N
(        dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\);) N
(        dumpobject\(K\);) N
(    }) N
() N
(    error\(undefined, ") S
(Aload) str
("\);) p n
(}) N
() N
(/* key value  store  -) c n
(   replace topmost definition of key */) N
(void) k
( Astore\(context *ctx, object K, object V\) {) p n
(    object D;) N
(    Awhere\(ctx, K\);) N
(    ) S
(if) K
( \(pop\(ctx->lo, ctx->os\).int_.val\) {) p n
(        D = pop\(ctx->lo, ctx->os\);) N
(    } ) S
(else) K
( {) p n
(        D = top\(ctx->lo, ctx->ds, 0\);) N
(    }) N
(    bdcput\(ctx, D, K, V\);) N
(}) N
() N
(/* dict key  get  any) c n
(opdi.c) (Page 2/5) (Aug 24, 13 14:28) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opdi.c) (45/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 46
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   get value associated with key in dict */) c n
(void) k
( DAget\(context *ctx, object D, object K\) {) p n
(    push\(ctx->lo, ctx->os, bdcget\(ctx, D, K\)\);) N
(}) N
() N
(/* dict key value  put  -) c n
(   associate key with value in dict */) N
(void) k
( DAAput\(context *ctx, object D, object K, object V\) {) p n
(    bdcput\(ctx, D, K, V\);) N
(}) N
() N
(/* dict key  undef  -) c n
(   remove key and its value in dict */) N
(void) k
( DAundef\(context *ctx, object D, object K\) {) p n
(    bdcundef\(ctx, D, K\);) N
(}) N
() N
(/* dict key  known  bool) c n
(   test whether key is in dict */) N
(void) k
( DAknown\(context *ctx, object D, object K\) {) p n
(#if) K
( 0) p n
(    printf\(") S
(\\nknown: ) str
("\);) p n
(    dumpobject\(D\);) N
(    dumpdic\(bank\(ctx, D\), D\); puts\(""\);) N
(    dumpobject\(K\);) N
(#endif) K n
(    push\(ctx->lo, ctx->os, consbool\(dicknown\(ctx, bank\(ctx, D\), D, K\)\)\);) p n
(}) N
() N
() N
(/* key  where  dict true -or- false) c n
(   find dict in which key is defined */) N
(void) k
( Awhere\(context *ctx, object K\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(int) k
( z = count\(ctx->lo, ctx->ds\);) p n
(    ) S
(for) K
( \(i = 0; i < z; i++\) {) p n
(        object D = top\(ctx->lo, ctx->ds, i\);) N
(        ) S
(if) K
( \(dicknown\(ctx, bank\(ctx, D\), D, K\)\) {) p n
(            push\(ctx->lo, ctx->os, D\);) N
(            push\(ctx->lo, ctx->os, consbool\(true\)\);) N
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
(    push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(}) N
() N
(/* dict1 dict2  copy  dict2) c n
(   copy contents of dict1 to dict2 */) N
(void) k
( Dcopy\(context *ctx, object S, object D\) {) p n
(    ) S
(int) k
( i, sz;) p n
(    mfile *mem;) N
(    ) S
(unsigned) k
( ad;) p n
(    dichead *dp;) N
(    object *tp;) N
(    mem = bank\(ctx, S\);) N
(    sz = dicmaxlength\(mem, S\);) N
(    ad = adrent\(mem, S.comp_.ent\);) N
(    dp = \() S
(void) k
( *\)\(mem->base + ad\);) p n
(    tp = \() S
(void) k
( *\)\(mem->base + ad + ) p
(sizeof) K
(\(dichead\)\);) p n
(    ) S
(for) K
( \(i=0; i < sz+1; i++\) {) p n
(        ) S
(if) K
( \(type\(tp[2 * i]\) != nulltype\) {) p n
(            bdcput\(ctx, D, tp[2*i], tp[2*i+1]\);) N
(        }) N
(    }) N
(    push\(ctx->lo, ctx->os, D\);) N
(}) N
() N
(void) k
( DPforall \(context *ctx, object D, object P\) {) p n
(    mfile *mem = bank\(ctx, D\);) N
(opdi.c) (Page 3/5) (Aug 24, 13 14:28) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    assert\(mem->base\);) p n
(    D.comp_.sz = dicmaxlength\(mem, D\); ) S
(// stash size locally) c n
(    ) p
(if) K
( \(D.comp_.off <= D.comp_.sz\) { ) p
(// not finished?) c n
(        ) p
(unsigned) k
( ad;) p n
(        dichead *dp;) N
(        object *tp;) N
(        ad = adrent\(mem, D.comp_.ent\);) N
(        dp = \() S
(void) k
( *\)\(mem->base + ad\); ) p n
(        tp = \() S
(void) k
( *\)\(mem->base + ad + ) p
(sizeof) K
(\(dichead\)\); ) p n
() N
(        ) S
(for) K
( \( ; D.comp_.off <= D.comp_.sz; ++D.comp_.off\) { ) p
(// find next pair) c n
(            ) p
(if) K
( \(type\(tp[2 * D.comp_.off]\) != nulltype\) { ) p
(// found) c n
(                object k,v;) p n
() N
(                k = tp[2 * D.comp_.off];) N
(                ) S
(if) K
( \(type\(k\) == extendedtype\)) p n
(                    k = unextend\(k\);) N
(                v = tp[2 * D.comp_.off + 1];) N
(                push\(ctx->lo, ctx->os, k\);) N
(                push\(ctx->lo, ctx->os, v\);) N
() N
(                push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(forall) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(                push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(                push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(                ++D.comp_.off;) N
(                push\(ctx->lo, ctx->es, D\);) N
() N
(                push\(ctx->lo, ctx->es, P\);) N
(                ) S
(return) K
(;) p n
(            }) N
(        }) N
(    }) N
(}) N
() N
(/* -  currentdict  dict) c n
(   push current dict on operand stack */) N
(void) k
( Zcurrentdict\(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, top\(ctx->lo, ctx->ds, 0\)\);) N
(}) N
() N
(/* -  errordict  dict   % error handler dictionary : err.ps) c n
(   -  $error  dict      % error control and status dictionary : err.ps) N
(   -  systemdict  dict  % system dictionary : op.c init.ps) N
(   -  userdict  dict    % writeable dictionary in local VM : itp.c) N
(   %-  globaldict  dict  % writeable dictionary in global VM) N
(   %-  statusdict  dict  % product-dependent dictionary) N
(   */) N
() p n
(/* -  countdictstack  int) c n
(   count elements on dict stack */) N
(void) k
( Zcountdictstack\(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, consint\(count\(ctx->lo, ctx->ds\)\)\);) N
(}) N
() N
(/* array  dictstack  subarray) c n
(   copy dict stack into array */) N
(void) k
( Adictstack\(context *ctx, object A\) {) p n
(    ) S
(int) k
( z = count\(ctx->lo, ctx->ds\);) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i=0; i < z; i++\)) p n
(        barput\(ctx, A, i, bot\(ctx->lo, ctx->ds, i\)\);) N
(    push\(ctx->lo, ctx->os, arrgetinterval\(A, 0, z\)\);) N
(}) N
() N
(void) k
( cleardictstack\(context *ctx\) {) p n
(    ) S
(int) k
( z = count\(ctx->lo, ctx->ds\);) p n
(    ) S
(while) K
( \(z-- > 3\) {) p n
(        \() S
(void) k
(\)pop\(ctx->lo, ctx->ds\);) p n
(    }) N
(opdi.c) (Page 4/5) (Aug 24, 13 14:28) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opdi.c) (46/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5,1) 47
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(void) k
( initopdi\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    op = consoper\(ctx, ") S
(dict) str
(", Idict, 1, 1, integertype\); INSTALL;) p n
(    bdcput\(ctx, sd, consname\(ctx, ") S
(<<) str
("\), mark\);) p n
(    op = consoper\(ctx, ") S
(>>) str
(", dictomark, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(length) str
(", Dlength, 1, 1, dicttype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(maxlength) str
(", Dmaxlength, 1, 1, dicttype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(begin) str
(", Dbegin, 0, 1, dicttype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(end) str
(", Zend, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(def) str
(", Adef, 0, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(load) str
(", Aload, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(store) str
(", Astore, 0, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(get) str
(", DAget, 1, 2, dicttype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(put) str
(", DAAput, 1, 3,) p n
(            dicttype, anytype, anytype\); INSTALL;) N
(    ) S
(//op = consoper\(ctx, "undef", DAundef, 0, 2, dicttype, anytype\); INSTALL;) c n
(    op = consoper\(ctx, ") p
(known) str
(", DAknown, 1, 2, dicttype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(where) str
(", Awhere, 2, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(copy) str
(", Dcopy, 1, 2, dicttype, dicttype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(forall) str
(", DPforall, 0, 2, dicttype, proctype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(currentdict) str
(", Zcurrentdict, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(countdictstack) str
(", Zcountdictstack, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(dictstack) str
(", Adictstack, 1, 1, arraytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cleardictstack) str
(", cleardictstack, 0, 0\); INSTALL;) p n
(}) N
() N
(opdi.c) (Page 5/5) (Aug 24, 13 14:28) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <ctype.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdio_ext.h> ) p
(/* __fpurge */) c n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(f.h) str
(") p n
(#include) K
( ") p
(osunix.h) str
(") p n
() N
(void) k
( Sfile \(context *ctx, object fn, object mode\) {) p n
(    object f;) N
(    f = fileopen\(ctx->lo, charstr\(ctx, fn\), charstr\(ctx, mode\)\);) N
(    push\(ctx->lo, ctx->os, cvlit\(f\)\);) N
(}) N
() N
(void) k
( Fclosefile \(context *ctx, object f\) {) p n
(    fileclose\(ctx->lo, f\);) N
(}) N
() N
(void) k
( Fread \(context *ctx, object f\) {) p n
(    object b;) N
(    ) S
(if) K
( \(!isreadable\(f\)\) error\(invalidaccess, ") p
(Fread) str
("\);) p n
(    b = fileread\(ctx->lo, f\);) N
(    ) S
(if) K
( \(b.int_.val != EOF\) {) p n
(        push\(ctx->lo, ctx->os, b\);) N
(        push\(ctx->lo, ctx->os, consbool\(true\)\);) N
(    } ) S
(else) K
( {) p n
(        push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(    }) N
(}) N
() N
(void) k
( Fwrite \(context *ctx, object f, object i\) {) p n
(    ) S
(if) K
( \(!iswriteable\(f\)\) error\(invalidaccess, ") p
(Fwrite) str
("\);) p n
(    filewrite\(ctx->lo, f, i\);) N
(}) N
() N
(char) k
( *hex = ") p
(0123456789) str
(" ") p
(ABCDEF) str
(" ") p
(abcdef) str
(";) p n
() N
(void) k
( Freadhexstring \(context *ctx, object F, object S\) {) p n
(    ) S
(int) k
( n;) p n
(    ) S
(int) k
( c[2];) p n
(    ) S
(int) k
( eof = 0;) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(char) k
( *s;) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) error\(ioerror, ") p
(Freadhexstring) str
("\);) p n
(    ) S
(if) K
( \(!isreadable\(F\)\) error\(invalidaccess, ") p
(Freadhexstring) str
("\);) p n
(    f = filefile\(ctx->lo, F\);) N
(    s = charstr\(ctx, S\);) N
() N
(    ) S
(for) K
(\(n=0; !eof && n < S.comp_.sz; n++\) {) p n
(        ) S
(do) K
( {) p n
(            c[0] = fgetc\(f\);) N
(            ) S
(if) K
( \(c[0] == EOF\) ++eof;) p n
(        } ) S
(while) K
(\(!eof && strchr\(hex, c[0]\) == ) p
(NULL) K
(\);) p n
(        ) S
(if) K
( \(!eof\) {) p n
(            ) S
(do) K
( {) p n
(                c[1] = fgetc\(f\);) N
(opf.c) (Page 1/4) (Aug 18, 13 1:35) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opdi.c, opf.c) (47/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 48
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                ) p
(if) K
( \(c[1] == EOF\) ++eof;) p n
(            } ) S
(while) K
(\(!eof && strchr\(hex, c[1]\) == ) p
(NULL) K
(\);) p n
(        } ) S
(else) K
( {) p n
(            c[1] = ') S
(0) str
(';) p n
(        }) N
(        s[n] = \(\(strchr\(hex, toupper\(c[0]\)\) - hex\) << 4\)) N
(             | \(strchr\(hex, toupper\(c[1]\)\) - hex\);) N
(    }) N
(    S.comp_.sz = n;) N
(    push\(ctx->lo, ctx->os, S\);) N
(    push\(ctx->lo, ctx->os, consbool\(!eof\)\);) N
(}) N
() N
(void) k
( Fwritehexstring \(context *ctx, object F, object S\) {) p n
(    ) S
(int) k
( n;) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(char) k
( *s;) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) error\(ioerror, ") p
(Fwritehexstring) str
("\);) p n
(    ) S
(if) K
( \(!iswriteable\(F\)\) error\(invalidaccess, ") p
(Fwritehexstring) str
("\);) p n
(    f = filefile\(ctx->lo, F\);) N
(    s = charstr\(ctx, S\);) N
() N
(    ) S
(for) K
(\(n=0; n < S.comp_.sz; n++\) {) p n
(        ) S
(if) K
( \(fputc\(hex[s[n] / 16], f\)\) error\(ioerror, ") p
(Fwritehexstring) str
("\);) p n
(        ) S
(if) K
( \(fputc\(hex[s[n] % 16], f\)\) error\(ioerror, ") p
(Fwritehexstring) str
("\);) p n
(    }) N
(}) N
() N
(void) k
( Freadstring \(context *ctx, object F, object S\) {) p n
(    ) S
(int) k
( n;) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(char) k
( *s;) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) error\(ioerror, ") p
(Freadstring) str
("\);) p n
(    ) S
(if) K
( \(!isreadable\(F\)\) error\(invalidaccess, ") p
(Freadstring) str
("\);) p n
(    f = filefile\(ctx->lo, F\);) N
(    s = charstr\(ctx, S\);) N
(    n = fread\(s, 1, S.comp_.sz, f\);) N
(    ) S
(if) K
( \(n == S.comp_.sz\) {) p n
(        push\(ctx->lo, ctx->os, S\);) N
(        push\(ctx->lo, ctx->os, consbool\(true\)\);) N
(    } ) S
(else) K
( {) p n
(        S.comp_.sz = n;) N
(        push\(ctx->lo, ctx->os, S\);) N
(        push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(    }) N
(}) N
() N
(void) k
( Fwritestring \(context *ctx, object F, object S\) {) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(char) k
( *s;) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) error\(ioerror, ") p
(Fwritestring) str
("\);) p n
(    ) S
(if) K
( \(!iswriteable\(F\)\) error\(invalidaccess, ") p
(Fwritestring) str
("\);) p n
(    f = filefile\(ctx->lo, F\);) N
(    s = charstr\(ctx, S\);) N
(    ) S
(if) K
( \(fwrite\(s, 1, S.comp_.sz, f\) != S.comp_.sz\)) p n
(        error\(ioerror, ") S
(Fwritestring) str
("\);) p n
(}) N
() N
(void) k
( Freadline \(context *ctx, object F, object S\) {) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(char) k
( *s;) p n
(    ) S
(int) k
( n, c = ') p
( ) str
(';) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) error\(ioerror, ") p
(Freadline) str
("\);) p n
(    ) S
(if) K
( \(!iswriteable\(F\)\) error\(invalidaccess, ") p
(Freadline) str
("\);) p n
(    f = filefile\(ctx->lo, F\);) N
(    s = charstr\(ctx, S\);) N
(    ) S
(for) K
( \(n=0; n < S.comp_.sz; n++\) {) p n
(        c = fgetc\(f\);) N
(        ) S
(if) K
( \(c == EOF || c == ') p
(\\n) str
('\) ) p
(break) K
(;) p n
(opf.c) (Page 2/4) (Aug 18, 13 1:35) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        s[n] = c;) p n
(    }) N
(    ) S
(if) K
( \(n == S.comp_.sz && c != ') p
(\\n) str
('\) error\(rangecheck, ") p
(Freadline) str
("\);) p n
(    S.comp_.sz = n;) N
(    push\(ctx->lo, ctx->os, S\);) N
(    push\(ctx->lo, ctx->os, consbool\(c != EOF\)\);) N
(}) N
() N
(void) k
( Fbytesavailable \(context *ctx, object F\) {) p n
(    push\(ctx->lo, ctx->os, consint\(filebytesavailable\(ctx->lo, F\)\)\);) N
(}) N
() N
(void) k
( Zflush \(context *ctx\) {) p n
(    ) S
(int) k
( ret;) p n
(    \() S
(void) k
(\)ctx;) p n
(    ret = fflush\() S
(NULL) K
(\);) p n
(    ) S
(if) K
( \(ret != 0\) error\(ioerror, ") p
(fflush did not return 0) str
("\);) p n
(}) N
() N
(void) k
( Fflushfile \(context *ctx, object F\) {) p n
(    ) S
(int) k
( ret;) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) ) p
(return) K
(;) p n
(    f = filefile\(ctx->lo, F\);) N
(    ) S
(if) K
( \(iswriteable\(F\)\) {) p n
(        ret = fflush\(f\);) N
(        ) S
(if) K
( \(ret != 0\) error\(ioerror, ") p
(fflush did not return 0) str
("\);) p n
(    } ) S
(else) K
( {) p n
(        ) S
(int) k
( c;) p n
(        ) S
(while) K
( \(\(c = fgetc\(f\)\) != EOF\)) p n
(            ) S
(/**/) c
(;) p n
(    }) N
(}) N
() N
(void) k
( Fresetfile \(context *ctx, object F\) {) p n
(    ) S
(FILE) k
( *f;) p n
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) ) p
(return) K
(;) p n
(    f = filefile\(ctx->lo, F\);) N
(    __fpurge\(f\);) N
(}) N
() N
(void) k
( Fstatus \(context *ctx, object F\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(filestatus\(ctx->lo, F\)\)\);) N
(}) N
() N
(void) k
( Zcurrentfile \(context *ctx\) {) p n
(    ) S
(int) k
( z = count\(ctx->lo, ctx->es\);) p n
(    ) S
(int) k
( i;) p n
(    object o;) N
(    ) S
(for) K
( \(i=0; i<z; i++\) {) p n
(        o = top\(ctx->lo, ctx->es, i\);) N
(        ) S
(if) K
( \(type\(o\) == filetype\) {) p n
(            push\(ctx->lo, ctx->os, o\);) N
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
(    push\(ctx->lo, ctx->os, consfile\(ctx->lo, ) S
(NULL) K
(\)\);) p n
(}) N
() N
(void) k
( Sprint \(context *ctx, object S\) {) p n
(    size_t ret;) N
(    ) S
(char) k
( *s;) p n
(    s = charstr\(ctx, S\);) N
(    ret = fwrite\(s, 1, S.comp_.sz, stdout\);) N
(    ) S
(if) K
( \(ret != S.comp_.sz\)) p n
(        error\(ioerror, ") S
(Sprint\(\) fwrite returned unexpected value) str
("\);) p n
(}) N
() N
(void) k
( Becho \(context *ctx, object b\) {) p n
(opf.c) (Page 3/4) (Aug 18, 13 1:35) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opf.c) (48/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4,1) 49
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    \() p
(void) k
(\)ctx;) p n
(    ) S
(if) K
( \(b.int_.val\)) p n
(        echoon\(stdin\);) N
(    ) S
(else) K n
(        echooff\(stdin\);) p n
(}) N
() N
(void) k
( initopf \(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(file) str
(", Sfile, 1, 2, stringtype, stringtype\); INSTALL;) p n
(    ) S
(//filter) c n
(    op = consoper\(ctx, ") p
(closefile) str
(", Fclosefile, 0, 1, filetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(read) str
(", Fread, 1, 1, filetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(write) str
(", Fwrite, 0, 2, filetype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(readhexstring) str
(", Freadhexstring, 2, 2, filetype, stringtype\)) p n
(; INSTALL;) N
(    op = consoper\(ctx, ") S
(writehexstring) str
(", Fwritehexstring, 0, 2, filetype, stringtype) p n
(\); INSTALL;) N
(    op = consoper\(ctx, ") S
(readstring) str
(", Freadstring, 2, 2, filetype, stringtype\); INST) p n
(ALL;) N
(    op = consoper\(ctx, ") S
(writestring) str
(", Fwritestring, 0, 2, filetype, stringtype\); IN) p n
(STALL;) N
(    op = consoper\(ctx, ") S
(readline) str
(", Freadline, 2, 2, filetype, stringtype\); INSTALL) p n
(;) N
(    ) S
(//token: see optok.c) c n
(    op = consoper\(ctx, ") p
(bytesavailable) str
(", Fbytesavailable, 1, 1, filetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(flush) str
(", Zflush, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(flushfile) str
(", Fflushfile, 0, 1, filetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(resetfile) str
(", Fresetfile, 0, 1, filetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(status) str
(", Fstatus, 1, 1, filetype\); INSTALL;) p n
(    ) S
(//string status) c n
(    ) p
(//run: see init.ps) c n
(    op = consoper\(ctx, ") p
(currentfile) str
(", Zcurrentfile, 1, 0\); INSTALL;) p n
(    ) S
(//deletefile) c n
(    ) p
(//renamefile) c n
(    ) p
(//filenameforall) c n
(    ) p
(//setfileposition) c n
(    ) p
(//fileposition) c n
(    op = consoper\(ctx, ") p
(print) str
(", Sprint, 0, 1, stringtype\); INSTALL;) p n
(    ) S
(//=: see init.ps) c n
(    ) p
(//==: see init.ps) c n
(    ) p
(//stack: see init.ps) c n
(    ) p
(//pstack: see init.ps) c n
(    ) p
(//printobject) c n
(    ) p
(//writeobject) c n
(    ) p
(//setobjectformat) c n
(    ) p
(//currentobjectformat) c n
(    op = consoper\(ctx, ") p
(echo) str
(", Becho, 0, 1, booleantype\); INSTALL;) p n
() N
(    ) S
(/* dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\); */) N
(}) p n
() N
() N
(opf.c) (Page 4/4) (Aug 18, 13 1:35) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <limits.h>) p n
(#include) K
( <math.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h> ) p
(/* printf */) c n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
() p n
(#define) K
( PI \(4.0 * atan\(1.0\)\)) p n
(double) k
( RAD_PER_DEG ) p
(/* = PI / 180.0 */) c
(;) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(bool subwillunder\() S
(long) k
( x, ) p
(long) k
( y\);) p n
(bool addwillover\() S
(long) k
( x, ) p
(long) k
( y\) {) p n
(    ) S
(if) K
( \(y < 0\) ) p
(return) K
( subwillunder\(x, -y\);) p n
(    ) S
(if) K
( \(x > LONG_MAX - y\) ) p
(return) K
( true;) p n
(    ) S
(if) K
( \(y == LONG_MIN\) ) p
(return) K
( true;) p n
(    ) S
(return) K
( false;) p n
(}) N
() N
(bool subwillunder\() S
(long) k
( x, ) p
(long) k
( y\) {) p n
(    ) S
(if) K
( \(y < 0\) ) p
(return) K
( addwillover\(x, -y\);) p n
(    ) S
(if) K
( \(x < LONG_MIN + y\) ) p
(return) K
( true;) p n
(    ) S
(if) K
( \(y == LONG_MIN\) ) p
(return) K
( true;) p n
(    ) S
(return) K
( false;) p n
(}) N
() N
(bool mulwillover\() S
(long) k
( x, ) p
(long) k
( y\) {) p n
(    ) S
(if) K
( \(x == 0||y == 0\) ) p
(return) K
( false;) p n
(    ) S
(if) K
( \(x < 0\) x = -x;) p n
(    ) S
(if) K
( \(y < 0\) y = -y;) p n
(    ) S
(if) K
( \(x > LONG_MAX / y\) ) p
(return) K
( true;) p n
(    ) S
(return) K
( false;) p n
(}) N
() N
(/* num1 num2  add  sum) c n
(   num1 plus num2 */) N
(void) k
( Iadd \(context *ctx, object x, object y\) {) p n
(    ) S
(if) K
( \(addwillover\(x.int_.val, y.int_.val\)\)) p n
(        push\(ctx->lo, ctx->os, consreal\(\(real\)x.int_.val + y.int_.val\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consint\(x.int_.val + y.int_.val\)\);) p n
(}) N
() N
(void) k
( Radd \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(x.real_.val + y.real_.val\)\);) N
(}) N
() N
(/* num1 num2  div  quotient) c n
(   num1 divided by num2 */) N
(void) k
( Rdiv \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(x.real_.val / y.real_.val\)\);) N
(}) N
() N
(/* num1 num2  idiv  quotient) c n
(   integer divide */) N
(void) k
( Iidiv \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consint\(x.int_.val / y.int_.val\)\);) N
(}) N
() N
(/* num1 num2  mod  remainder) c n
(   num1 mod num2 */) N
(opm.c) (Page 1/5) (Sep 01, 13 4:11) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opf.c, opm.c) (49/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 50
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( Imod \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consint\(x.int_.val % y.int_.val\)\);) N
(}) N
() N
(/* num1 num2  mul  product) c n
(   num1 times num2 */) N
(void) k
( Imul \(context *ctx, object x, object y\) {) p n
(    ) S
(if) K
( \(mulwillover\(x.int_.val, y.int_.val\)\)) p n
(        push\(ctx->lo, ctx->os, consreal\(\(real\)x.int_.val * y.int_.val\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consint\(x.int_.val * y.int_.val\)\);) p n
(}) N
() N
(void) k
( Rmul \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(x.real_.val * y.real_.val\)\);) N
(}) N
() N
(/* num1 num2  sub  difference) c n
(   num1 minus num2 */) N
(void) k
( Isub \(context *ctx, object x, object y\) {) p n
(    ) S
(if) K
( \(subwillunder\(x.int_.val, y.int_.val\)\)) p n
(        push\(ctx->lo, ctx->os, consreal\(\(real\)x.int_.val - y.int_.val\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consint\(x.int_.val - y.int_.val\)\);) p n
(}) N
() N
(void) k
( Rsub \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(x.real_.val - y.real_.val\)\);) N
(}) N
() N
(/* num1  abs  num2) c n
(   absolute value of num1 */) N
(void) k
( Iabs \(context *ctx, object x\) {) p n
(    ) S
(if) K
( \(x.int_.val == INT_MIN\)) p n
(        push\(ctx->lo, ctx->os, consreal\(- \(real\)INT_MIN\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consint\(x.int_.val>0? x.int_.val: -x.int_.val\)\);) p n
(}) N
() N
(void) k
( Rabs \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(fabs\(x.real_.val\)\)\);) N
(}) N
() N
(/* num1  neg  num2) c n
(   negative of num1 */) N
(void) k
( Ineg \(context *ctx, object x\) {) p n
(    ) S
(if) K
( \(x.int_.val == INT_MIN\)) p n
(        push\(ctx->lo, ctx->os, consreal\(- \(real\)INT_MIN\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consint\(-x.int_.val\)\);) p n
(}) N
() N
(void) k
( Rneg \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(-x.real_.val\)\);) N
(}) N
() N
(/* stub for integer  floor, ceiling, round, truncate */) c n
(void) k
( Istet \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, x\);) N
(}) N
() N
(/* num1  ceiling  num2) c n
(   ceiling of num1 */) N
(void) k
( Rceiling \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(ceil\(x.real_.val\)\)\);) N
(}) N
() N
(/* num1  floor  num2) c n
(   floor of num1 */) N
(opm.c) (Page 2/5) (Sep 01, 13 4:11) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( Rfloor \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(floor\(x.real_.val\)\)\);) N
(}) N
() N
(/* num1  round  num2) c n
(   round num1 to nearest integer */) N
(void) k
( Rround \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(floor\(x.real_.val + 0.5\)\)\);) N
(#if) K
( 0) p n
(    ) S
(if) K
( \(x.real_.val > 0\)) p n
(        push\(ctx->lo, ctx->os, consreal\(round\(x.real_.val\)\)\);) N
(    ) S
(else) K n
(        push\(ctx->lo, ctx->os, consreal\(rint\(x.real_.val\)\)\);) p n
(#endif) K n
(}) p n
() N
(/* num1  truncate  num2) c n
(   remove fractional part of num1 */) N
(void) k
( Rtruncate \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(trunc\(x.real_.val\)\)\);) N
(}) N
() N
(/* num1  sqrt  num2) c n
(   square root of num1 */) N
(void) k
( Rsqrt \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(sqrt\(x.real_.val\)\)\);) N
(}) N
() N
(/* num den  atan  angle) c n
(   arctangent of num/den in degrees */) N
(void) k
( Ratan \(context *ctx, object num, object den\) {) p n
(    real ang = atan2\(num.real_.val * RAD_PER_DEG, den.real_.val * RAD_PER_DEG\) /) N
( RAD_PER_DEG;) N
(    ) S
(if) K
( \(ang < 0.0\) ang += 360.0;) p n
(    push\(ctx->lo, ctx->os, consreal\(ang\)\);) N
(}) N
() N
(/* angle  cos  real) c n
(   cosine of angle \(degrees\) */) N
(void) k
( Rcos \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os,) N
(            consreal\(cos\(RAD_PER_DEG * x.real_.val\)\)\);) N
(}) N
() N
(/* angle  sin  real) c n
(   sine of angle \(degrees\) */) N
(void) k
( Rsin \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os,) N
(            consreal\(sin\(RAD_PER_DEG * x.real_.val\)\)\);) N
(}) N
() N
(/* base exponent  exp  real) c n
(   raise base to exponent power */) N
(void) k
( Rexp \(context *ctx, object base, object expn\) {) p n
(    ) S
(if) K
( \(base.real_.val < 0\)) p n
(        expn.real_.val = trunc\(expn.real_.val\);) N
(    push\(ctx->lo, ctx->os,) N
(            consreal\(pow\(base.real_.val, expn.real_.val\)\)\);) N
(}) N
() N
(/* num  ln  real) c n
(   natural logarithm of num */) N
(void) k
( Rln \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, consreal\(log\(x.real_.val\)\)\);) N
(}) N
() N
(/* num  log  real) c n
(   logarithm \(base 10\) */) N
(void) k
( Rlog \(context *ctx, object x\) {) p n
(opm.c) (Page 3/5) (Sep 01, 13 4:11) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opm.c) (50/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4-5) 51
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    push\(ctx->lo, ctx->es, consreal\(log10\(x.real_.val\)\)\);) p n
(}) N
() N
(/* -  rand  int) c n
(   generate pseudo-random integer */) N
(void) k
( Zrand \(context *ctx\) {) p n
(    ) S
(unsigned) k
( x;) p n
(    ctx->rand_next = ctx->rand_next * 1103515245 + 12345;) N
(    x = ctx->rand_next << 16;) N
(    ctx->rand_next = ctx->rand_next * 1103515245 + 12345;) N
(    x |= ctx->rand_next & 0xffff;) N
(    push\(ctx->lo, ctx->es, consint\(x & 0x7fffffff\)\);) N
(}) N
() N
(/* int  srand  -) c n
(   set random number seed */) N
(void) k
( Isrand \(context *ctx, object seed\) {) p n
(    ctx->rand_next = seed.int_.val;) N
(}) N
() N
(/* -  rrand  int) c n
(   return random number seed */) N
(void) k
( Zrrand \(context *ctx\) {) p n
(    push\(ctx->lo, ctx->es, consint\(ctx->rand_next\)\);) N
(}) N
() N
(void) k
( initopm \(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    RAD_PER_DEG = PI / 180.0;) N
() N
(    op = consoper\(ctx, ") S
(add) str
(", Iadd, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(add) str
(", Radd, 1, 2, floattype, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(sub) str
(", Isub, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(sub) str
(", Rsub, 1, 2, floattype, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(mul) str
(", Imul, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(mul) str
(", Rmul, 1, 2, floattype, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(idiv) str
(", Iidiv, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(div) str
(", Rdiv, 1, 2, floattype, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(mod) str
(", Imod, 1, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(abs) str
(", Iabs, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(abs) str
(", Rabs, 1, 1, realtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(neg) str
(", Ineg, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(neg) str
(", Rneg, 1, 1, realtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(floor) str
(", Istet, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(floor) str
(", Rfloor, 1, 1, realtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(ceiling) str
(", Istet, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(ceiling) str
(", Rceiling, 1, 1, realtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(round) str
(", Istet, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(round) str
(", Rround, 1, 1, realtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(truncate) str
(", Istet, 1, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(truncate) str
(", Rtruncate, 1, 1, realtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(sqrt) str
(", Rsqrt, 1, 1, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(atan) str
(", Ratan, 1, 2, floattype, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cos) str
(", Rcos, 1, 1, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(sin) str
(", Rsin, 1, 1, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(exp) str
(", Rexp, 1, 2, floattype, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(ln) str
(", Rln, 1, 1, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(log) str
(", Rlog, 1, 1, floattype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(rand) str
(", Zrand, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(srand) str
(", Isrand, 0, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(rrand) str
(", Zrrand, 1, 0\); INSTALL;) p n
() N
(    ) S
(/* op = consoper\(ctx, "eq", Aeq, 1, 2, anytype, anytype\); INSTALL;) c n
(    //dumpdic\(ctx->gl, sd\); fflush\(NULL\);) N
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\); */) N
(}) p n
(opm.c) (Page 4/5) (Sep 01, 13 4:11) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(opm.c) (Page 5/5) (Sep 01, 13 4:11) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opm.c) (51/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 52
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL strtod */) c n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(opar.h) str
(") p n
() N
(void) k
( packedarray \(context *ctx, object n\) {) p n
(    ) S
(int) k
( i;) p n
(    object a, v;) N
(    a = consbar\(ctx, n.int_.val\);) N
(    ) N
(    ) S
(for) K
( \(i=n.int_.val; i > 0; i--\) {) p n
(        v = pop\(ctx->lo, ctx->os\);) N
(        barput\(ctx, a, i-1, v\);) N
(    }) N
(    a = setfaccess\(cvlit\(a\), readonly\);) N
(    push\(ctx->lo, ctx->os, a\);) N
(}) N
() N
(void) k
( setpacking \(context *ctx, object b\) {) p n
(    object sd = bot\(ctx->lo, ctx->ds, 0\);) N
(    bdcput\(ctx, sd, consname\(ctx, ") S
(currentpacking) str
("\), b\);) p n
(}) N
() N
(void) k
( initoppa\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(packedarray) str
(", packedarray, 1, 1, integertype\); INSTALL;) p n
(    bdcput\(ctx, sd, consname\(ctx, ") S
(currentpacking) str
("\), consbool\(false\)\);) p n
(    op = consoper\(ctx, ") S
(setpacking) str
(", setpacking, 0, 1, booleantype\); INSTALL;) p n
() N
(    ) S
(/* dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\); */) N
() p n
(}) N
() N
() N
(oppa.c) (Page 1/1) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(ops.h) str
(") p n
() N
(/* any  pop  -) c n
(   discard top element */) N
(void) k
( Apop \(context *ctx, object x\) {) p n
(    \() S
(void) k
(\)ctx;) p n
(    \() S
(void) k
(\)x;) p n
(}) N
() N
(/* any1 any2  exch  any2 any1) c n
(   exchange top two elements */) N
(void) k
( AAexch \(context *ctx, object x, object y\) {) p n
(    push\(ctx->lo, ctx->os, y\);) N
(    push\(ctx->lo, ctx->os, x\);) N
(}) N
() N
(/* any  dup  any any) c n
(   duplicate top element */) N
(void) k
( Adup \(context *ctx, object x\) {) p n
(    push\(ctx->lo, ctx->os, x\);) N
(    push\(ctx->lo, ctx->os, x\);) N
(}) N
() N
(/* any1..anyN N  copy  any1..anyN any1..anyN) c n
(   duplicate top n elements */) N
(void) k
( Icopy \(context *ctx, object n\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(if) K
( \(n.int_.val < 0\) error\(rangecheck, ") p
(Icopy) str
("\);) p n
(    ) S
(if) K
( \(\() p
(unsigned) k
(\)n.int_.val > count\(ctx->lo, ctx->os\)\) error\(stackunderflow, ") p
(I) str n
(copy) S
("\);) p n
(    ) S
(for) K
( \(i=0; i < n.int_.val; i++\)) p n
(        push\(ctx->lo, ctx->os, top\(ctx->lo, ctx->os, n.int_.val - 1\)\);) N
(}) N
() N
(/* anyN..any0 N  index  anyN..any0 anyN) c n
(   duplicate arbitrary element */) N
(void) k
( Iindex \(context *ctx, object n\) {) p n
(    ) S
(if) K
( \(n.int_.val < 0\) error\(rangecheck, ") p
(Iindex) str
("\);) p n
(    ) S
(if) K
( \(\() p
(unsigned) k
(\)n.int_.val >= count\(ctx->lo, ctx->os\)\) error\(stackunderflow, ") p
() str n
(Iindex) S
("\);) p n
(    ) S
(//printf\("index %d\\n", n.int_.val\);) c n
(    push\(ctx->lo, ctx->os, top\(ctx->lo, ctx->os, n.int_.val\)\);) p n
(}) N
() N
(/* a\(n-1\)..a\(0\) n j  roll  a\(\(j-1\)mod n\)..a\(0\) a\(n-1\)..a\(j mod n\)) c n
(   roll n elements j times */) N
(void) k
( IIroll \(context *ctx, object N, object J\) {) p n
(    object *t;) N
(    ) S
(int) k
( i;) p n
(    ) S
(int) k
( n = N.int_.val;) p n
(    ) S
(int) k
( j = J.int_.val;) p n
(    ) S
(if) K
( \(n < 0\) error\(rangecheck, ") p
(IIroll) str
("\);) p n
(    ) S
(if) K
( \(n == 0\) ) p
(return) K
(;) p n
(    ) S
(if) K
( \(j < 0\) j = n - \( \(- j\) % n\);) p n
(    j %= n;) N
(ops.c) (Page 1/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(oppa.c, ops.c) (52/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 53
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(if) K
( \(j == 0\) ) p
(return) K
(;) p n
(    ) N
(    t = alloca\(\(n-j\) * ) S
(sizeof) K
(\(object\)\);) p n
(    ) S
(for) K
( \(i = 0; i < n-j; i++\)) p n
(        t[i] = top\(ctx->lo, ctx->os, n - 1 - i\);) N
(    ) S
(for) K
( \(i = 0; i < j; i++\)) p n
(        pot\(ctx->lo, ctx->os, n - 1 - i,) N
(                top\(ctx->lo, ctx->os, j - 1 - i\)\);) N
(    ) S
(for) K
( \(i = 0; i < n-j; i++\)) p n
(        pot\(ctx->lo, ctx->os, n - j - 1 - i, t[i]\);) N
(}) N
() N
(/* |- any1..anyN  clear  |-) c n
(   discard all elements */) N
(void) k
( Zclear \(context *ctx\) {) p n
(    stack *s = \() S
(void) k
( *\)\(ctx->lo->base + ctx->os\);) p n
(    s->top = 0;) N
(}) N
() N
(/* |- any1..anyN  count  |- any1..anyN N) c n
(   count elements on stack */) N
(void) k
( Zcount \(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, consint\(count\(ctx->lo, ctx->os\)\)\);) N
(}) N
() N
(/* -  mark  mark) c n
(   push mark on stack */) N
(/* the name "mark" is defined in systemdict as a marktype object */) N
() p n
(/* mark obj1..objN  cleartomark  -) c n
(   discard elements down through mark */) N
(void) k
( Zcleartomark \(context *ctx\) {) p n
(    object o;) N
(    ) S
(do) K
( {) p n
(        o = pop\(ctx->lo, ctx->os\);) N
(    } ) S
(while) K
( \(o.tag != marktype\);) p n
(}) N
() N
(/* mark obj1..objN  counttomark  N) c n
(   count elements down to mark */) N
(void) k
( Zcounttomark \(context *ctx\) {) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(unsigned) k
( z;) p n
(    z = count\(ctx->lo, ctx->os\);) N
(    ) S
(for) K
( \(i = 0; i < z; i++\) {) p n
(        ) S
(if) K
( \(top\(ctx->lo, ctx->os, i\).tag == marktype\) {) p n
(            push\(ctx->lo, ctx->os, consint\(i\)\);) N
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
(    error\(unmatchedmark, ") S
(Zcounttomark) str
("\);) p n
(}) N
() N
(/*) c n
(   -  currentcontext  context) N
(   return current context identifier) N
() N
(   mark obj1..objN proc  fork  context) N
(   create context executing proc with obj1..objN as operands) N
() N
(   context  join  mark obj1..objN) N
(   await context termination and return its results) N
() N
(   context  detach  -) N
(   enable context to terminate immediately when done) N
() N
(   -  lock  lock) N
(   create lock object) N
() N
(ops.c) (Page 2/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(   lock proc  monitor  -) c n
(   execute proc while holding lock) N
() N
(   -  condition  condition) N
(   create condition object) N
() N
(   local condition  wait  -) N
(   release lock, wait for condition, reacquire lock) N
() N
(   condition  notify  -) N
(   resume contexts waiting for condition) N
() N
(   -  yield  -) N
(   suspend current context momentarily) N
(   */) N
() p n
(void) k
( initops\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    op = consoper\(ctx, ") S
(pop) str
(", Apop, 0, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(exch) str
(", AAexch, 2, 2, anytype, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(dup) str
(", Adup, 2, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(copy) str
(", Icopy, 0, 1, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(index) str
(", Iindex, 1, 1, integertype\); INSTALL;) p n
(    ) S
(//dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(    op = consoper\(ctx, ") p
(roll) str
(", IIroll, 0, 2, integertype, integertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(clear) str
(", Zclear, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(count) str
(", Zcount, 1, 0\); INSTALL;) p n
(    bdcput\(ctx, sd, consname\(ctx, ") S
(mark) str
("\), mark\);) p n
(    op = consoper\(ctx, ") S
(cleartomark) str
(", Zcleartomark, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(counttomark) str
(", Zcounttomark, 1, 0\); INSTALL;) p n
(}) N
(ops.c) (Page 3/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(ops.c) (53/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 54
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h> ) p
(/* ob.h:bool */) c n
(#include) K
( <stdio.h> ) p
(/* printf */) c n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(void) k
( Istring\(context *ctx, object I\) {) p n
(    push\(ctx->lo, ctx->os, cvlit\(consbst\(ctx, I.int_.val, ) S
(NULL) K
(\)\)\);) p n
(}) N
() N
(void) k
( Slength\(context *ctx, object S\) {) p n
(    push\(ctx->lo, ctx->os, consint\(S.comp_.sz\)\);) N
(}) N
() N
(void) k
( s_copy\(context *ctx, object S, object D\) {) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(for) K
( \(i = 0; i < S.comp_.sz; i++\)) p n
(        bstput\(ctx, D, i, bstget\(ctx, S, i\)\);) N
(}) N
() N
(void) k
( Scopy\(context *ctx, object S, object D\) {) p n
(    ) S
(if) K
( \(D.comp_.sz < S.comp_.sz\) error\(rangecheck, ") p
(Scopy) str
("\);) p n
(    s_copy\(ctx, S, D\);) N
(    push\(ctx->lo, ctx->os, arrgetinterval\(D, 0, S.comp_.sz\)\);) N
(}) N
() N
(void) k
( Sget\(context *ctx, object S, object I\) {) p n
(    push\(ctx->lo, ctx->os, consint\(bstget\(ctx, S, I.int_.val\)\)\);) N
(}) N
() N
(void) k
( Sput\(context *ctx, object S, object I, object C\) {) p n
(    bstput\(ctx, S, I.int_.val, C.int_.val\);) N
(}) N
() N
(void) k
( Sgetinterval\(context *ctx, object S, object I, object L\) {) p n
(    push\(ctx->lo, ctx->os, arrgetinterval\(S, I.int_.val, L.int_.val\)\);) N
(}) N
() N
(void) k
( Sputinterval\(context *ctx, object D, object I, object S\) {) p n
(    s_copy\(ctx, S, arrgetinterval\(D, I.int_.val, S.comp_.sz\)\);) N
(}) N
() N
(int) k
( ancsearch\() p
(char) k
( *str, ) p
(char) k
( *seek, ) p
(int) k
( seekn\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(for) K
( \(i = 0; i < seekn; i++\)) p n
(        ) S
(if) K
( \(str[i] != seek[i]\)) p n
(            ) S
(return) K
( false;) p n
(    ) S
(return) K
( true;) p n
(}) N
() N
(void) k
( Sanchorsearch\(context *ctx, object str, object seek\) {) p n
(    ) S
(char) k
( *s, *k;) p n
(    ) S
(if) K
( \(seek.comp_.sz > str.comp_.sz\) error\(rangecheck, ") p
(Sanchorsearch) str
("\);) p n
(    s = charstr\(ctx, str\);) N
(    k = charstr\(ctx, seek\);) N
(    ) S
(if) K
( \(ancsearch\(s, k, seek.comp_.sz\)\) {) p n
(        push\(ctx->lo, ctx->os,) N
(                arrgetinterval\(str, seek.comp_.sz, ) N
(                    str.comp_.sz - seek.comp_.sz\)\); ) S
(/* post */) c n
(        push\(ctx->lo, ctx->os,) p n
(opst.c) (Page 1/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                arrgetinterval\(str, 0, seek.comp_.sz\)\); ) p
(/* match */) c n
(        push\(ctx->lo, ctx->os, consbool\(true\)\);) p n
(    } ) S
(else) K
( {) p n
(        push\(ctx->lo, ctx->os, str\);) N
(        push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(    }) N
(}) N
() N
(void) k
( Ssearch\(context *ctx, object str, object seek\) {) p n
(    ) S
(int) k
( i;) p n
(    ) S
(char) k
( *s, *k;) p n
(    ) S
(if) K
( \(seek.comp_.sz > str.comp_.sz\) error\(rangecheck, ") p
(Ssearch) str
("\);) p n
(    s = charstr\(ctx, str\);) N
(    k = charstr\(ctx, seek\);) N
(    ) S
(for) K
( \(i = 0; i <= \(str.comp_.sz - seek.comp_.sz\); i++\) {) p n
(        ) S
(if) K
( \(ancsearch\(s+i, k, seek.comp_.sz\)\) {) p n
(            push\(ctx->lo, ctx->os, ) N
(                    arrgetinterval\(str, i + seek.comp_.sz,) N
(                        str.comp_.sz - seek.comp_.sz - i\)\); ) S
(/* post */) c n
(            push\(ctx->lo, ctx->os,) p n
(                    arrgetinterval\(str, i, seek.comp_.sz\)\); ) S
(/* match */) c n
(            push\(ctx->lo, ctx->os,) p n
(                    arrgetinterval\(str, 0, i\)\); ) S
(/* pre */) c n
(            push\(ctx->lo, ctx->os, consbool\(true\)\);) p n
(            ) S
(return) K
(;) p n
(        }) N
(    }) N
(    push\(ctx->lo, ctx->os, str\);) N
(    push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(}) N
() N
(void) k
( Sforall\(context *ctx, object S, object P\) {) p n
(    ) S
(if) K
( \(S.comp_.sz == 0\) ) p
(return) K
(;) p n
(    assert\(ctx->gl->base\);) N
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(forall) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, consoper\(ctx, ") S
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, cvlit\(P\)\);) N
(    push\(ctx->lo, ctx->es, cvlit\(arrgetinterval\(S, 1, S.comp_.sz-1\)\)\);) N
(    ) S
(if) K
( \(isx\(S\)\) push\(ctx->lo, ctx->es, consoper\(ctx, ") p
(cvx) str
(", ) p
(NULL) K
(,0,0\)\);) p n
(    push\(ctx->lo, ctx->es, P\);) N
(    push\(ctx->lo, ctx->es, consint\(bstget\(ctx, S, 0\)\)\);) N
(}) N
() N
(// token : see optok.c) c n
() p n
(void) k
( initopst\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(    op = consoper\(ctx, ") S
(string) str
(", Istring, 1, 1,) p n
(            integertype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(length) str
(", Slength, 1, 1,) p n
(            stringtype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(copy) str
(", Scopy, 1, 2,) p n
(            stringtype, stringtype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(get) str
(", Sget, 1, 2,) p n
(            stringtype, integertype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(put) str
(", Sput, 0, 3,) p n
(            stringtype, integertype, integertype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(getinterval) str
(", Sgetinterval, 1, 3,) p n
(            stringtype, integertype, integertype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(putinterval) str
(", Sputinterval, 0, 3,) p n
(            stringtype, integertype, stringtype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(anchorsearch) str
(", Sanchorsearch, 3, 2,) p n
(            stringtype, stringtype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(search) str
(", Ssearch, 4, 2,) p n
(            stringtype, stringtype\); INSTALL;) N
(    op = consoper\(ctx, ") S
(forall) str
(", Sforall, 0, 2,) p n
(opst.c) (Page 2/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opst.c) (54/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3,1) 55
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            stringtype, proctype\); INSTALL;) p n
(    ) S
(//bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\);) c n
(}) p n
() N
(opst.c) (Page 3/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <limits.h>) p n
(#include) K
( <math.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL strtod */) c n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(void) k
( Atype\(context *ctx, object o\) {) p n
(    push\(ctx->lo, ctx->os, cvx\(consname\(ctx, types[type\(o\)]\)\)\);) N
(}) N
() N
(void) k
( Acvlit\(context *ctx, object o\){) p n
(    push\(ctx->lo, ctx->os, cvlit\(o\)\);) N
(}) N
() N
(void) k
( Acvx\(context *ctx, object o\){) p n
(    push\(ctx->lo, ctx->os, cvx\(o\)\);) N
(}) N
() N
(void) k
( Axcheck\(context *ctx, object o\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(isx\(o\)\)\);) N
(}) N
() N
(void) k
( Aexecuteonly\(context *ctx, object o\) {) p n
(    o.tag &= ~FACCESS;) N
(    o.tag |= \(executeonly << FACCESSO\);) N
(    push\(ctx->lo, ctx->os, o\);) N
(}) N
() N
(void) k
( Anoaccess\(context *ctx, object o\) {) p n
(    o.tag &= ~FACCESS;) N
(    o.tag |= \(noaccess << FACCESSO\);) N
(    push\(ctx->lo, ctx->os, o\);) N
(}) N
() N
(void) k
( Areadonly\(context *ctx, object o\) {) p n
(    o.tag &= ~FACCESS;) N
(    o.tag |= \(readonly << FACCESSO\);) N
(    push\(ctx->lo, ctx->os, o\);) N
(}) N
() N
(void) k
( Archeck\(context *ctx, object o\) {) p n
(    push\(ctx->lo, ctx->os, consbool\( \(o.tag & FACCESS\) >> FACCESSO >= readonly \)) N
(\);) N
(}) N
() N
(void) k
( Awcheck\(context *ctx, object o\) {) p n
(    push\(ctx->lo, ctx->os, consbool\( \(o.tag & FACCESS\) >> FACCESSO == unlimited ) N
(\)\);) N
(}) N
() N
(void) k
( Ncvi\(context *ctx, object n\) {) p n
(    ) S
(if) K
( \(type\(n\) == realtype\)) p n
(        n = consint\(n.real_.val\);) N
(    push\(ctx->lo, ctx->os, n\);) N
(}) N
(opt.c) (Page 1/5) (Aug 18, 13 20:35) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opst.c, opt.c) (55/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 56
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(void) k
( Scvi\(context *ctx, object s\) {) p n
(    ) S
(double) k
( dbl;) p n
(    ) S
(long) k
( num;) p n
(    ) S
(char) k
( *t = alloca\(s.comp_.sz+1\);) p n
(    memcpy\(t, charstr\(ctx, s\), s.comp_.sz\);) N
(    t[s.comp_.sz] = ') S
(\\0) str
(';) p n
() N
(    dbl = strtod\(t, ) S
(NULL) K
(\);) p n
(    ) S
(if) K
( \(\(dbl == HUGE_VAL || dbl -HUGE_VAL\) && errno==ERANGE\)) p n
(        error\(limitcheck, ") S
(Scvr) str
("\);) p n
(    ) S
(if) K
( \(dbl >= LONG_MAX || dbl <= LONG_MIN\)) p n
(        error\(limitcheck, ") S
(Scvi) str
("\);) p n
(    num = dbl;) N
() N
(    ) S
(/*) c n
(    num = strtol\(t, NULL, 10\);) N
(    if \(\(num == LONG_MAX || num == LONG_MIN\) && errno==ERANGE\)) N
(        error\(limitcheck, "Scvi"\);) N
(    */) N
() p n
(    push\(ctx->lo, ctx->os, consint\(num\)\);) N
(}) N
() N
(void) k
( Scvn\(context *ctx, object s\) {) p n
(    ) S
(char) k
( *t = alloca\(s.comp_.sz+1\);) p n
(    memcpy\(t, charstr\(ctx, s\), s.comp_.sz\);) N
(    t[s.comp_.sz] = ') S
(\\0) str
(';) p n
(    push\(ctx->lo, ctx->os, consname\(ctx, t\)\);) N
(}) N
() N
(void) k
( Ncvr\(context *ctx, object n\) {) p n
(    ) S
(if) K
( \(type\(n\) == integertype\)) p n
(        n = consreal\(n.int_.val\);) N
(    push\(ctx->lo, ctx->os, n\);) N
(}) N
() N
(void) k
( Scvr\(context *ctx, object str\) {) p n
(    ) S
(double) k
( num;) p n
(    ) S
(char) k
( *s = alloca\(str.comp_.sz + 1\);) p n
(    memcpy\(s, charstr\(ctx, str\), str.comp_.sz\);) N
(    s[str.comp_.sz] = ') S
(\\0) str
(';) p n
(    num = strtod\(s, ) S
(NULL) K
(\);) p n
(    ) S
(if) K
( \(\(num == HUGE_VAL || num -HUGE_VAL\) && errno==ERANGE\)) p n
(        error\(limitcheck, ") S
(Scvr) str
("\);) p n
(    push\(ctx->lo, ctx->os, consreal\(num\)\);) N
(}) N
() N
(int) k
( conv_rad\() p
(int) k
( num, ) p
(int) k
( rad, ) p
(char) k
( *s, ) p
(int) k
( n\) {) p n
(    ) S
(char) k
( *vec = ") p
(0123456789) str
(" ") p
(ABCDEFGHIJKLM) str
(" ") p
(NOPQRSTUVWXYZ) str
(";) p n
(    ) S
(int) k
( off;) p n
(    ) S
(if) K
( \(n == 0\) ) p
(return) K
( 0;) p n
(    ) S
(if) K
( \(num < rad\) {) p n
(        *s = vec[num];) N
(        ) S
(return) K
( 1;) p n
(    }) N
(    off = conv_rad\(num/rad, rad, s, n\);) N
(    ) S
(if) K
( \(\(off == n\) || \(off == -1\)\) ) p
(return) K
( -1;) p n
(    s[off] = vec[num%rad];) N
(    ) S
(return) K
( off+1;) p n
(}) N
() N
(void) k
( NRScvrs\(context *ctx, object num, object rad, object str\) {) p n
(    ) S
(int) k
( r, n;) p n
(    ) S
(if) K
( \(type\(num\) == realtype\) num = consint\(num.real_.val\);) p n
(    r = rad.int_.val;) N
(    ) S
(if) K
( \(r < 2 || r > 36\) error\(rangecheck, ") p
(NRScvrs) str
("\);) p n
(    n = conv_rad\(num.int_.val, r, charstr\(ctx, str\), str.comp_.sz\);) N
(    ) S
(if) K
( \(n == -1\) error\(rangecheck, ") p
(NRScvrs) str
("\);) p n
(opt.c) (Page 2/5) (Aug 18, 13 20:35) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(if) K
( \(n < str.comp_.sz\) str.comp_.sz = n;) p n
(    push\(ctx->lo, ctx->os, str\);) N
(}) N
() N
(int) k
( conv_integ\(real num, ) p
(char) k
( *s, ) p
(int) k
( n\) {) p n
(    ) S
(int) k
( off;) p n
(    ) S
(if) K
( \(num < 10.0\) {) p n
(        *s = \(\() S
(int) k
(\)num\) + ') p
(0) str
(';) p n
(        ) S
(return) K
( 1;) p n
(    }) N
(    off = conv_integ\(num/10.0, s, n\);) N
(    ) S
(if) K
( \(\(off == n\) || \(off == -1\)\) ) p
(return) K
( -1;) p n
(    s[off] = \(\(\() S
(int) k
(\)num\)%10\) + ') p
(0) str
(';) p n
(    ) S
(return) K
( off + 1;) p n
(}) N
() N
(int) k
( conv_frac\(real num, ) p
(char) k
( *s, ) p
(int) k
( n\) {) p n
(    real integ, frac;) N
(    num *= 10.0;) N
(    integ = floor\(num\);) N
(    frac = num - integ;) N
(    *s = \() S
(int) k
(\)integ + ') p
(0) str
(';) p n
(    ) S
(//if \(num == 0.0\) return 1;) c n
(    ) p
(if) K
( \(num < 0.0001\) ) p
(return) K
( 1;) p n
(    ) S
(return) K
( 1 + conv_frac\(frac, s+1, n-1\);) p n
(}) N
() N
(int) k
( conv_real\(real num, ) p
(char) k
( *s, ) p
(int) k
( n\) {) p n
(    ) S
(int) k
( off = 0;) p n
(    real integ, frac;) N
(    ) S
(if) K
( \(n == 0\) ) p
(return) K
( -1;) p n
(    ) S
(if) K
( \(isinf\(num\)\){) p n
(        ) S
(if) K
( \(n < 3\) ) p
(return) K
( -1;) p n
(        memcpy\(s, ") S
(inf) str
(", 3\);) p n
(        ) S
(return) K
( 3;) p n
(    }) N
(    ) S
(if) K
( \(isnan\(num\)\){) p n
(        ) S
(if) K
( \(n < 3\) ) p
(return) K
( -1;) p n
(        memcpy\(s, ") S
(nan) str
(", 3\);) p n
(        ) S
(return) K
( 3;) p n
(    }) N
(    ) S
(if) K
( \(num < 0\) {) p n
(        num = fabs\(num\);) N
(        s[off++] = ') S
(-) str
(';) p n
(    }) N
(    integ = floor\(num\);) N
(    frac = num - integ;) N
(    off += conv_integ\(integ, s+off, n\);) N
(    s[off++] = ') S
(.) str
(';) p n
(    off += conv_frac\(frac, s+off, n-off\);) N
(    ) S
(return) K
( off;) p n
(}) N
() N
(void) k
( AScvs\(context *ctx, object any, object str\) {) p n
(    ) S
(char) k
( nostringval[] = ") p
(-nostringval-) str
(";) p n
(    ) S
(char) k
( strue[] = ") p
(true) str
(";) p n
(    ) S
(char) k
( sfalse[] = ") p
(false) str
(";) p n
(    ) S
(char) k
( smark[] = ") p
(-mark-) str
(";) p n
(    ) S
(int) k
( n;) p n
() N
(    ) S
(switch) K
(\(type\(any\)\) {) p n
(    ) S
(default) K
(:) p n
(        ) S
(if) K
( \(str.comp_.sz < ) p
(sizeof) K
(\(nostringval\)-1\) error\(rangecheck, ") p
(AScvs) str
("\);) p n
(        memcpy\(charstr\(ctx, str\), nostringval, ) S
(sizeof) K
(\(nostringval\)-1\);) p n
(        str.comp_.sz = ) S
(sizeof) K
(\(nostringval\)-1;) p n
(        ) S
(break) K
(;) p n
(    ) S
(case) K
( marktype:) p n
(        ) S
(if) K
( \(str.comp_.sz < ) p
(sizeof) K
(\(smark\)-1\) error\(rangecheck, ") p
(AScvs) str
("\);) p n
(        memcpy\(charstr\(ctx, str\), smark, ) S
(sizeof) K
(\(smark\)-1\);) p n
(opt.c) (Page 3/5) (Aug 18, 13 20:35) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opt.c) (56/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4-5) 57
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        str.comp_.sz = ) p
(sizeof) K
(\(smark\)-1;) p n
(        ) S
(break) K
(;) p n
() N
(    ) S
(case) K
( booleantype:) p n
(        {) N
(            ) S
(if) K
( \(any.int_.val\) {) p n
(                ) S
(if) K
( \(str.comp_.sz < ) p
(sizeof) K
(\(strue\)-1\) error\(rangecheck, ") p
(AScvs boole) str n
(antype case) S
("\);) p n
(                memcpy\(charstr\(ctx, str\), strue, ) S
(sizeof) K
(\(strue\)-1\);) p n
(                str.comp_.sz = ) S
(sizeof) K
(\(strue\)-1;) p n
(            } ) S
(else) K
( {) p n
(                ) S
(if) K
( \(str.comp_.sz < ) p
(sizeof) K
(\(sfalse\)-1\) error\(rangecheck, ") p
(AScvs bool) str n
(eantype case) S
("\);) p n
(                memcpy\(charstr\(ctx, str\), sfalse, ) S
(sizeof) K
(\(sfalse\)-1\);) p n
(                str.comp_.sz = ) S
(sizeof) K
(\(sfalse\)-1;) p n
(            }) N
(        }) N
(        ) S
(break) K
(;) p n
(    ) S
(case) K
( integertype:) p n
(        n = conv_rad\(any.int_.val, 10, charstr\(ctx, str\), str.comp_.sz\);) N
(        ) S
(if) K
( \(n == -1\) error\(rangecheck, ") p
(AScvs integertype case) str
("\);) p n
(        ) S
(if) K
( \(n < str.comp_.sz\) str.comp_.sz = n;) p n
(        ) S
(break) K
(;) p n
(    ) S
(case) K
( realtype:) p n
(        n = conv_real\(any.real_.val, charstr\(ctx, str\), str.comp_.sz\);) N
(        ) S
(if) K
( \(n == -1\) error\(rangecheck, ") p
(AScvs realtype case) str
("\);) p n
(        ) S
(if) K
( \(n < str.comp_.sz\) str.comp_.sz = n;) p n
(        ) S
(break) K
(;) p n
() N
(    ) S
(case) K
( operatortype:) p n
(        {) N
(            oper *optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(            oper op = optab[any.mark_.padw];) N
(            mark_ nm = { nametype | FBANK, 0, op.name };) N
(            any.mark_ = nm;) N
(        }) N
(        ) S
(/*@fallthrough@*/) c n
(    ) p
(case) K
( nametype:) p n
(        any = strname\(ctx, any\);) N
(        ) S
(/*@fallthrough@*/) c n
(    ) p
(case) K
( stringtype:) p n
(        ) S
(if) K
( \(any.comp_.sz > str.comp_.sz\) error\(rangecheck, ") p
(AScvs stringtype case) str
("\);) p n
(        ) S
(if) K
( \(any.comp_.sz < str.comp_.sz\) str.comp_.sz = any.comp_.sz;) p n
(        memcpy\(charstr\(ctx, str\), charstr\(ctx, any\), any.comp_.sz\);) N
(        ) S
(break) K
(;) p n
(    }) N
() N
(    push\(ctx->lo, ctx->os, str\);) N
(}) N
() N
(void) k
( initopt\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(type) str
(", Atype, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvlit) str
(", Acvlit, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvx) str
(", Acvx, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(xcheck) str
(", Axcheck, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(executeonly) str
(", Aexecuteonly, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(noaccess) str
(", Anoaccess, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(readonly) str
(", Areadonly, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(rcheck) str
(", Archeck, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(wcheck) str
(", Awcheck, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvi) str
(", Ncvi, 1, 1, numbertype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvi) str
(", Scvi, 1, 1, stringtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvn) str
(", Scvn, 1, 1, stringtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvr) str
(", Ncvr, 1, 1, numbertype\); INSTALL;) p n
(opt.c) (Page 4/5) (Aug 18, 13 20:35) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    op = consoper\(ctx, ") p
(cvr) str
(", Scvr, 1, 1, stringtype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(cvrs) str
(", NRScvrs, 1, 3, numbertype, integertype, stringtype) p n
(\); INSTALL;) N
(    op = consoper\(ctx, ") S
(cvs) str
(", AScvs, 1, 2, anytype, stringtype\); INSTALL;) p n
() N
(    ) S
(/* dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\); */) N
(}) p n
() N
() N
(opt.c) (Page 5/5) (Aug 18, 13 20:35) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opt.c) (57/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 58
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <ctype.h>) p n
(#include) K
( <errno.h> ) p
(/* errno */) c n
(#include) K
( <limits.h>) p n
(#include) K
( <math.h>) p n
(#include) K
( <stdbool.h> ) p
(/* ob.h:bool */) c n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <string.h> ) p
(/* strchr */) c n
() p n
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(f.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(opar.h) str
(") p n
(#include) K
( ") p
(opdi.h) str
(") p n
(#include) K
( ") p
(optok.h) str
(") p n
() N
(enum) k
( { NBUF = BUFSIZ };) p n
() N
(int) k
( puff \(context *ctx, ) p
(char) k
( *buf, ) p
(int) k
( nbuf, object *src,) p n
(        ) S
(int) k
( \(*next\)\(context *ctx, object *src\),) p n
(        ) S
(void) k
( \(*back\)\(context *ctx, ) p
(int) k
( c, object *src\)\);) p n
(object toke \(context *ctx, object *src,) N
(        ) S
(int) k
( \(*next\)\(context *ctx, object *src\),) p n
(        ) S
(void) k
( \(*back\)\(context *ctx, ) p
(int) k
( c, object *src\)\);) p n
() N
(int) k
( ishash \() p
(int) k
( c\) { ) p
(return) K
( c == ') p
(#) str
('; }) p n
(int) k
( isdot \() p
(int) k
( c\) { ) p
(return) K
( c == ') p
(.) str
('; }) p n
(int) k
( ise \() p
(int) k
( c\) { ) p
(return) K
( strchr\(") p
(eE) str
(", c\) != ) p
(NULL) K
(; }) p n
(int) k
( issign \() p
(int) k
( c\) { ) p
(return) K
( strchr\(") p
(+-) str
(", c\) != ) p
(NULL) K
(; }) p n
(int) k
( isdel \() p
(int) k
( c\) { ) p
(return) K
( strchr\(") p
(\(\)[]<>{}/%) str
(", c\) != ) p
(NULL) K
(; }) p n
(int) k
( isreg \() p
(int) k
( c\) { ) p
(return) K
( \(c!=EOF\) && \(!isspace\(c\)\) && \(!isdel\(c\)\); }) p n
(//int isxdigit \(int c\) { return strchr\("0123456789ABCDEFabcdef", c\) != NULL; }) c n
() p n
(typedef) K
( ) p
(struct) k
( { ) p
(int) k
( \(*pred\)\() p
(int) k
(\); ) p
(int) k
( y, n; } test;) p n
() N
(test fsm_dec[] = {) N
(    ) S
(/* 0 */) c
( { issign,  1,  1 },) p n
(    ) S
(/* 1 */) c
( { isdigit, 2, -1 },) p n
(    ) S
(/* 2 */) c
( { isdigit, 2, -1 } };) p n
(int) k
( accept_dec\() p
(int) k
( i\) { ) p
(return) K
( i == 2; }) p n
() N
(test fsm_rad[] = {) N
(    ) S
(/* 0 */) c
( { isdigit, 1, -1 },) p n
(    ) S
(/* 1 */) c
( { isdigit, 1,  2 },) p n
(    ) S
(/* 2 */) c
( { ishash,  3, -1 },) p n
(    ) S
(/* 3 */) c
( { isalnum, 4, -1 },) p n
(    ) S
(/* 4 */) c
( { isalnum, 4, -1 } };) p n
(int) k
( accept_rad\() p
(int) k
( i\) { ) p
(return) K
( i == 4; }) p n
() N
(test fsm_real[] = {) N
(    ) S
(/* 0 */) c
(  { issign,  1,   1 },) p n
(    ) S
(/* 1 */) c
(  { isdigit, 2,   4 },) p n
(    ) S
(/* 2 */) c
(  { isdigit, 2,   3 },) p n
(    ) S
(/* 3 */) c
(  { isdot,   6,   7 },) p n
(    ) S
(/* 4 */) c
(  { isdot,   5,  -1 },) p n
(    ) S
(/* 5 */) c
(  { isdigit, 6,  -1 },) p n
(    ) S
(/* 6 */) c
(  { isdigit, 6,   7 },) p n
(    ) S
(/* 7 */) c
(  { ise,     8,  -1 },) p n
(    ) S
(/* 8 */) c
(  { issign,  9,   9 },) p n
(    ) S
(/* 9 */) c
(  { isdigit, 10, -1 },) p n
(optok.c) (Page 1/6) (Aug 17, 13 4:37) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(/* 10 */) c
( { isdigit, 10, -1 } };) p n
(int) k
( accept_real\() p
(int) k
( i\) {) p n
(    ) S
(switch) K
( \(i\) { ) p
(//case 2:) c n
(        ) p
(case) K
( 6: ) p
(case) K
( 10: ) p
(return) K
( true; ) p
(default) K
(: ) p
(return) K
( false; }) p n
(    ) S
(//return \(i & 3\) == 2;  // 2, 6 == 2|4, 10 == 2|8) c n
(}) p n
() N
(int) k
( fsm_check \() p
(char) k
( *s, ) p
(int) k
( ns, test *fsm,) p n
(        ) S
(int) k
( \(*accept\)\() p
(int) k
( final\)\) {) p n
(    ) S
(int) k
( sta = 0;) p n
(    ) S
(char) k
( *sp = s;) p n
(    ) S
(while) K
( \(sta != -1 && *sp\) {) p n
(        ) S
(if) K
( \(sp-s > ns\) ) p
(break) K
(;) p n
(        ) S
(if) K
( \(fsm[sta].pred\(*sp\)\) {) p n
(            sta = fsm[sta].y;) N
(            ++sp;) N
(        } ) S
(else) K
( {) p n
(            sta = fsm[sta].n;) N
(        }) N
(    }) N
(    ) S
(return) K
( accept\(sta\);) p n
(}) N
() N
(object grok \(context *ctx, ) S
(char) k
( *s, ) p
(int) k
( ns, object *src,) p n
(        ) S
(int) k
( \(*next\)\(context *ctx, object *src\),) p n
(        ) S
(void) k
( \(*back\)\(context *ctx, ) p
(int) k
( c, object *src\)\) {) p n
(    ) S
(if) K
( \(ns == NBUF\) error\(limitcheck, ") p
(grok buf maxxed) str
("\);) p n
(    s[ns] = ') S
(\\0) str
(';  ) p
(//fsm_check & consname  terminate on \\0) c n
() p n
(    ) S
(if) K
( \(fsm_check\(s, ns, fsm_dec, accept_dec\)\) {) p n
(        ) S
(long) k
( num;) p n
(        num = strtol\(s, ) S
(NULL) K
(, 10\);) p n
(        ) S
(if) K
( \(\(num == LONG_MAX || num == LONG_MIN\) && errno==ERANGE\)) p n
(            error\(limitcheck, ") S
(grok integer out of range) str
("\);) p n
(        ) S
(return) K
( consint\(num\);) p n
(    }) N
() N
(    ) S
(else) K
( ) p
(if) K
( \(fsm_check\(s, ns, fsm_rad, accept_rad\)\) {) p n
(        ) S
(long) k
( base, num;) p n
(        base = strtol\(s, &s, 10\);) N
(        ) S
(if) K
( \(base > 36 || base < 2\)) p n
(            error\(limitcheck, ") S
(grok bad radix) str
("\);) p n
(        num = strtol\(s+1, ) S
(NULL) K
(, base\);) p n
(        ) S
(if) K
( \(\(num == LONG_MAX || num == LONG_MIN\) && errno==ERANGE\)) p n
(            error\(limitcheck, ") S
(grok radixnumber out of range) str
("\);) p n
(        ) S
(return) K
( consint\(num\);) p n
(    }) N
() N
(    ) S
(else) K
( ) p
(if) K
( \(fsm_check\(s, ns, fsm_real, accept_real\)\) {) p n
(        ) S
(double) k
( num;) p n
(        num = strtod\(s, ) S
(NULL) K
(\);) p n
(        ) S
(if) K
( \(\(num == HUGE_VAL || num == -HUGE_VAL\) && errno==ERANGE\)) p n
(            error\(limitcheck, ") S
(grok real out of range) str
("\);) p n
(        ) S
(return) K
( consreal\(num\);) p n
(    }) N
() N
(    ) S
(else) K
( ) p
(switch) K
(\(*s\) {) p n
() N
(    ) S
(case) K
( ') p
(\() str
(': {) p n
(                  ) S
(int) k
( c, defer = 1;) p n
(                  ) S
(char) k
( *sp = s;) p n
(                  ) S
(while) K
( \(defer && \(c = next\(ctx, src\)\) != EOF\) {) p n
(                      ) S
(switch) K
(\(c\) {) p n
(                      ) S
(case) K
( ') p
(\() str
(': ++defer; ) p
(break) K
(;) p n
(                      ) S
(case) K
( ') p
(\)) str
(': --defer; ) p
(break) K
(;) p n
(                      ) S
(case) K
( ') p
(\\\\) str
(':) p n
(                          ) S
(switch) K
(\(c = next\(ctx, src\)\) {) p n
(                          ) S
(case) K
( ') p
(\\n) str
(': ) p
(continue) K
(;) p n
(                          ) S
(case) K
( ') p
(a) str
(': c = ') p
(\\a) str
('; ) p
(break) K
(;) p n
(optok.c) (Page 2/6) (Aug 17, 13 4:37) title
border
grestore
(Printed by U-Z1\\josh) rhead
(optok.c) (58/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 59
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                          ) p
(case) K
( ') p
(b) str
(': c = ') p
(\\b) str
('; ) p
(break) K
(;) p n
(                          ) S
(case) K
( ') p
(f) str
(': c = ') p
(\\f) str
('; ) p
(break) K
(;) p n
(                          ) S
(case) K
( ') p
(n) str
(': c = ') p
(\\n) str
('; ) p
(break) K
(;) p n
(                          ) S
(case) K
( ') p
(r) str
(': c = ') p
(\\r) str
('; ) p
(break) K
(;) p n
(                          ) S
(case) K
( ') p
(t) str
(': c = ') p
(\\t) str
('; ) p
(break) K
(;) p n
(                          ) S
(case) K
( ') p
(v) str
(': c = ') p
(\\v) str
('; ) p
(break) K
(;) p n
(                          ) S
(default) K
(:) p n
(                              ) S
(if) K
( \(isdigit\(c\)\) {) p n
(                                  ) S
(int) k
( t = 0, n = 0;) p n
(                                  ) S
(do) K
( {) p n
(                                      t *= 8;) N
(                                      t += c - ') S
(0) str
(';) p n
(                                      ++n;) N
(                                      c = next\(ctx, src\);) N
(                                  } ) S
(while) K
( \(isdigit\(c\) && n < 3\);) p n
(                                  ) S
(if) K
( \(!isdigit\(c\)\) back\(ctx, c, src\);) p n
(                                  c = t;) N
(                              }) N
(                          }) N
(                      }) N
(                      ) S
(if) K
( \(!defer\) ) p
(break) K
(;) p n
(                      ) S
(if) K
( \(sp-s > NBUF\) error\(limitcheck, ") p
(grok string exceeds buf) str
("\);) p n
(                      ) S
(else) K
( *sp++ = c;) p n
(                  }) N
(                  ) S
(return) K
( cvlit\(consbst\(ctx, sp-s, s\)\);) p n
(              }) N
() N
(    ) S
(case) K
( ') p
(<) str
(': {) p n
(                  ) S
(int) k
( c;) p n
(                  ) S
(char) k
( d, *x = ") p
(0123456789ABCDEF) str
(", *sp = s;) p n
(                  c = next\(ctx, src\);) N
(                  ) S
(if) K
( \(c == ') p
(<) str
('\) {) p n
(                      ) S
(return) K
( cvx\(consname\(ctx, ") p
(<<) str
("\)\);) p n
(                  }) N
(                  back\(ctx, c, src\);) N
(                  ) S
(while) K
( \(c = next\(ctx, src\), c != ') p
(>) str
(' && c != EOF\) {) p n
(                      ) S
(if) K
( \(isspace\(c\)\) ) p
(continue) K
(;) p n
(                      ) S
(if) K
( \(isxdigit\(c\)\) c = strchr\(x, toupper\(c\)\) - x;) p n
(                      ) S
(else) K
( error\(syntaxerror, ") p
(grok) str
("\);) p n
(                      d = c << 4; ) S
(// hi nib) c n
(                      ) p
(while) K
(\(isspace\(c = next\(ctx, src\)\)\)) p n
(                          ) S
(/**/) c
(;) p n
(                      ) S
(if) K
( \(isxdigit\(c\)\)) p n
(                          c = strchr\(x, toupper\(c\)\) - x;) N
(                      ) S
(else) K
( ) p
(if) K
( \(c == ') p
(>) str
('\) {) p n
(                          back\(ctx, c, src\); ) S
(// pushback for next iter) c n
(                          c = 0;             ) p
(// pretend it got a 0) c n
(                      } ) p
(else) K
( error\(syntaxerror, ") p
(grok) str
("\);) p n
(                      d |= c;) N
(                      ) S
(if) K
( \(sp-s > NBUF\) error\(limitcheck, ") p
(grok hexstring exceeds buf) str
("\);) p n
(                      *sp++ = d;) N
(                  }) N
(                  ) S
(return) K
( cvlit\(consbst\(ctx, sp-s, s\)\);) p n
(              }) N
() N
(    ) S
(case) K
( ') p
(>) str
(': {) p n
(                  ) S
(int) k
( c;) p n
(                  ) S
(if) K
( \(\(c = next\(ctx, src\)\) == ') p
(>) str
('\) {) p n
(                      ) S
(return) K
( cvx\(consname\(ctx, ") p
(>>) str
("\)\);) p n
(                  } ) S
(else) K
( error\(syntaxerror, ") p
(grok bare angle bracket >) str
("\);) p n
(              }) N
(              ) S
(return) K
( null; ) p
(//not reached) c n
() p n
(    ) S
(case) K
( ') p
({) str
(': { ) p
(// This is the one part that makes it a recursive-descent parser) c n
(                  object tail;) p n
(                  tail = consname\(ctx, ") S
(}) str
("\);) p n
(                  push\(ctx->lo, ctx->os, mark\);) N
(                  ) S
(while) K
( \(1\) {) p n
(                      object t = toke\(ctx, src, next, back\);) N
(optok.c) (Page 3/6) (Aug 17, 13 4:37) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                      ) p
(if) K
( \(objcmp\(ctx, t, tail\) == 0\)) p n
(                          ) S
(break) K
(;) p n
(                      push\(ctx->lo, ctx->os, t\);) N
(                  }) N
(                  arrtomark\(ctx\);  ) S
(// ie. the /] operator) c n
(                  ) p
(return) K
( cvx\(pop\(ctx->lo, ctx->os\)\);) p n
(              }) N
() N
(    ) S
(case) K
( ') p
(/) str
(': {) p n
(                  *s = next\(ctx, src\);) N
(                  ) S
(//ns = puff\(ctx, s, NBUF, src, next, back\);) c n
(                  ) p
(if) K
( \(ns && *s == ') p
(/) str
('\) {) p n
(                      object ret;) N
(                      ns = puff\(ctx, s, NBUF, src, next, back\);) N
(                      ) S
(if) K
( \(ns == NBUF\) error\(limitcheck, ") p
(grok immediate name exceeds buf) str
() p n
("\);) N
(                      s[ns] = ') S
(\\0) str
(';) p n
(                      ) S
(//push\(ctx->lo, ctx->os, cvx\(consname\(ctx, s\)\)\);) c n
(                      ) p
(//opexec\(ctx, consoper\(ctx, "load", NULL,0,0\).mark_.padw\);) c n
(                      ) p
(if) K
( \(DEBUGLOAD\)) p n
(                          printf\(") S
(\\ntoken: loading immediate name %s\\n) str
(", s\);) p n
(                      Aload\(ctx, cvx\(consname\(ctx, s\)\)\);) N
(                      ret = pop\(ctx->lo, ctx->os\);) N
(                      ) S
(if) K
( \(DEBUGLOAD\)) p n
(                          dumpobject\(ret\);) N
(                      ) S
(return) K
( ret;) p n
(                  } ) S
(else) K
( {) p n
(                      ns = 1 + puff\(ctx, s+1, NBUF-1, src, next, back\);) N
(                  }) N
(                  ) S
(if) K
( \(ns == NBUF\) error\(limitcheck, ") p
(grok name exceeds buf) str
("\);) p n
(                  s[ns] = ') S
(\\0) str
(';) p n
(                  ) S
(return) K
( cvlit\(consname\(ctx, s\)\);) p n
(              }) N
(    ) S
(default) K
(: {) p n
(                 ) S
(return) K
( cvx\(consname\(ctx, s\)\);) p n
(             }) N
(    }) N
(}) N
() N
(/* read until a non-whitespace, non-comment char.) c n
(   "prime" the buffer.  */) N
(int) k
( snip \(context *ctx, ) p
(char) k
( *buf, object *src,) p n
(        ) S
(int) k
( \(*next\)\(context *ctx, object *src\)\) {) p n
(    ) S
(int) k
( c;) p n
(    ) S
(do) K
( {) p n
(        c = next\(ctx, src\);) N
(        ) S
(if) K
( \(c == ') p
(%) str
('\) {) p n
(            ) S
(do) K
( {) p n
(                c = next\(ctx, src\);) N
(            } ) S
(while) K
(\(c != ') p
(\\n) str
(' && c != ') p
(\\f) str
(' && c != EOF\);) p n
(        }) N
(    } ) S
(while) K
(\(c != EOF && isspace\(c\)\);) p n
(    ) S
(if) K
( \(c == EOF\) ) p
(return) K
( false;) p n
(    *buf = c;) N
(    ) S
(return) K
( 1; ) p
(// true, and size of buffer) c n
(}) p n
() N
(/* read in a token up to delimiter) c n
(   read into buf any regular characters,) N
(   if we read one too many, put it back, unless whitespace. */) N
(int) k
( puff \(context *ctx, ) p
(char) k
( *buf, ) p
(int) k
( nbuf, object *src,) p n
(        ) S
(int) k
( \(*next\)\(context *ctx, object *src\),) p n
(        ) S
(void) k
( \(*back\)\(context *ctx, ) p
(int) k
( c, object *src\)\) {) p n
(    ) S
(int) k
( c;) p n
(    ) S
(char) k
( *s = buf;) p n
(    ) S
(while) K
( \(isreg\(c = next\(ctx, src\)\)\) {) p n
(        ) S
(if) K
( \(s-buf >= nbuf\) ) p
(return) K
( 0;) p n
(        *s++ = c;) N
(    }) N
(optok.c) (Page 4/6) (Aug 17, 13 4:37) title
border
grestore
(Printed by U-Z1\\josh) rhead
(optok.c) (59/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 60
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(if) K
( \(!isspace\(c\) && c != EOF\) back\(ctx, c, src\);) p n
(    ) S
(return) K
( s-buf;) p n
(}) N
() N
() N
(object toke \(context *ctx, object *src,) N
(        ) S
(int) k
( \(*next\)\(context *ctx, object *src\),) p n
(        ) S
(void) k
( \(*back\)\(context *ctx, ) p
(int) k
( c, object *src\)\) {) p n
(    ) S
(char) k
( buf[NBUF] = "";) p n
(    ) S
(int) k
( sta;  ) p
(// status, and size) c n
(    object o;) p n
(    sta = snip\(ctx, buf, src, next\);) N
(    ) S
(if) K
( \(!sta\)) p n
(        ) S
(return) K
( null;) p n
(    ) S
(if) K
( \(!isdel\(*buf\)\)) p n
(        sta += puff\(ctx, buf+1, NBUF-1, src, next, back\);) N
(    o = grok\(ctx, buf, sta, src, next, back\);) N
(    ) S
(return) K
( o;) p n
(} ) N
() N
() N
(int) k
( Fnext\(context *ctx, object *F\) {) p n
(    ) S
(return) K
( fgetc\(filefile\(ctx->lo, *F\)\);) p n
(}) N
(void) k
( Fback\(context *ctx, ) p
(int) k
( c, object *F\) {) p n
(    \() S
(void) k
(\)ungetc\(c, filefile\(ctx->lo, *F\)\);) p n
(}) N
(void) k
( Ftoken \(context *ctx, object F\) {) p n
(    object t;) N
(    ) S
(if) K
( \(!filestatus\(ctx->lo, F\)\) error\(ioerror, ") p
(Ftoken) str
("\);) p n
(    t = toke\(ctx, &F, Fnext, Fback\);) N
(    ) S
(if) K
( \(type\(t\) != nulltype\) {) p n
(        push\(ctx->lo, ctx->os, t\);) N
(        push\(ctx->lo, ctx->os, consbool\(true\)\);) N
(    } ) S
(else) K
( {) p n
(        push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(    }) N
(}) N
() N
(int) k
( Snext\(context *ctx, object *S\) {) p n
(    ) S
(int) k
( ret;) p n
(    ) S
(if) K
( \(S->comp_.sz == 0\) ) p
(return) K
( EOF;) p n
(    ret = charstr\(ctx, *S\)[0];) N
(    ++S->comp_.off;) N
(    --S->comp_.sz;) N
(    ) S
(return) K
( ret;) p n
(}) N
(void) k
( Sback\(context *ctx, ) p
(int) k
( c, object *S\) {) p n
(    --S->comp_.off;) N
(    ++S->comp_.sz;) N
(    charstr\(ctx, *S\)[0] = c;) N
(}) N
(void) k
( Stoken \(context *ctx, object S\) {) p n
(    object t;) N
(    t = toke\(ctx, &S, Snext, Sback\);) N
(    ) S
(if) K
( \(type\(t\) != nulltype\) {) p n
(        push\(ctx->lo, ctx->os, S\);) N
(        push\(ctx->lo, ctx->os, t\);) N
(        push\(ctx->lo, ctx->os, consbool\(true\)\);) N
(    } ) S
(else) K
( {) p n
(        push\(ctx->lo, ctx->os, consbool\(false\)\);) N
(    }) N
(}) N
() N
(void) k
( initoptok\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
(optok.c) (Page 5/6) (Aug 17, 13 4:37) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    op = consoper\(ctx, ") S
(token) str
(", Ftoken, 2, 1, filetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(token) str
(", Stoken, 3, 1, stringtype\); INSTALL;) p n
(}) N
() N
(optok.c) (Page 6/6) (Aug 17, 13 4:37) title
border
grestore
(Printed by U-Z1\\josh) rhead
(optok.c) (60/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 61
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL strtod */) c n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(v.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
() N
(void) k
( Zsave \(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, save\(ctx->lo\)\);) N
(}) N
() N
(void) k
( Vrestore \(context *ctx, object V\) {) p n
(    ) S
(int) k
( z = count\(ctx->lo, adrent\(ctx->lo, VS\)\);) p n
(    ) S
(while) K
(\(z > V.save_.lev\) {) p n
(        restore\(ctx->lo\);) N
(        z--;) N
(    }) N
(}) N
() N
(void) k
( Bsetglobal \(context *ctx, object B\) {) p n
(    ctx->vmmode = B.int_.val? GLOBAL: LOCAL;) N
(}) N
() N
(void) k
( Zcurrentglobal \(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, consbool\(ctx->vmmode==GLOBAL\)\);) N
(}) N
() N
(void) k
( Agcheck \(context *ctx, object A\) {) p n
(    object r;) N
(    ) S
(switch) K
(\(type\(A\)\) {) p n
(    ) S
(default) K
(:) p n
(            r = consbool\(false\); ) S
(break) K
(;) p n
(    ) S
(case) K
( stringtype:) p n
(    ) S
(case) K
( nametype:) p n
(    ) S
(case) K
( dicttype:) p n
(    ) S
(case) K
( arraytype:) p n
(            r = consbool\(\(A.tag&FBANK\)!=0\);) N
(    }) N
(    push\(ctx->lo, ctx->os, r\);) N
(}) N
() N
(void) k
( Zvmstatus \(context *ctx\) {) p n
(    push\(ctx->lo, ctx->os, consint\(count\(ctx->lo, adrent\(ctx->lo, VS\)\)\)\);) N
(    push\(ctx->lo, ctx->os, consint\(ctx->lo->used\)\);) N
(    push\(ctx->lo, ctx->os, consint\(ctx->lo->max\)\);) N
(}) N
() N
(void) k
( initopv\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(save) str
(", Zsave, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(restore) str
(", Vrestore, 0, 1, savetype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(setglobal) str
(", Bsetglobal, 0, 1, booleantype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(currentglobal) str
(", Zcurrentglobal, 1, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(gcheck) str
(", Agcheck, 1, 1, anytype\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(vmstatus) str
(", Zvmstatus, 3, 0\); INSTALL;) p n
(opv.c) (Page 1/2) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(/* dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\); */) N
() p n
(}) N
() N
() N
(opv.c) (Page 2/2) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opv.c) (61/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 62
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <alloca.h>) p n
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h> ) p
(/* NULL strtod */) c n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(nm.h) str
(") p n
(#include) K
( ") p
(st.h) str
(") p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( ") p
(di.h) str
(") p n
(#include) K
( ") p
(op.h) str
(") p n
(#include) K
( ") p
(opdi.h) str
(") p n
() N
(object bind \(context *ctx, object p\) {) N
(    object t, d;) N
(    ) S
(int) k
( i, j, z;) p n
(    ) S
(for) K
( \(i = 0; i < p.comp_.sz; i++\) {) p n
(        t = barget\(ctx, p, i\);) N
(        ) S
(switch) K
(\(type\(t\)\){) p n
(        ) S
(case) K
( nametype:) p n
(            z = count\(ctx->lo, ctx->ds\);) N
(            ) S
(for) K
( \(j = 0; j < z; j++\) {) p n
(                d = top\(ctx->lo, ctx->ds, j\);) N
(                ) S
(if) K
( \(dicknown\(ctx, bank\(ctx,d\), d, t\)\) {) p n
(                    t = bdcget\(ctx, d, t\);) N
(                    ) S
(if) K
( \(type\(t\) == operatortype\) {) p n
(                        barput\(ctx, p, i, t\);) N
(                    }) N
(                    ) S
(break) K
(;) p n
(                }) N
(            }) N
(            ) S
(break) K
(;) p n
(        ) S
(case) K
( arraytype:) p n
(            ) S
(if) K
( \(isx\(t\)\) {) p n
(                t = bind\(ctx, t\);) N
(                barput\(ctx, p, i, t\);) N
(            }) N
(        }) N
(    }) N
(    ) S
(return) K
( setfaccess\(p, readonly\);) p n
(}) N
() N
(void) k
( Pbind \(context *ctx, object P\) {) p n
(    push\(ctx->lo, ctx->os, bind\(ctx, P\)\);) N
(}) N
() N
(void) k
( traceon \(context *ctx\) {) p n
(    \() S
(void) k
(\)ctx;) p n
(    TRACE = 1;) N
(}) N
(void) k
( traceoff \(context *ctx\) {) p n
(    \() S
(void) k
(\)ctx;) p n
(    TRACE = 0;) N
(}) N
() N
(void) k
( debugloadon \(context *ctx\) {) p n
(    \() S
(void) k
(\)ctx;) p n
(    DEBUGLOAD = 1;) N
(}) N
(void) k
( debugloadoff \(context *ctx\) {) p n
(    \() S
(void) k
(\)ctx;) p n
(    DEBUGLOAD = 0;) N
(}) N
() N
(opx.c) (Page 1/2) (Aug 18, 13 2:10) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( Odumpnames \(context *ctx\) {) p n
(    printf\(") S
(\\nGlobal Name stack: ) str
("\);) p n
(    dumpstack\(ctx->gl, adrent\(ctx->gl, NAMES\)\);) N
(    \() S
(void) k
(\)puts\(""\);) p n
(    printf\(") S
(\\nLocal Name stack: ) str
("\);) p n
(    dumpstack\(ctx->lo, adrent\(ctx->lo, NAMES\)\);) N
(    \() S
(void) k
(\)puts\(""\);) p n
(}) N
() N
(void) k
( dumpvm \(context *ctx\) {) p n
(    dumpmfile\(ctx->lo\);) N
(    dumpmtab\(ctx->lo, 0\);) N
(    dumpmfile\(ctx->gl\);) N
(    dumpmtab\(ctx->gl, 0\);) N
(}) N
() N
(void) k
( initopx\(context *ctx, object sd\) {) p n
(    oper *optab;) N
(    object n,op;) N
(    assert\(ctx->gl->base\);) N
(    optab = \() S
(void) k
( *\)\(ctx->gl->base + adrent\(ctx->gl, OPTAB\)\);) p n
() N
(    op = consoper\(ctx, ") S
(bind) str
(", Pbind, 1, 1, proctype\); INSTALL;) p n
(    bdcput\(ctx, sd, consname\(ctx, ") S
(null) str
("\), null\);) p n
(    ) S
(//version: see init.ps) c n
(    ) p
(//realtime) c n
(    ) p
(//usertime) c n
(    ) p
(//languagelevel) c n
(    ) p
(//product: see init.ps \(Xpost3\)) c n
(    ) p
(//revision) c n
(    ) p
(//serialnumber) c n
(    ) p
(//executive: see init.ps) c n
(    ) p
(//echo: see opf.c) c n
(    ) p
(//prompt: see init.ps) c n
() p n
(    op = consoper\(ctx, ") S
(traceon) str
(", traceon, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(traceoff) str
(", traceoff, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(debugloadon) str
(", debugloadon, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(debugloadoff) str
(", debugloadoff, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(dumpnames) str
(", Odumpnames, 0, 0\); INSTALL;) p n
(    op = consoper\(ctx, ") S
(dumpvm) str
(", dumpvm, 0, 0\); INSTALL;) p n
() N
(    ) S
(/* dumpdic\(ctx->gl, sd\); fflush\(NULL\);) c n
(    bdcput\(ctx, sd, consname\(ctx, "mark"\), mark\); */) N
() p n
(}) N
() N
() N
(opx.c) (Page 2/2) (Aug 18, 13 2:10) title
border
grestore
(Printed by U-Z1\\josh) rhead
(opx.c) (62/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1,1) 63
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <stdio.h>) p n
(#include) K
( <termios.h>) p n
(#include) K
( <unistd.h>) p n
() N
(void) k
( echoon \() p
(FILE) k
( *f\) {) p n
(    ) S
(struct) k
( termios ts;) p n
(    tcgetattr\(fileno\(f\), &ts\);) N
(    ts.c_lflag |= ECHO;) N
(    tcsetattr\(fileno\(f\), TCSANOW, &ts\);) N
(}) N
() N
(void) k
( echooff \() p
(FILE) k
( *f\) {) p n
(    ) S
(struct) k
( termios ts;) p n
(    tcgetattr\(fileno\(f\), &ts\);) N
(    ts.c_lflag &= ~ECHO;) N
(    tcsetattr\(fileno\(f\), TCSANOW, &ts\);) N
(}) N
() N
(osunix.c) (Page 1/1) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* s.c - a segmented, extendable stack */) c n
() p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <stdio.h> ) p
(/* printf */) c n
(#include) K
( <stdlib.h> ) p
(/* NULL */) c n
(#include) K
( ") p
(m.h) str
(" ) p
(/* mfile mfalloc findtabent */) c n
() p n
(#include) K
( ") p
(ob.h) str
(" ) p
(/* object size */) c n
(/* typedef long long object; */) N
() p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(err.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(/*#define STACKSEGSZ 10 */) c n
() p n
(/*) c n
(typedef struct {) N
(    unsigned nextseg;) N
(    unsigned top;) N
(    object data[STACKSEGSZ];) N
(} stack;) N
(*/) N
() p n
(unsigned) k
( initstack\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( adr = mfalloc\(mem, ) p
(sizeof) K
(\(stack\)\);) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + adr\);) p n
(    s->nextseg = 0;) N
(    s->top = 0;) N
(    ) S
(return) K
( adr;) p n
(}) N
() N
(void) k
( dumpstack\(mfile *mem, ) p
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    ) S
(unsigned) k
( i;) p n
(    ) S
(unsigned) k
( a;) p n
(    a = 0;) N
(    ) S
(while) K
( \(1\) {) p n
(        ) S
(for) K
( \(i=0; i < s->top; i++\) {) p n
(            printf\(") S
(%d:) str
(", a++\);) p n
(            dumpobject\(s->data[i]\);) N
(        }) N
(        ) S
(if) K
( \(i != STACKSEGSZ\) ) p
(break) K
(;) p n
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(}) N
() N
(/* free a stack segment */) c n
(void) k
( sfree\(mfile *mem, ) p
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( e;) p n
(    ) S
(if) K
( \(s->nextseg\) sfree\(mem, s->nextseg\);) p n
(    e = mtalloc\(mem, 0, 0\); ) S
(/* allocate entry with 0 size */) c n
(    findtabent\(mem, &tab, &e\);) p n
(    tab->tab[e].adr = stackadr; ) S
(/* insert address */) c n
(    tab->tab[e].sz = ) p
(sizeof) K
(\(stack\); ) p
(/* insert size */) c n
(    ) p
(/* discard */) c n
(}) p n
() N
(unsigned) k
( count\(mfile *mem, ) p
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    ) S
(unsigned) k
( ct = 0;) p n
(    ) S
(while) K
( \(s->top == STACKSEGSZ\) {) p n
(        ct += STACKSEGSZ;) N
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(    ) S
(return) K
( ct + s->top;) p n
(}) N
() N
(s.c) (Page 1/4) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(osunix.c, s.c) (63/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 64
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( push\(mfile *mem, ) p
(unsigned) k
( stackadr, object o\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\); ) p
(/* load the stack */) c n
() p n
(    ) S
(while) K
( \(s->top == STACKSEGSZ\) { ) p
(/* find top segment */) c n
(        s = \() p
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
() N
(    s->data[s->top++] = o; ) S
(/* push value */) c n
() p n
(    ) S
(/* if push maxxed the topmost segment, link a new one */) c n
(    ) p
(if) K
( \(s->top == STACKSEGSZ\) {) p n
(        ) S
(if) K
( \(s->nextseg == 0\) {) p n
(            s->nextseg = initstack\(mem\);) N
(        } ) S
(else) K
( {) p n
(            s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(            s->top = 0;) N
(        }) N
(    }) N
(}) N
() N
(#if) K
( 0) p n
(/* index the stack from top-down */) c n
(/* n.b. this code can only reliably access) N
(   STACKSEGSZ elements from the top */) N
(object top\(mfile *mem, ) p
(unsigned) k
( stackadr, integer i\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    stack *p = ) S
(NULL) K
(;) p n
() N
(    ) S
(/* find top segment */) c n
(    ) p
(while) K
( \(s->top == STACKSEGSZ\) {) p n
(        p = s;) N
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(    ) S
(if) K
( \(s->top == 0\) {) p n
(        ) S
(if) K
( \(p != ) p
(NULL) K
(\) s = p;) p n
(        ) S
(else) K
( ) p
(/*error\("stack underflow"\);*/) c n
(            ) p
(return) K
( invalid;) p n
(    } ) S
(else) K
( ) p
(if) K
( \(\(integer\)s->top <= i\) {) p n
(        i -= s->top;) N
(        ) S
(if) K
( \(p != ) p
(NULL) K
(\) s = p;) p n
(        ) S
(else) K
( ) p
(/*error\("stack underflow"\);*/) c n
(            ) p
(return) K
( invalid;) p n
(    }) N
(    ) S
(return) K
( s->data[s->top-1-i];) p n
(}) N
(#endif) K n
() p n
(/* index the stack from top-down */) c n
(object top\(mfile *mem, ) p
(unsigned) k
( stacadr, integer i\) {) p n
(    ) S
(int) k
( cnt = count\(mem, stacadr\);) p n
(    ) S
(return) K
( bot\(mem, stacadr, cnt - 1 - i\);) p n
(}) N
() N
(#if) K
( 0) p n
(/* index from top-down and put item there.) c n
(   the inverse of top. */) N
(void) k
( pot\(mfile *mem, ) p
(unsigned) k
( stackadr, integer i, object o\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    stack *p = ) S
(NULL) K
(;) p n
() N
() N
(    ) S
(/* find top segment */) c n
(    ) p
(while) K
( \(s->top == STACKSEGSZ\) {) p n
(        p = s;) N
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(    ) S
(if) K
( \(s->top == 0\) {) p n
(        ) S
(if) K
( \(p != ) p
(NULL) K
(\) s = p;) p n
(        ) S
(else) K
( error\(stackunderflow, ") p
(pot) str
("\);) p n
(s.c) (Page 2/4) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    } ) p
(else) K
( ) p
(if) K
( \(\(integer\)s->top < i\) {) p n
(        i -= s->top;) N
(        ) S
(if) K
( \(p != ) p
(NULL) K
(\) s = p;) p n
(        ) S
(else) K
( error\(stackunderflow, ") p
(pot) str
("\);) p n
(    }) N
(    s->data[s->top - 1 - i] = o;) N
(}) N
(#endif) K n
() p n
(/* index from top-down and put item there.) c n
(   inverse of top. */) N
(void) k
( pot\(mfile *mem, ) p
(unsigned) k
( stacadr, integer i, object o\) {) p n
(    ) S
(int) k
( cnt = count\(mem, stacadr\);) p n
(    tob\(mem, stacadr, cnt - 1 - i, o\);) N
(}) N
() N
(/* index from bottom up */) c n
(object bot\(mfile *mem, ) p
(unsigned) k
( stacadr, integer i\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stacadr\);) p n
() N
(    ) S
(/* find desired segment */) c n
(    ) p
(while) K
( \(i >= STACKSEGSZ\) {) p n
(        i -= STACKSEGSZ;) N
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(    ) S
(return) K
( s->data[i];) p n
(}) N
() N
(/* index from bottom-up and put item there.) c n
(   inverse of bot. */) N
(void) k
( tob\(mfile *mem, ) p
(unsigned) k
( stacadr, integer i, object o\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stacadr\);) p n
() N
(    ) S
(/* find desired segment */) c n
(    ) p
(while) K
( \(i >= STACKSEGSZ\) {) p n
(        i -= STACKSEGSZ;) N
(        ) S
(if) K
( \(s->nextseg == 0\) error\(stackunderflow, ") p
(tob) str
("\);) p n
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(    s->data[i] = o;) N
(}) N
() N
(object pop\(mfile *mem, ) S
(unsigned) k
( stackadr\) {) p n
(    stack *s = \() S
(void) k
( *\)\(mem->base + stackadr\);) p n
(    stack *p = ) S
(NULL) K
(;) p n
() N
(    ) S
(/* find top segment */) c n
(    ) p
(while) K
( \(s->top == STACKSEGSZ\) {) p n
(        p = s;) N
(        s = \() S
(void) k
( *\)\(mem->base + s->nextseg\);) p n
(    }) N
(    ) S
(if) K
( \(s->top == 0\) {) p n
(        ) S
(if) K
( \(p != ) p
(NULL) K
(\) s = p; ) p
(/* back up if top is empty */) c n
(        ) p
(else) K
( ) p
(/* error\("stack underflow"\); */) c n
(            ) p
(return) K
( invalid;) p n
(    }) N
() N
(    ) S
(return) K
( s->data[--s->top]; ) p
(/* pop value */) c n
(}) p n
() N
(#ifdef) K
( TESTMODULE) p n
() N
(#include) K
( <stdio.h>) p n
(#include) K
( <unistd.h>) p n
() N
(mfile mem;) N
(unsigned) k
( s, t;) p n
() N
(/* initialize everything */) c n
(s.c) (Page 3/4) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(s.c) (64/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (4,1) 65
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( init\() p
(void) k
(\) {) p n
(    pgsz = getpagesize\(\);) N
(    initmem\(&mem, ") S
(x.mem) str
("\);) p n
(    s = initstack\(&mem\);) N
(    t = initstack\(&mem\);) N
(}) N
() N
(void) k
( xit\() p
(void) k
(\) {) p n
(    exitmem\(&mem\);) N
(}) N
() N
(int) k
( main\(\) {) p n
(    init\(\);) N
() N
(    printf\(") S
(\\n^test s.c\\n) str
("\);) p n
(    printf\(") S
(test stack by reversing a sequence\\n) str
("\);) p n
(    ) S
(//object a = { .int_.val = 2 }, b = \( .int_.val = 12 }, c = { .int_.val = 0x) c n
(F00 };) N
(    object a = consint\(2\);) p n
(    object b = consint\(12\);) N
(    object c = consint\(0xF00\);) N
(    object x = a, y = b, z = c;) N
(    printf\(") S
(x = %d, y = %d, z = %d\\n) str
(", x.int_.val, y.int_.val, z.int_.val\);) p n
() N
(    push\(&mem, s, a\);) N
(    push\(&mem, s, b\);) N
(    push\(&mem, s, c\);) N
() N
(    x = pop\(&mem, s\); ) S
(/* x = c */) c n
(    push\(&mem, t, x\);) p n
(    y = pop\(&mem, s\); ) S
(/* y = b */) c n
(    push\(&mem, t, y\);) p n
(    z = pop\(&mem, s\); ) S
(/* z = a */) c n
(    push\(&mem, t, z\);) p n
(    printf\(") S
(x = %d, y = %d, z = %d\\n) str
(", x.int_.val, y.int_.val, z.int_.val\);) p n
(    printf\(") S
(top\(0\): %d\\n) str
(", top\(&mem, t, 0\).int_.val\);) p n
(    printf\(") S
(top\(1\): %d\\n) str
(", top\(&mem, t, 1\).int_.val\);) p n
(    printf\(") S
(top\(2\): %d\\n) str
(", top\(&mem, t, 2\).int_.val\);) p n
(    printf\(") S
(bot\(0\): %d\\n) str
(", bot\(&mem, t, 0\).int_.val\);) p n
(    printf\(") S
(bot\(1\): %d\\n) str
(", bot\(&mem, t, 1\).int_.val\);) p n
(    printf\(") S
(bot\(2\): %d\\n) str
(", bot\(&mem, t, 2\).int_.val\);) p n
(    printf\(") S
(tob\(2, 55\)\\n) str
("\);) p n
(    tob\(&mem, t, 2, consint\(55\)\);) N
(    printf\(") S
(pot\(1, 37\)\\n) str
("\);) p n
(    pot\(&mem, t, 1, consint\(37\)\);) N
() N
(    x = pop\(&mem, t\); ) S
(/* x = a */) c n
(    y = pop\(&mem, t\); ) p
(/* y = b */) c n
(    z = pop\(&mem, t\); ) p
(/* z = c */) c n
(    printf\(") p
(x = %d, y = %d, z = %d\\n) str
(", x.int_.val, y.int_.val, z.int_.val\);) p n
(    ) S
(//z = pop\(&mem, t\);) c n
() p n
(    xit\(\);) N
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
(s.c) (Page 4/4) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <stdbool.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
() N
(object consstr\(mfile *mem, ) S
(unsigned) k
( sz, ) p
(/*@NULL@*/) c
( ) p
(char) k
( *ini\) {) p n
(    ) S
(unsigned) k
( ent;) p n
(    object o;) N
(    ) S
(//ent = mtalloc\(mem, 0, \(sz/sizeof\(int\) + 1\)*sizeof\(int\)\);) c n
(    ent = gballoc\(mem, \(sz/) p
(sizeof) K
(\() p
(int) k
(\) + 1\)*) p
(sizeof) K
(\() p
(int) k
(\)\);) p n
(    ) S
(if) K
( \(ini\) put\(mem, ent, 0, sz, ini\);) p n
(    o.tag = stringtype | \(unlimited << FACCESSO\);) N
(    o.comp_.sz = sz;) N
(    o.comp_.ent = ent;) N
(    o.comp_.off = 0;) N
(    ) S
(return) K
( o;) p n
(}) N
() N
(object consbst\(context *ctx, ) S
(unsigned) k
( sz, ) p
(/*@NULL@*/) c
( ) p
(char) k
( *ini\) {) p n
(    object s;) N
(    s = consstr\(ctx->vmmode==GLOBAL? ctx->gl: ctx->lo, sz, ini\);) N
(    ) S
(if) K
( \(ctx->vmmode==GLOBAL\)) p n
(        s.tag |= FBANK;) N
(    ) S
(return) K
( s;) p n
(}) N
() N
(/*@dependent@*/) c n
(char) k
( *charstr\(context *ctx, object S\) {) p n
(    mfile *f;) N
(    mtab *tab;) N
(    ) S
(unsigned) k
( ent = S.comp_.ent;) p n
(    f = bank\(ctx, S\) ) S
(/*S.tag&FBANK?ctx->gl:ctx->lo*/) c
(;) p n
(    findtabent\(f, &tab, &ent\);) N
(    ) S
(return) K
( \() p
(void) k
( *\)\(f->base + tab->tab[ent].adr + S.comp_.off\);) p n
(}) N
() N
() N
(void) k
( strput\(mfile *mem, object s, integer i, integer c\) {) p n
(    byte b = c;) N
(    put\(mem, s.comp_.ent, s.comp_.off + i, 1, &b\);) N
(}) N
() N
(void) k
( bstput\(context *ctx, object s, integer i, integer c\) {) p n
(    strput\(bank\(ctx, s\) ) S
(/*s.tag&FBANK? ctx->gl: ctx->lo*/) c
(, s, i, c\);) p n
(}) N
() N
(integer strget\(mfile *mem, object s, integer i\) {) N
(    byte b;) N
(    get\(mem, s.comp_.ent, s.comp_.off + i, 1, &b\);) N
(    ) S
(return) K
( b;) p n
(}) N
() N
(integer bstget\(context *ctx, object s, integer i\) {) N
(    ) S
(return) K
( strget\(bank\(ctx, s\) ) p
(/*s.tag&FBANK? ctx->gl: ctx->lo*/) c
(, s, i\);) p n
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
(#include) K
( <stdio.h>) p n
() N
(#define) K
( CNT_STR\(s\) ) p
(sizeof) K
(\(s\), s) p n
() N
(mfile mem;) N
() N
(int) k
( main\() p
(void) k
(\) {) p n
(    object s;) N
(    ) S
(int) k
( i;) p n
(    printf\(") S
(\\n^ st.c\\n) str
("\);) p n
(st.c) (Page 1/2) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(s.c, st.c) (65/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2,1) 66
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    initmem\(&mem, ") p
(x.mem) str
("\);) p n
(    \() S
(void) k
(\)initmtab\(&mem\);) p n
() N
(    s = consstr\(&mem, CNT_STR\(") S
(This is a string) str
("\)\);) p n
(    ) S
(for) K
( \(i=0; i < s.comp_.sz; i++\) {) p n
(        putchar\(strget\(&mem, s, i\)\);) N
(    }) N
(    putchar\(') S
(\\n) str
('\);) p n
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
() p n
(st.c) (Page 2/2) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <assert.h>) p n
(#include) K
( <stdbool.h>) p n
(#include) K
( <string.h>) p n
() N
(#include) K
( ") p
(m.h) str
(") p n
(#include) K
( ") p
(ob.h) str
(") p n
(#include) K
( ") p
(s.h) str
(") p n
(#include) K
( ") p
(itp.h) str
(") p n
(#include) K
( ") p
(gc.h) str
(") p n
() N
(/*) c n
(typedef struct {) N
(    word tag;) N
(    word lev;) N
(    unsigned stk;) N
(} save_;) N
() N
(typedef struct {) N
(    unsigned src;) N
(    unsigned cpy;) N
(} saverec_;) N
(*/) N
() p n
(/* create a stack in slot VS.) c n
(   sz is 0 so gc will ignore it. */) N
(void) k
( initsave\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( t;) p n
(    ) S
(unsigned) k
( ent;) p n
(    mtab *tab;) N
(    ent = mtalloc\(mem, 0, 0\); ) S
(/* allocate an entry of zero length */) c n
(    assert\(ent == VS\);) p n
(    t = initstack\(mem\);) N
(    tab = \() S
(void) k
( *\)mem->base;) p n
(    tab->tab[ent].adr = t;) N
(}) N
() N
(/* push a new save object on the save stack) c n
(   this object is itself a stack \(contains a stackadr\) */) N
(object save\(mfile *mem\) {) p n
(    object v;) N
(    v.tag = savetype;) N
(    v.save_.lev = count\(mem, adrent\(mem, VS\)\);) N
(    v.save_.stk = initstack\(mem\);) N
(    push\(mem, adrent\(mem, VS\), v\);) N
(    ) S
(return) K
( v;) p n
(}) N
() N
(/* check ent's tlev against current save level \(save-stack count\) */) c n
(unsigned) k
( stashed\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    ) S
(//object sav = top\(mem, adrent\(mem, VS\), 0\);) c n
(    mtab *tab;) p n
(    ) S
(unsigned) k
( cnt;) p n
(    ) S
(unsigned) k
( tlev;) p n
(    cnt = count\(mem, adrent\(mem, VS\)\);) N
(    findtabent\(mem, &tab, &ent\);) N
(    tlev = \(tab->tab[ent].mark & TLEVM\) >> TLEVO;) N
(    ) S
(return) K
( tlev == cnt;) p n
(}) N
() N
(/* make a clone of ent, return new ent */) c n
(unsigned) k
( copy\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    mtab *tab;) N
(    ) S
(unsigned) k
( new;) p n
(    ) S
(unsigned) k
( tent = ent;) p n
(    findtabent\(mem, &tab, &ent\);) N
(    new = gballoc\(mem, tab->tab[ent].sz\);) N
(    ent = tent;) N
(    findtabent\(mem, &tab, &ent\); ) S
(//recalc) c n
(    memcpy\(mem->base + adrent\(mem, new\),) p n
(v.c) (Page 1/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(st.c, v.c) (66/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (2-3) 67
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            mem->base + tab->tab[ent].adr,) p n
(            tab->tab[ent].sz\);) N
(    ) S
(return) K
( new;) p n
(}) N
() N
(/* set tlev for ent to current save level) c n
(   push saverec relating ent to saved copy */) N
(void) k
( stash\(mfile *mem, ) p
(unsigned) k
( ent\) {) p n
(    object sav = top\(mem, adrent\(mem, VS\), 0\);) N
(    mtab *tab;) N
(    ) S
(unsigned) k
( rent = ent;) p n
(    object o;) N
(    ) S
(unsigned) k
( tlev;) p n
(    findtabent\(mem, &tab, &rent\);) N
(    tlev = sav.save_.lev;) N
(    tab->tab[rent].mark &= ~TLEVM; ) S
(// clear TLEV field) c n
(    tab->tab[rent].mark |= \(tlev << TLEVO\);  ) p
(// set TLEV field) c n
(    o.saverec_.src = ent;) p n
(    o.saverec_.cpy = copy\(mem, ent\);) N
(    push\(mem, sav.save_.stk, o\);) N
(}) N
() N
(/* for each saverec from current save stack) c n
(        exchange adrs between src and cpy) N
(        pop saverec) N
(    pop save stack */) N
(void) k
( restore\(mfile *mem\) {) p n
(    ) S
(unsigned) k
( v;) p n
(    object sav;) N
(    mtab *stab, *ctab;) N
(    ) S
(unsigned) k
( cnt;) p n
(    ) S
(unsigned) k
( sent, cent;) p n
(    v = adrent\(mem, VS\); ) S
(// save-stack address) c n
(    sav = pop\(mem, v\); ) p
(// save-object \(stack of saverec_'s\)) c n
(    cnt = count\(mem, sav.save_.stk\);) p n
(    ) S
(while) K
( \(cnt--\) {) p n
(        object rec;) N
(        ) S
(unsigned) k
( hold;) p n
(        rec = pop\(mem, sav.save_.stk\);) N
(        sent = rec.saverec_.src;) N
(        cent = rec.saverec_.cpy;) N
(        findtabent\(mem, &stab, &sent\);) N
(        findtabent\(mem, &ctab, &cent\);) N
(        hold = stab->tab[sent].adr;                 ) S
(// tmp = src) c n
(        stab->tab[sent].adr = ctab->tab[cent].adr;  ) p
(// src = cpy) c n
(        ctab->tab[cent].adr = hold;                 ) p
(// cpy = tmp) c n
(    }) p n
(    sfree\(mem, sav.save_.stk\);) N
(}) N
() N
(#ifdef) K
( TESTMODULE) p n
(#include) K
( ") p
(ar.h) str
(") p n
(#include) K
( <stdio.h>) p n
() N
(mfile mf;) N
() N
(void) k
( init\(mfile *mem\) {) p n
(    initmem\(mem, ") S
(x.mem) str
("\);) p n
(    \() S
(void) k
(\)initmtab\(mem\);) p n
(    initfree\(mem\);) N
(    initsave\(mem\);) N
(}) N
() N
(void) k
( show\() p
(char) k
( *msg, mfile *mem, object a\) {) p n
(    printf\(") S
(%s ) str
(", msg\);) p n
(    printf\(") S
(%d ) str
(", arrget\(mem, a, 0\).int_.val\);) p n
(    printf\(") S
(%d\\n) str
(", arrget\(mem, a, 1\).int_.val\);) p n
(}) N
() N
(v.c) (Page 2/3) (Aug 14, 13 22:46) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(int) k
( main\() p
(void) k
(\) {) p n
(    mfile *mem = &mf;) N
(    object a;) N
(    printf\(") S
(\\n^test v\\n) str
("\);) p n
(    init\(mem\);) N
() N
(    a = consarr\(mem, 2\);) N
(    arrput\(mem, a, 0, consint\(33\)\);) N
(    arrput\(mem, a, 1, consint\(66\)\);) N
(    show\(") S
(initial) str
(", mem, a\);) p n
() N
(    ) S
(//object v = ) c n
(    \() p
(void) k
(\)save\(mem\);) p n
(    arrput\(mem, a, 0, consint\(77\)\);) N
(    show\(") S
(save and alter) str
(", mem, a\);) p n
() N
(    restore\(mem\);) N
(    show\(") S
(restored) str
(", mem, a\);) p n
() N
(    puts\(""\);) N
(    ) S
(return) K
( 0;) p n
(}) N
() N
(#endif) K n
() p n
() N
(v.c) (Page 3/3) (Aug 14, 13 22:46) title
border
grestore
(Printed by U-Z1\\josh) rhead
(v.c) (67/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 68
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(%procedures in systemdict) c n
(\() p
(loading init.ps...\\n) str
(\) print) p n
() N
(%\(35\\n\) print) c n
(%currentfile flushfile) N
() p n
(systemdict ) S
(begin) K n
(true) k
( setglobal) p n
() N
(/product \() S
(Xpost3) str
(\) ) p
(def) K n
(/version \() p
(0) str
(\) ) p
(def) K n
(/revision 0 ) p
(def) K n
(/run) L
( { \() p
(r) str
(\) file cvx exec } ) p
(def) K n
(/Run) L
( { \() p
(\\\() str
(\) print ) p
(dup) K
( =print \() p
(\\\) run\\n) str
(\) print flush run } ) p
(def) K n
(/interrupt) L
( { stop } ) p
(def) K n
(/) p
(true) k
( 0 0 ) p
(eq) K
( ) p
(def) K n
(/) p
(false) k
( 0 0 ne ) p
(def) K n
() p n
() N
(/=string 128 string ) S
(def) K n
(/=print {) p n
(    ) S
(dup) K
( type /stringtype ne {) p n
(        //=string cvs) N
(    } ) S
(if) K n
(    print) p n
(} ) S
(def) K n
(/=only //=print ) p
(def) K n
(/strcat) L
( {) p n
(    2 ) S
(copy) K n
(    ) p
(length) K
( ) p
(exch) K
( ) p
(length) K
( ) p
(exch) K
( 1 ) p
(index) K
( ) p
(add) K
( ) p
(% a b an bn+an) c n
(    string ) p
(dup) K
( 0 6 -1 ) p
(roll) K
( putinterval ) p
(% b an str) c n
(    ) p
(dup) K
( 4 2 ) p
(roll) K
( ) p
(exch) K
( putinterval ) p
(% \(ab\)) c n
(} ) p
(def) K n
() p n
() N
(/= {) N
(    //=print exec) N
(    \() S
(\\n) str
(\) print) p n
(} ) S
(def) K n
() p n
(%dumpnames dumpvm) c n
(%debugloadon) N
() p n
(%\(/err.ps\)) c n
(%\(.\) [ {) N
(%    \(XPOSTDIR\) getenv %env) N
(%    exch pop exch pop) N
(%} stopped {cleartomark} if) N
(%exch strcat Run) N
(\() p
(err.ps) str
(\)run) p n
() N
() N
(/stack) L
( { count ) p
(dup) K
( 1 ) p
(add) K
( ) p
(copy) K
( //= repeat ) p
(pop) K
( } ) p
(def) K n
() p n
(% ==) c n
(24 ) p
(dict) K
( ) p
(begin) K n
(/==) p
(dict) K
( ) p
(currentdict) K
( ) p
(def) K n
(    /rmargin 72 ) p
(def) K n
(    /NL \() p
(\\n) str
(\) ) p
(def) K n
() p n
(    /cvsprint {) N
(        =string cvs tprint) N
(        \() S
( ) str
(\) tprint) p n
(    } ) S
(def) K n
(    /tprint {) p n
(        ) S
(dup) K
( ) p
(length) K
( cp ) p
(add) K
( rmargin ) p
(gt) K
( {) p n
(            NL print) N
(            /cp 0 ) S
(def) K n
(        } ) p
(if) K n
(init.ps) (Page 1/4) (Aug 18, 13 2:13) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        ) p
(dup) K
( ) p
(length) K
( cp ) p
(add) K
( /cp ) p
(exch) K
( ) p
(def) K n
(        print) p n
(    } ) S
(def) K n
(    /typeprint { ) p
(dup) K
( type exec } ) p
(def) K n
() p n
(    /arraytype {) N
(        ) S
(dup) K
( rcheck {) p n
(            ) S
(dup) K
( xcheck {) p n
(                \() S
({ ) str
(\) tprint { typeprint } ) p
(forall) K
( \() p
(} ) str
(\) tprint) p n
(            }{) N
(                \() S
([ ) str
(\) tprint { typeprint } ) p
(forall) K
( \() p
(] ) str
(\) tprint) p n
(            } ) S
(ifelse) K n
(        }{ ) p
(pop) K
( \() p
(-array-) str
(\) tprint } ) p
(ifelse) K n
(    } ) p
(def) K n
(    { cvsprint }) p n
(    ) S
(dup) K
( /booleantype ) p
(exch) K
( ) p
(def) K n
(    ) p
(dup) K
( /integertype ) p
(exch) K
( ) p
(def) K n
(    /realtype ) p
(exch) K
( ) p
(def) K n
() p n
(    /nulltype { ) S
(pop) K
( \() p
(null ) str
(\) tprint } ) p
(def) K n
(    /dicttype { ) p
(pop) K
( \() p
(-dict- ) str
(\) tprint } ) p
(def) K n
(    /filetype { ) p
(pop) K
( \() p
(-file- ) str
(\) tprint } ) p
(def) K n
(    /marktype { ) p
(pop) K
( \() p
(-mark- ) str
(\) tprint } ) p
(def) K n
(    /fonttype { ) p
(pop) K
( \() p
(-font- ) str
(\) tprint } ) p
(def) K n
() p n
(    /nametype {) N
(        ) S
(dup) K
( xcheck not {) p n
(            \() S
(/) str
(\) tprint) p n
(        } ) S
(if) K n
(        cvsprint) p n
(    } ) S
(def) K n
() p n
(    /operatortype {) N
(        \() S
(--) str
(\) tprint) p n
(        =string cvs tprint) N
(        \() S
(--) str
(\) tprint) p n
(    } ) S
(def) K n
() p n
(    /savetype {) N
(        ) S
(pop) K
( \() p
(-savelevel- ) str
(\) tprint) p n
(    } ) S
(def) K n
() p n
(    /stringtype {) N
(        ) S
(dup) K
( rcheck {) p n
(            \() S
(\\\() str
(\) tprint tprint \() p
(\\\)) str
(\) tprint) p n
(        }{) N
(            ) S
(pop) K
( \() p
(-string- ) str
(\) tprint) p n
(        } ) S
(ifelse) K n
(    } ) p
(def) K n
() p n
(/== {) N
(    ) S
(%traceon) c n
(    //==) p
(dict) K
( ) p
(begin) K n
(        /cp 0 ) p
(def) K n
(        typeprint) p n
(        NL print) N
(    ) S
(end) K n
(} ) p
(end) K
( ) p
(def) K
( ) p
(% remove ==dict, installing == in systemdict) c n
() p n
(/pstack) L
( { count ) p
(dup) K
( 1 ) p
(add) K
( ) p
(copy) K
( //== repeat ) p
(pop) K
( } ) p
(def) K n
() p n
() N
(/execdict 6 ) S
(dict) K
( ) p
(def) K n
(execdict ) p
(begin) K n
(    /quitflag ) p
(false) k
( ) p
(def) K n
(    /checkquit {) p n
(        //execdict /quitflag ) S
(get) K n
(        { exit } ) p
(if) K n
(    } ) p
(def) K n
(init.ps) (Page 2/4) (Aug 18, 13 2:13) title
border
grestore
(Printed by U-Z1\\josh) rhead
(init.ps) (68/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 69
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    /execdepth 0 ) p
(def) K n
(end) N
() p n
(/start) L
( {) p n
(    /quit {) N
(        ) S
(%exit) c n
(        //execdict /quitflag ) p
(true) k
( ) p
(put) K n
(        //$error /newerror ) p
(false) k
( ) p
(put) K n
(        interrupt) p n
(    } ) S
(def) K n
() p n
(    /executive load stopped) N
(    ) S
(pop) K
( //quit ) p
(% the operator) c n
(} ) p
(def) K n
() p n
(/prompt) L
( {) p n
(    \() S
(PS) str
(\) print) p n
(    count ) S
(dup) K
( 0 ) p
(eq) K
( { ) p
(pop) K
( } { \() p
(<) str
(\) print //=print exec } ) p
(ifelse) K n
(    //execdict /execdepth ) p
(get) K
( {) p n
(        \() S
(>) str
(\) print) p n
(    } repeat) N
(    flush) N
(} ) S
(def) K n
() p n
(/executive) L
( {) p n
(    //execdict ) S
(begin) K n
() p n
(    /execdepth execdepth 1 ) S
(add) K
( ) p
(def) K n
(    /QUIET ) p
(where) K
( { ) p
(pop) K
( }{) p n
(        product print) N
(        \() S
( version ) str
(\) print version print) p n
(        \() S
(.) str
(\) print revision =print) p n
(        \() S
(\\n) str
(\) print) p n
(    } ) S
(ifelse) K n
() p n
(    { ) S
(%loop) c n
(        /quitflag ) p
(false) k
( ) p
(def) K n
(        //$error /newerror ) p
(false) k
( ) p
(put) K n
(        /prompt load stopped {) p n
(            \() S
(Error during prompt execution\\n) str
(\) print) p n
(            handleerror) N
(            exit) N
(        } ) S
(if) K n
(        {) p n
(            mark) N
(            /stmtfile \() S
(%statementedit) str
(\) \() p
(r) str
(\) file ) p
(def) K n
(        } stopped {) p n
(            cleartomark) N
(            //$error /newerror ) S
(get) K
( {) p n
(                //$error /errorname ) S
(get) K
( ) p n
(                /undefinedfilename ne { ) S
(% ^d at prompt) c n
(                    handleerror) p n
(                } ) S
(if) K n
(                //$error /newerror ) p
(false) k
( ) p
(put) K n
(                exit) p n
(            } ) S
(if) K n
(        }{) p n
(            ) S
(pop) K
( stmtfile ) p
(end) K n
(            {) p n
(                cvx exec) N
(            } stopped //execdict ) S
(begin) K
( {) p n
(                handleerror) N
(                stmtfile closefile) N
(            } ) S
(if) K n
(        } ) p
(ifelse) K n
(        checkquit) p n
(    } loop) N
(    /quitflag ) S
(false) k
( ) p
(def) K n
(    //execdict /execdepth 2 ) p
(copy) K
( ) p
(get) K
( 1 ) p
(sub) K
( ) p
(put) K n
(init.ps) (Page 3/4) (Aug 18, 13 2:13) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(end) K n
(    //$error /doclose ) p
(false) k
( ) p
(put) K n
(    interrupt) p n
(} ) S
(bind) K n
(def) N
() p n
(end) K
( ) p
(% systemdict) c n
() p n
(%traceon) c n
(%debugloadon) N
() p n
($error/initializing ) S
(false) k
( ) p
(put) K
( ) p
(% ready to go!) c n
(false) k
( setglobal) p n
(init.ps) (Page 4/4) (Aug 18, 13 2:13) title
border
grestore
(Printed by U-Z1\\josh) rhead
(init.ps) (69/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 70
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(% error dictionaries) c n
() p n
(\() S
(loading err.ps...\\n) str
(\) print) p n
() N
(systemdict /$error 13 ) S
(dict) K
( ) p
(put) K n
($error ) p
(begin) K n
(    /ostackarray null ) p
(def) K n
(    /newerror ) p
(false) k
( ) p
(def) K n
(    /command null ) p
(def) K n
(    /errorname null ) p
(def) K n
(    /initializing ) p
(true) k
( ) p
(def) K n
(    /Extra \(\) ) p
(def) K n
(end) N
(\() p
($error) str
(\)=) p n
() N
(/.error {) N
(    //$error ) S
(exch) K
( /errorname ) p
(exch) K
( ) p
(put) K n
(    //$error ) p
(exch) K
( /command ) p
(exch) K
( ) p
(put) K n
(    //$error /newerror ) p
(true) k
( ) p
(put) K n
(    //$error /errorname ) p
(get) K
( /VMerror ne {) p n
(        //$error /ostackarray ) S
(get) K
( null ) p
(eq) K
( {) p n
(            //$error /estackarray 250 ) S
(array) K
( ) p
(put) K n
(            //$error /ostackarray 1000 ) p
(array) K
( ) p
(put) K n
(            //$error /dstackarray 30 ) p
(array) K
( ) p
(put) K n
(        } ) p
(if) K n
(        count) p n
(        //$error /ostackarray ) S
(get) K
( ) p
(exch) K
( 0 ) p
(exch) K
( getinterval astore) p n
(        //$error ) S
(exch) K
( /ostack ) p
(exch) K
( ) p
(put) K n
(        //$error /dstack //$error /dstackarray ) p
(get) K
( dictstack ) p
(put) K n
(        //$error /estack //$error /estackarray ) p
(get) K
( execstack) p n
(        ) S
(dup) K
( ) p
(length) K
( 2 ) p
(sub) K
( 0 ) p
(exch) K
( getinterval ) p
(put) K
( ) p
(% trim 1:{ //$err... 2:{ //$err.) c n
(.. execstack) N
(        //$error /ostack ) p
(get) K
( aload ) p
(pop) K n
(    } ) p
(if) K n
(    //$error /initializing ) p
(get) K
( {) p n
(        handleerror) N
(    } ) S
(if) K n
(    //$error /errorname ) p
(get) K
( ) p
(dup) K
( /stackoverflow ) p
(eq) K
( { clear }{) p n
(        /dictstackoverflow ) S
(eq) K
( {) p n
(            ) S
(end) K
( ) p
(end) K
( ) p
(%end end end end end end end end) c n
(        } ) p
(if) K n
(    } ) p
(ifelse) K n
(    interrupt) p n
(} ) S
(def) K n
(/signalerror /.error load ) p
(def) K n
(%\(.error\)=) c n
() p n
(/errordict 28 ) S
(dict) K
( ) p
(def) K n
(errordict ) p
(begin) K n
(    /signalerror /signalerror load ) p
(def) K n
(    /handleerror {) p n
(        ) S
(%traceon) c n
(        //$error ) p
(begin) K n
(            newerror {) p n
(                /newerror ) S
(false) k
( ) p
(def) K n
(                \() p
(%%[ Error: ) str
(\) print) p n
(                errorname //=print exec) N
(                \() S
(; OffendingCommand: ) str
(\) print) p n
(                /command load //=print exec) N
(                \() S
(; Extra: ) str
(\) print) p n
(                /Extra load //=print exec) N
(                \() S
(]%%\\n) str
(\) print) p n
(                \() S
(Stack:\\n) str
(\) print) p n
(                ostack { = } ) S
(forall) K n
(                \() p
(ExecStack:\\n) str
(\) print) p n
(                estack { = } ) S
(forall) K n
(                flush) p n
(            } ) S
(if) K n
(        ) p
(end) K n
(err.ps) (Page 1/2) (Aug 22, 13 23:54) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    } ) p
(def) K n
(    /VMerror {/VMerror //.error exec} ) p
(def) K n
(    /dictfull {/dictfull //.error exec} ) p
(def) K n
(    /dictstackoverflow {/dictstackoverflow //.error exec} ) p
(def) K n
(    /dictstackunderflow {/dictstackunderflow //.error exec} ) p
(def) K n
(    /execstackoverflow {/execstackoverflow //.error exec} ) p
(def) K n
(    /invalidaccess {/invalidaccess //.error exec} ) p
(def) K n
(    /invalidexit {/invalidexit //.error exec} ) p
(def) K n
(    /invalidfileaccess {/invalidfileaccess //.error exec} ) p
(def) K n
(    /invalidfont {/invalidfont //.error exec} ) p
(def) K n
(    /invalidrestore {/invalidrestore //.error exec} ) p
(def) K n
(    /ioerror {/ioerror //.error exec} ) p
(def) K n
(    /limitcheck {/limitcheck //.error exec} ) p
(def) K n
(    /nocurrentpoint {/nocurrentpoint //.error exec} ) p
(def) K n
(    /rangecheck {/rangecheck //.error exec} ) p
(def) K n
(    /stackoverflow {/stackoverflow //.error exec} ) p
(def) K n
(    /stackunderflow {/stackunderflow //.error exec} ) p
(def) K n
(    /syntaxerror {/syntaxerror //.error exec} ) p
(def) K n
(    /timeout {/timeout /timeout //.error exec} ) p
(def) K n
(    /typecheck {/typecheck //.error exec} ) p
(def) K n
(    /undefined {/undefined //.error exec} ) p
(def) K n
(    /undefinedfilename {/undefinedfilename //.error exec} ) p
(def) K n
(    /undefinedresult {/undefinedresult //.error exec} ) p
(def) K n
(    /unmatchedmark {/unmatchedmark //.error exec} ) p
(def) K n
(    /unregistered {/unregistered //.error exec} ) p
(def) K n
(    /interrupt { stop } ) p
(def) K n
(end) N
(%\(errordict\)=) c n
() p n
(/handleerror) L
( { errordict /handleerror ) p
(get) K
( exec } ) p
(def) K n
(/interrupt) L
( { stop } ) p
(def) K n
() p n
(err.ps) (Page 2/2) (Aug 22, 13 23:54) title
border
grestore
(Printed by U-Z1\\josh) rhead
(err.ps) (70/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 71
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(%/CONSTRAINFLATNESS null def) c n
() p n
(/DEVICE <<) N
(    /dimensions [ 100 100 ]) N
(    /defaultmatrix [ 1 0 0 1 0 0 ]) N
(>> ) S
(def) K n
() p n
(/graphicsdict <<) N
(    /currgstate 12 ) S
(dict) K n
(    /gstackarray 100 ) p
(array) K n
(    /gptr -1) p n
(>> ) S
(def) K n
() p n
(/gstatetemplate) L
( {<<) p n
(    /currmatrix [ 1 0 0 1 0 0 ]) N
(    /scratchmatrix [ 1 0 0 1 0 0 ]) N
(    /currpath 1 ) S
(dict) K n
(    /clipregion 1 ) p
(dict) K n
(    /flat 1) p n
(    /linewidth 1) N
(    /linecap 0) N
(    /linejoin 2) N
(>>} ) S
(def) K n
() p n
() N
() N
(% Graphics State Operators -- Device Independent) c n
() p n
(/gstatecopy) L
( { ) p
(% dict dict) c n
(    ) p
(begin) K n
(    {) p n
(        ) S
(dup) K
( type /arraytype ) p
(eq) K
( {) p n
(            ) S
(exch) K n
(            ) p
(currentdict) K
( 1 ) p
(index) K
( ) p
(known) K
( {) p n
(                load) N
(            }{) N
(                ) S
(pop) K n
(                ) p
(dup) K
( ) p
(length) K
( ) p
(array) K n
(            } ) p
(ifelse) K n
(            ) p
(copy) K
( ) p
(pop) K n
(        }{) p n
(            ) S
(def) K n
(        } ) p
(ifelse) K n
(    } ) p
(forall) K n
(    ) p
(currentdict) K
( ) p
(end) K n
(} ) p
(def) K n
() p n
(% -  gsave  -) c n
(% push graphics state) N
(/gsave) L
( {) p n
(graphicsdict ) S
(begin) K n
(    /gptr gptr 1 ) p
(add) K
( ) p
(def) K n
(    gptr gstackarray ) p
(length) K
( ) p
(ge) K
( { error } ) p
(if) K n
(    gstackarray gptr gstate currentgstate) p n
(    ) S
(put) K n
(end) N
(} ) p
(def) K n
() p n
(% -  grestore  -) c n
(% pop graphics state) N
(/grestore) L
( {) p n
(graphicsdict ) S
(begin) K n
(    gptr -1 ) p
(gt) K
( {) p n
(        gstackarray gptr ) S
(get) K n
(            ) p
(%dup {exch = ==} forall) c n
(        currgstate gstatecopy ) p
(pop) K n
(        /gptr gptr 1 ) p
(sub) K
( ) p
(def) K n
(    } ) p
(if) K n
(end) N
(g.ps) (Page 1/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(} ) p
(def) K n
() p n
(% -  grestoreall  -) c n
(% pop to bottommost graphics state) N
(/grestoreall) L
( {) p n
(graphicsdict ) S
(begin) K n
(    /gptr -1 ) p
(def) K n
(    gstackarray 0 ) p
(get) K n
(    currgstate gstatecopy ) p
(pop) K n
(end) N
(} ) p
(def) K n
() p n
(% -  initgraphics  -) c n
(% reset graphics state parameters) N
(/initgraphics) L
( {) p n
(    gstate setgstate) N
(    initclip) N
(} ) S
(def) K n
() p n
(% -  gstate  gstate) c n
(% create graphics state object) N
(/gstate) L
( {) p n
(    gstatetemplate ) S
(dup) K
( ) p
(length) K
( ) p
(dict) K
( ) p
(copy) K n
(} ) p
(def) K n
() p n
(% gstate  setgstate  -) c n
(% set graphics state from gstate) N
(/setgstate) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( ) p
(copy) K
( ) p
(pop) K n
(} ) p
(def) K n
() p n
(% gstate  currentgstate  gstate) c n
(% copy current graphics state into gstate) N
(/currentgstate) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( ) p
(exch) K
( gstatecopy) p n
(} ) S
(def) K n
() p n
(% num  setlinewidth  -) c n
(% set line width) N
(/setlinewidth) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( ) p
(exch) K
( /linewidth ) p
(exch) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(% -  currentlinewidth  num) c n
(% return current line width) N
(/currentlinewidth) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( /linewidth ) p
(get) K n
(} ) p
(def) K n
() p n
(% int  setlinecap  -) c n
(% set shape of the ends for stroke \(0=butt, 1=round, 2=square\)) N
(/setlinecap) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( ) p
(exch) K
( /linecap ) p
(exch) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(% -  currentlinecap  int) c n
(% return current line cap) N
(/currentlinecap) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( /linecap ) p
(get) K n
(} ) p
(def) K n
() p n
(% int  setlinejoin  -) c n
(% set shape of corners for stroke \(0=miter, 1=round, 2=bevel\)) N
(/setlinejoin) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( ) p
(exch) K
( /linejoin ) p
(exch) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(% -  currentlinejoin  int) c n
(% return current line join) N
(g.ps) (Page 2/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (71/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 72
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/currentlinejoin) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( /linejoin ) p
(get) K n
(} ) p
(def) K n
() p n
() N
() N
(% Graphics State Operators -- Device Dependent) c n
() p n
(/setflat) L
( {) p n
(    /CONSTRAINFLATNESS ) S
(where) K
({) p n
(        ) S
(pop) K
( ) p
(dup) K
( 100 ) p
(gt) K
({) p
(pop) K
( 100}) p
(if) K
( ) p
(dup) K
( .2 ) p
(lt) K
({) p
(pop) K
( .2}) p
(if) K
( } ) p
(if) K n
(    graphicsdict /currgstate ) p
(get) K
( ) p
(exch) K
( /flat ) p
(exch) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(/currentflat) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( /flat ) p
(get) K n
(} ) p
(def) K n
() p n
() N
(% Coordinate System and Matrix Operators) c n
() p n
(% -  matrix  matrix) c n
(% create identity matrix) N
(/matrix) L
( { 6 ) p
(array) K
( identmatrix } ) p
(def) K n
() p n
(% -  initmatrix  -) c n
(% set CTM to device default) N
(/initmatrix) L
( {) p n
(    matrix defaultmatrix setmatrix) N
(} ) S
(def) K n
() p n
(% matrix  identmatrix  matrix) c n
(% fill matrix with identity transform) N
(/identmatrix) L
( {) p n
(    ) S
(dup) K
( type/arraytype ne { /identmatrix cvx /typecheck signalerror } ) p
(if) K n
(    { 1 0 0 1 0 0 } ) p
(exch) K
( ) p
(copy) K n
(} ) p
(def) K n
() p n
(% matrix  defaultmatrix  matrix) c n
(% fill matrix with device default matrix) N
(/defaultmatrix) L
( {) p n
(    ) S
(dup) K
( type/arraytype ne { /defaultmatrix cvx /typecheck signalerror } ) p
(if) K n
(    DEVICE /defaultmatrix ) p
(get) K
( ) p
(exch) K
( ) p
(copy) K n
(} ) p
(def) K n
() p n
(% matrix  currentmatrix  matrix) c n
(% fill matrix with CTM) N
(/currentmatrix) L
( {) p n
(    ) S
(dup) K
( type/arraytype ne { /currentmatrix cvx /typecheck signalerror } ) p
(if) K n
(    graphicsdict /currgstate ) p
(get) K
( /currmatrix ) p
(get) K
( ) p
(exch) K
( ) p
(copy) K n
(} ) p
(def) K n
() p n
(% matrix  setmatrix  -) c n
(% replace CTM by matrix) N
(/setmatrix) L
( {) p n
(    ) S
(dup) K
( type/arraytype ne { /setmatrix cvx /typecheck signalerror } ) p
(if) K n
(    graphicsdict /currgstate ) p
(get) K
( /currmatrix ) p
(get) K
( ) p
(copy) K
( ) p
(pop) K n
(} ) p
(def) K n
() p n
(%        tx ty  translate  -       % translate userspace by \(tx, ty\)) c n
(% tx ty matrix  translate  matrix  % define translation by \(tx, ty\)) N
(/translate) L
( {) p n
(    ) S
(dup) K
( type/arraytype ne) p n
(        { ) S
(true) k
( 3 1 ) p
(roll) K
( matrix } ) p
(% no array: create array, concat later) c n
(        { ) p
(false) k
( 4 1 ) p
(roll) K
( } ) p
(% array: do not create, do not concat later) c n
(    ) p
(ifelse) K
( ) p
(% bool tx ty matrix) c n
(    ) p
(dup) K
( 0 1 ) p
(put) K n
(    ) p
(dup) K
( 1 0 ) p
(put) K n
(    ) p
(dup) K
( 2 0 ) p
(put) K n
(g.ps) (Page 3/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(dup) K
( 3 1 ) p
(put) K n
(    ) p
(dup) K
( 4 5 4 ) p
(roll) K
( ) p
(put) K n
(    ) p
(dup) K
( 5 4 3 ) p
(roll) K
( ) p
(put) K n
(    ) p
(exch) K
( { concat } ) p
(if) K n
(} ) p
(def) K n
() p n
(%        sx sy  scale  -       % scale user space by \(sx, sy\)) c n
(% sx sy matrix  scale  matrix  % define scaling by \(sx, sy\)) N
(/scale) L
( {) p n
(    ) S
(dup) K
( type/arraytype ne) p n
(        { ) S
(true) k
( 3 1 ) p
(roll) K
( matrix }) p n
(        { ) S
(false) k
( 4 1 ) p
(roll) K
( }) p n
(    ) S
(ifelse) K
( ) p
(% bool sx sy matrix) c n
(    ) p
(dup) K
( 0        ) p
(% b sx sy mat mat 0) c n
(          5 4 ) p
(roll) K
( ) p
(put) K
( ) p
(% b sy mat) c n
(    ) p
(dup) K
( 1 0 ) p
(put) K n
(    ) p
(dup) K
( 2 0 ) p
(put) K n
(    ) p
(dup) K
( 3 4 3 ) p
(roll) K
( ) p
(put) K
( ) p
(% b mat) c n
(    ) p
(dup) K
( 4 0 ) p
(put) K n
(    ) p
(dup) K
( 5 0 ) p
(put) K n
(    ) p
(exch) K
( { concat } ) p
(if) K n
(} ) p
(def) K n
() p n
(%        angle  rotate  -       % rotate user space by angle) c n
(% angle matrix  rotate  matrix  % define rotation by angle degrees) N
(/rotate) L
( {) p n
(    ) S
(dup) K
( type /arraytype ne) p n
(        { ) S
(true) k
( ) p
(exch) K
( matrix }) p n
(        { ) S
(false) k
( 3 1 ) p
(roll) K
( }) p n
(    ) S
(ifelse) K
(          ) p
(% bool ang mat) c n
(    ) p
(dup) K
( 0                 ) p
(% b ang mat mat 0) c n
(          3 ) p
(index) K
( cos ) p
(put) K
( ) p
(% b ang mat) c n
(    ) p
(dup) K
( 1 3 ) p
(index) K
( sin ) p
(put) K n
(    ) p
(dup) K
( 2 3 ) p
(index) K
( sin ) p
(neg) K
( ) p
(put) K n
(    ) p
(dup) K
( 3 4 3 ) p
(roll) K
( cos ) p
(put) K n
(    ) p
(dup) K
( 4 0 ) p
(put) K n
(    ) p
(dup) K
( 5 0 ) p
(put) K n
(    ) p
(exch) K
( { concat } ) p
(if) K n
(} ) p
(def) K n
() p n
(% matrix  concat  -) c n
(% replace CTM by matrix \\times CTM) N
(/concat) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( /currmatrix ) p
(get) K
( ) p
(dup) K
( concatmatrix ) p
(pop) K n
(} ) p
(def) K n
() p n
(% matrix1 matrix2 matrix3  concatmatrix  matrix3) c n
(% fill matrix3 with matrix1 \\times matrix2) N
(/concatmatrix) L
( {) p n
(    3 ) S
(copy) K
( type/arraytype ne ) p
(exch) K
( type/arraytype ne or ) p
(exch) K
( type/arraytype ne or) p n
(        { /concatmatrix cvx /typecheck signalerror } ) S
(if) K n
(12 ) p
(dict) K
( ) p
(begin) K n
(    /D ) p
(exch) K
( ) p
(def) K n
(    aload ) p
(pop) K
( 7 6 ) p
(roll) K
( aload ) p
(pop) K n
(    {l k j i h g f e d c b a}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    a g ) p
(mul) K
( c h ) p
(mul) K
( ) p
(add) K n
(    b g ) p
(mul) K
( d h ) p
(mul) K
( ) p
(add) K n
(    a i ) p
(mul) K
( c j ) p
(mul) K
( ) p
(add) K n
(    b i ) p
(mul) K
( d j ) p
(mul) K
( ) p
(add) K n
(    a k ) p
(mul) K
( c l ) p
(mul) K
( ) p
(add) K
( e ) p
(add) K n
(    b k ) p
(mul) K
( d l ) p
(mul) K
( ) p
(add) K
( f ) p
(add) K n
(    D astore) p n
(end) K n
(} ) p
(def) K n
() p n
(%        x y  transform  x' y'  % transform \(x,y\) by CTM) c n
(% x y matrix  transform  x' y'  % transform \(x,y\) by matrix) N
(/transform) L
( {) p n
(12 ) S
(dict) K
( ) p
(begin) K n
(g.ps) (Page 4/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (72/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 73
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(dup) K
( type/arraytype ne { graphicsdict /currgstate ) p
(get) K
( /currmatrix ) p
(get) K
( } ) p
(if) K n
(    aload ) p
(pop) K
( ) p
(% x y a b c d e f) c n
(    {f e d c b a y x}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    a x ) p
(mul) K
( c y ) p
(mul) K
( ) p
(add) K
( e ) p
(add) K n
(    b x ) p
(mul) K
( d y ) p
(mul) K
( ) p
(add) K
( f ) p
(add) K n
(end) N
(} ) p
(def) K n
() p n
(%        dx dy  dtransform  dx' dy'  % transform distance \(dx,dy\) by CTM) c n
(% dx dy matrix  dtransform  dx' dy'  % transform distance \(dx,dy\) by matrix) N
(/dtransform) L
( {) p n
(12 ) S
(dict) K
( ) p
(begin) K n
(    ) p
(dup) K
( type/arraytype ne { graphicsdict /currgstate ) p
(get) K
( /currmatrix ) p
(get) K
( } ) p
(if) K n
(    aload ) p
(pop) K
( ) p
(% x y a b c d e f) c n
(    ) p
(pop) K
( ) p
(pop) K
( ) p
(% x y a b c d) c n
(    {d c b a y x}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    a x ) p
(mul) K
( c y ) p
(mul) K
( ) p
(add) K n
(    b x ) p
(mul) K
( d y ) p
(mul) K
( ) p
(add) K n
(end) N
(} ) p
(def) K n
() p n
(%        x' y'  itransform  x y  % inverse transform \(x',y'\) by CTM) c n
(% x' y' matrix  itransform  x y  % inverse transform \(x',y'\) by matrix) N
(/itransform) L
( {) p n
(12 ) S
(dict) K
( ) p
(begin) K n
(    ) p
(dup) K
( type/arraytype ne { graphicsdict /currgstate ) p
(get) K
( /currmatrix ) p
(get) K
( } ) p
(if) K n
(    ) p
(%graphicsdict /currgstate get /scratchmatrix get copy invertmatrix transform) c n
(    aload ) p
(pop) K
( {f e d c b a y x}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    a d ) p
(mul) K
( b c ) p
(mul) K
( ) p
(sub) K n
(    ) p
(%\(discr:\)print dup =) c n
(    ) p
(dup) K
( 0 ) p
(eq) K
( { ) p
(end) K
( /itransform cvx /undefinedresult signalerror } ) p
(if) K n
(    1 ) p
(exch) K
( ) p
(div) K n
(    /invdet ) p
(exch) K
( ) p
(def) K n
(    d x ) p
(mul) K
( b y ) p
(mul) K
( ) p
(sub) K
( c f ) p
(mul) K
( ) p
(add) K
( d e ) p
(mul) K
( ) p
(sub) K
( invdet ) p
(mul) K n
(    c x ) p
(mul) K
( ) p
(neg) K
( a y ) p
(mul) K
( ) p
(add) K
( b e ) p
(mul) K
( ) p
(add) K
( a f ) p
(mul) K
( ) p
(sub) K
( invdet ) p
(mul) K n
(end) N
(} ) p
(def) K n
() p n
(%        dx' dy'  idtransform  dx dy  % inverse transform distance \(dx',dy'\) by ) c n
(CTM) N
(% dx' dy' matrix  idtransform  dx dy  % inverse transform distance \(dx',dy'\) by ) N
(matrix) N
(/idtransform) L
( {) p n
(12 ) S
(dict) K
( ) p
(begin) K n
(    ) p
(dup) K
( type/arraytype ne { graphicsdict /currgstate ) p
(get) K
( /currmatrix ) p
(get) K
( } ) p
(if) K n
(    aload ) p
(pop) K
( ) p
(% x y a b c d e f) c n
(    ) p
(pop) K
( ) p
(pop) K
( ) p
(% x y a b c d) c n
(    {d c b a y x}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    a d ) p
(mul) K
( b c ) p
(mul) K
( ) p
(sub) K n
(    ) p
(dup) K
( 0 ) p
(eq) K
( { ) p
(end) K
( /idtransform cvx /undefinedresult signalerror } ) p
(if) K n
(    1 ) p
(exch) K
( ) p
(div) K n
(    /invdet ) p
(exch) K
( ) p
(def) K n
(    d x ) p
(mul) K
( b y ) p
(mul) K
( ) p
(sub) K
( invdet ) p
(mul) K n
(    c x ) p
(mul) K
( ) p
(neg) K
( a y ) p
(mul) K
( ) p
(add) K
( invdet ) p
(mul) K n
(end) N
(} ) p
(def) K n
() p n
(% matrix1 matrix2  invertmatrix  matrix2) c n
(% fill matrix2 with inverse of matrix1) N
(% revised using example at) N
(%   https://groups.google.com/d/msg/comp.lang.postscript/JuclKJjfNRQ/hs5OV6Widu8) N
(J) N
(/invertmatrix) L
( {) p n
(    2 ) S
(copy) K
( type/arraytype ne ) p
(exch) K
( type/arraytype ne or) p n
(    { /invertmatrix cvx /typecheck signalerror } ) S
(if) K n
(12 ) p
(dict) K
( ) p
(begin) K n
(    ) p
(exch) K
( aload ) p
(pop) K
( {f e d c b a}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    a d ) p
(mul) K
( b c ) p
(mul) K
( ) p
(sub) K n
(    ) p
(dup) K
( 0 ) p
(eq) K
( { A ) p
(end) K
( /invertmatrix cvx /undefinedresult signalerror } ) p
(if) K n
(g.ps) (Page 5/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    1 ) p
(exch) K
( ) p
(div) K n
(    /invdet ) p
(exch) K
( ) p
(def) K n
(    d invdet ) p
(mul) K n
(    b ) p
(neg) K
( invdet ) p
(mul) K n
(    c ) p
(neg) K
( invdet ) p
(mul) K n
(    a invdet ) p
(mul) K n
(    c f ) p
(mul) K
( d e ) p
(mul) K
( ) p
(sub) K
( invdet ) p
(mul) K n
(    b e ) p
(mul) K
( a f ) p
(mul) K
( ) p
(sub) K
( invdet ) p
(mul) K n
(    7 -1 ) p
(roll) K n
(    astore) p n
(end) K n
(} ) p
(def) K n
() p n
() N
() N
(% path == <<) c n
(%             0 << subpath0 >>) N
(%             1 << %subpath1) N
(%                   0  << elem0 /move >> %first elem must be /move) N
(%                   1  << elem1 >>) N
(%               >>) N
(%         >>) N
(% A /move element will always start a new subpath) N
(% Any other element appends to the last subpath) N
() p n
(% Path Construction Operators) c n
() p n
(% -  newpath  -) c n
(% initialize current path to be empty) N
(/newpath) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K n
(        /currpath 1 ) p
(dict) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(% -  currentpoint  x y) c n
(% return current point coordinates) N
(/currentpoint) L
( {) p n
(    cpath ) S
(dup) K
( ) p
(length) K
( 0 ) p
(eq) K
( {) p n
(        ) S
(pop) K
( /currentpoint cvx /nocurrentpoint signalerror) p n
(    }{) N
(        ) S
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
( ) p
(% last-subpath) c n
(        ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
( ) p
(% last-elem) c n
(        /data ) p
(get) K
( ) p
(dup) K
( ) p
(length) K
( 2 ) p
(sub) K
( 2 getinterval ) p
(% last data pair) c n
(        aload ) p
(pop) K
( itransform) p n
(    } ) S
(ifelse) K n
(} ) p
(def) K n
() p n
(/cpath) L
( { graphicsdict /currgstate ) p
(get) K
( /currpath ) p
(get) K
( } ) p
(def) K n
() p n
(/addtopath) L
( { ) p
(% << /data [...] /cmd /... >> <<path>>) c n
(    ) p
(%\(addtopath\)=) c n
(    ) p
(%\(addtopath start pstack:\)= pstack\(\)=) c n
(    ) p
(dup) K
( ) p
(length) K
( 0 ) p
(eq) K
( {                       ) p
(% elem path) c n
(        1 ) p
(index) K
( /cmd ) p
(get) K
( /move ) p
(eq) K
( {         ) p
(% elem path) c n
(            ) p
(%\(New Path\)=) c n
(            << 0 4 3 ) p
(roll) K
( >> ) p
(% new subpath  % <path> <subpath>) c n
(            0 ) p
(exch) K
( ) p
(put) K
(                      ) p
(%) c n
(        }{) p n
(            /addtopath cvx /nocurrentpoint signalerror) N
(        } ) S
(ifelse) K n
(    }{                                  ) p
(% elem path) c n
(        1 ) p
(index) K
( /cmd ) p
(get) K
( /move ) p
(eq) K
( {     ) p
(% elem path) c n
(            ) p
(dup) K
( ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
(    ) p
(% elem path last-subpath) c n
(            ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
(        ) p
(% elem path last-elem-of-last-subpath) c n
(            ) p
(dup) K
( /cmd ) p
(get) K
( /move ) p
(eq) K
( { ) p
(% elem path last-elem) c n
(                ) p
(%\(Merge /move\)=) c n
(                3 1 ) p
(roll) K
( ) p
(pop) K
(            ) p
(% last-elem elem) c n
(                /data ) p
(get) K
( /data ) p
(exch) K
( ) p
(put) K n
(            }{                          ) p
(% elem path last-elem) c n
(g.ps) (Page 6/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (73/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 74
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                ) p
(%\(New subpath\)=) c n
(                ) p
(pop) K
(                     ) p
(% elem path) c n
(                ) p
(dup) K
( ) p
(length) K
( 3 2 ) p
(roll) K
(     ) p
(% <path> n <elem>) c n
(                << 0 3 2 ) p
(roll) K
( >>        ) p
(% <path> n <<0 <elem>>>        % new sub) c n
(path) N
(                ) p
(%pstack\(\)=) c n
(                ) p
(put) K n
(            } ) p
(ifelse) K n
(        }{                              ) p
(% elem path) c n
(            ) p
(%\(Append elem\)=) c n
(            ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
(        ) p
(% elem last-subpath) c n
(            ) p
(dup) K
( ) p
(length) K
(                  ) p
(% elem last-subpath key) c n
(            3 2 ) p
(roll) K n
(            ) p
(%pstack\(\)=) c n
(            ) p
(put) K
(     ) p n
(        } ) S
(ifelse) K n
(    } ) p
(ifelse) K n
(    ) p
(%\(addtopath final pstack:\)= pstack\(\)=) c n
(    ) p
(%\(addtopath exit\)=) c n
(} ) p
(def) K n
() p n
(% x y  moveto  -) c n
(% set current point to \(x,y\)) N
(/moveto) L
( {) p n
(    transform) N
(    2 ) S
(array) K
( astore) p n
(    << /data 3 2 ) S
(roll) K
( /cmd /move >> cpath addtopath) p n
(} ) S
(def) K n
() p n
(% dx dy  rmoveto  -) c n
(% relative moveto) N
(/rmoveto) L
( {) p n
(    currentpoint) N
(    3 2 ) S
(roll) K
( ) p
(add) K n
(    3 1 ) p
(roll) K
( ) p
(add) K
( ) p
(exch) K n
(    ) p
(moveto) K n
(} ) p
(def) K n
() p n
(% x y  lineto  -) c n
(% append straight line to \(x,y\)) N
(/lineto) L
( {) p n
(    transform) N
(    2 ) S
(array) K
( astore) p n
(    << /data 3 2 ) S
(roll) K
( /cmd /line >> cpath addtopath) p n
(} ) S
(def) K n
() p n
(% dx dy  rlineto  -) c n
(% relative lineto) N
(/rlineto) L
( {) p n
(    currentpoint) N
(    3 2 ) S
(roll) K
( ) p
(add) K n
(    3 1 ) p
(roll) K
( ) p
(add) K
( ) p
(exch) K n
(    ) p
(lineto) K n
(} ) p
(def) K n
() p n
(% x1 y1 x2 y2 x3 y3  curveto  -) c n
(% append Bezier cubic section) N
(/curveto) L
( {) p n
(    3 { 6 2 ) S
(roll) K
( transform } repeat) p n
(    6 ) S
(array) K
( astore) p n
(    << /data 3 2 ) S
(roll) K
( /cmd /curve >> cpath addtopath) p n
(} ) S
(def) K n
() p n
(% dx1 dy1 dx2 dy2 dx3 dy3  rcurveto  -) c n
(% relative curveto) N
(/rcurveto) L
( {) p n
(    3 {) N
(        6 2 ) S
(roll) K
( currentpoint) p n
(        3 2 ) S
(roll) K
( ) p
(add) K n
(g.ps) (Page 7/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        3 1 ) p
(roll) K
( ) p
(add) K
( ) p
(exch) K n
(    } repeat) p n
(    ) S
(curveto) K n
(} ) p
(def) K n
() p n
(% -  closepath  -) c n
(% connect subpath back to its starting point) N
(/closepath) L
( {) p n
(    cpath ) S
(length) K
( 0 ) p
(gt) K
( {) p n
(        cpath ) S
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
( ) p
(% subpath) c n
(        ) p
(dup) K
( ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
( ) p
(% subpath last-elem) c n
(        /cmd ) p
(get) K
( /close ) p
(eq) K
( { ) p
(% subpath) c n
(            ) p
(pop) K n
(        }{                   ) p
(% subpath) c n
(            0 ) p
(get) K
( /data ) p
(get) K
( ) p
(% subpath [data]) c n
(            << /data 3 2 ) p
(roll) K
( /cmd /close >> cpath addtopath) p n
(        } ) S
(ifelse) K n
(    } ) p
(if) K n
(} ) p
(def) K n
() p n
(/median) L
( { ) p
(% P0 P3 = x0 y0 x1 y1) c n
(    3 -1 ) p
(roll) K
( ) p
(add) K
( .5 ) p
(mul) K
( ) p
(% x0 x1 y0+y1/2) c n
(    3 1 ) p
(roll) K
( ) p
(add) K
( .5 ) p
(mul) K
(  ) p
(% \(y0+y1\)/2 \(x0+x1\)/2) c n
(    ) p
(exch) K
( ) p
(% \(1/2\)\(P0+P3\)) c n
(} ) p
(def) K n
() p n
(/dist) L
( { ) p
(% P1 P2 = x1 y1 x2 y2) c n
(    3 -1 ) p
(roll) K
( ) p
(sub) K
( ) p
(dup) K
( ) p
(mul) K
( ) p
(% x1 x2 \(y2-y1\)^2) c n
(    3 1 ) p
(roll) K
( ) p
(exch) K
( ) p
(sub) K
( ) p
(dup) K
( ) p
(mul) K
( ) p
(% \(y2-y1\)^2 \(x2-x1\)^2) c n
(    ) p
(add) K
( sqrt ) p
(% dist) c n
(} ) p
(def) K n
() p n
(%calculate the pythagorean distance between the) c n
(% midpoint of the bezier curve and the midpoint of the straight line) N
(/checkflat) L
( { ) p
(% P0 P1 P2 P3) c n
(    8 ) p
(copy) K n
(    ) p
(exch) K
( .125 ) p
(mul) K
( ) p
(exch) K
( .125 ) p
(mul) K
( 8 2 ) p
(roll) K
( ) p
(% \(1/8\)P3 P0 P1 P2) c n
(    ) p
(exch) K
( .375 ) p
(mul) K
( ) p
(exch) K
( .375 ) p
(mul) K
( 8 2 ) p
(roll) K
( ) p
(% \(3/8\)P2 \(1/8\)P3 P0 P1) c n
(    ) p
(exch) K
( .375 ) p
(mul) K
( ) p
(exch) K
( .375 ) p
(mul) K
( 8 2 ) p
(roll) K
( ) p
(% \(3/8\)P1 \(3/8\)P2 \(1/8\)P3 P0) c n
(    ) p
(exch) K
( .125 ) p
(mul) K
( ) p
(exch) K
( .125 ) p
(mul) K
( 8 2 ) p
(roll) K
( ) p
(% \(1/8\)P0 \(3/8\)P1 \(3/8\)P2 \(1/8\)P3) c n
(    3 -1 ) p
(roll) K
( ) p
(add) K
( 3 1 ) p
(roll) K
( ) p
(add) K
( ) p
(exch) K
(      ) p
(%                        +) c n
(    3 -1 ) p
(roll) K
( ) p
(add) K
( 3 1 ) p
(roll) K
( ) p
(add) K
( ) p
(exch) K
(      ) p
(%                +) c n
(    3 -1 ) p
(roll) K
( ) p
(add) K
( 3 1 ) p
(roll) K
( ) p
(add) K
( ) p
(exch) K
(      ) p
(%        +) c n
(    10 2 ) p
(roll) K
(                            ) p
(% B\(1/2\) P0 P1 P2 P3) c n
(    8 2 ) p
(roll) K
( ) p
(pop) K
( ) p
(pop) K
( ) p
(pop) K
( ) p
(pop) K
(             ) p
(% B\(1/2\) P0 P3) c n
(    median ) p
(% B\(1/2\) \(1/2\)\(P0+P3\)) c n
(    dist) p n
(} ) S
(def) K n
() p n
(/getpair) L
( { ) p
(% xN yN .. x0 y0 N  getpair  xN yN .. x0 y0 xN yN) c n
(               ) p
(% a0 a1 b0 b1 1) c n
(    2 ) p
(mul) K
(      ) p
(% a0 a1 b0 b1 2) c n
(    2 ) p
(add) K
( ) p
(dup) K
(  ) p
(% a0 a1 b0 b1 4 4) c n
(    ) p
(index) K
(      ) p
(% a0 a1 b0 b1 4 a0) c n
(    ) p
(exch) K
( 1 ) p
(sub) K
( ) p
(% a0 a1 b0 b1 a0 3) c n
(    ) p
(index) K
(      ) p
(% a0 a1 b0 b1 a0 a1) c n
(} ) p
(def) K n
() p n
(% P'0 = P0           = P0) c n
(% P'1 = P01          = P0 P1 median) N
(%       P12          = P1 P2 median) N
(% P'2 = P012         = P01 P12  median) N
(% P'3 = P0123 = P''0 = P012 P123 median) N
(%        P123 = P''1 = P12 P23 median) N
(%         P23 = P''2 = P2 P3 median) N
(%          P3 = P''3 = P3) N
(/chopcurve) L
( { ) p
(% <</cmd /curve /data [...]>>) c n
(    flattendict /cp ) p
(get) K
( aload ) p
(pop) K n
(    2 ) p
(index) K
( /data ) p
(get) K
( aload ) p
(pop) K n
(g.ps) (Page 8/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (74/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 75
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    checkflat ) p
(% curve-error) c n
(    ) p
(%\(checkflat\)= dup =) c n
(    currentflat ) p
(gt) K
( {) p n
(        /data ) S
(get) K
( aload ) p
(pop) K n
(        flattendict /cp ) p
(get) K
( aload ) p
(pop) K
( 8 2 ) p
(roll) K
( ) p
(% P0 P1 P2 P3) c n
(        ) p
(%\(median\)=) c n
(        ) p
(%pstack\(\)=) c n
(        3 getpair 3 getpair median ) p
(% P0 P1 P2 P3 P01) c n
(        ) p
(%\(median\)=) c n
(        3 getpair 3 getpair median ) p
(% P0 P1 P2 P3 P01 P12) c n
(        3 getpair 3 getpair median ) p
(% P0 P1 P2 P3 P01 P12 P23) c n
(        2 getpair 2 getpair median ) p
(% P0 P1 P2 P3 P01 P12 P23 P012) c n
(        2 getpair 2 getpair median ) p
(% P0 P1 P2 P3 P01 P12 P23 P012 P123) c n
(        1 getpair 1 getpair median ) p
(% P0 P1 P2 P3 P01 P12 P23 P012 P123 P0123) c n
(        ) p
(%\(median\)=) c n
(                           ) p
(%drop   % X  X  X  "  '   X   "   '    "    ') c n
(                          ) p
(%curve1  %          |  P'1     |   P'2  |    P'3) c n
(                          ) p
(%curve2  %          P"3        P"2      P"1) c n
(                      ) p
(%pair index  % 9  8  7  6  5   4   3   2    1    0) c n
(                          ) p
(%count   % 20 18 16 14 12  10  8   6    4    2) c n
(        20 -2 ) p
(roll) K
( ) p
(pop) K
( ) p
(pop) K
(         ) p
(%    P1 P2 P3 P01 P12 P23 P012 P123 P0123) c n
(        18 -2 ) p
(roll) K
( ) p
(pop) K
( ) p
(pop) K
(         ) p
(%       P2 P3 P01 P12 P23 P012 P123 P0123) c n
(        16 -2 ) p
(roll) K
( ) p
(pop) K
( ) p
(pop) K
(         ) p
(%          P3 P01 P12 P23 P012 P123 P0123) c n
(        10 -2 ) p
(roll) K
( ) p
(pop) K
( ) p
(pop) K
(         ) p
(%          P3 P01     P23 P012 P123 P0123) c n
(                                   ) p
(%          P"3 P'1    P"2 P'2 P"1 P'3) c n
(        4 -2 ) p
(roll) K
(                  ) p
(%          P"3 P'1    P"2 P'2    P'3 P"1) c n
(        8 -2 ) p
(roll) K
(                  ) p
(%          P"3 P'1       P'2    P'3 P"1 P"2) c n
(        12 -2 ) p
(roll) K
(                 ) p
(%             P'1      P'2 P'3    P"1 P"2 P"3) c n
(        6 ) p
(array) K
( astore) p n
(        << /data 3 2 ) S
(roll) K
( /cmd /curve >> ) p
(%   P'1 P'2 P'3   <P"1 P"2 P"3>) c n
(        7 1 ) p
(roll) K
(                   ) p
(%        <P"1 P"2 P"3>  P'1 P'2 P'3 ) c n
(        6 ) p
(array) K
( astore) p n
(        << /data 3 2 ) S
(roll) K
( /cmd /curve >> ) p
(%  <P"1 P"2 P"3>  <P'1 P'2 P'3>) c n
(        ) p
(dup) K
( /data ) p
(get) K
( 4 2 getinterval ) p
(exch) K
( ) p
(%  <P"1 P"2 P"3> [P'3] <P'1 P'2 P'3>) c n
(        chopcurve) p n
(        flattendict ) S
(exch) K
( /cp ) p
(exch) K
( ) p
(put) K n
(        chopcurve) p n
(    }{) N
(        ) S
(dup) K
( /data ) p
(get) K
( 4 2 getinterval flattendict ) p
(exch) K
( /cp ) p
(exch) K
( ) p
(put) K n
(        << /data 3 2 ) p
(roll) K
( /data ) p
(get) K
( 4 2 getinterval /cmd /line >>) p n
(        cpath addtopath) N
(    } ) S
(ifelse) K n
(} ) p
(def) K n
() p n
(/flattendict <<) N
(    /move {) N
(        ) S
(dup) K
( /data ) p
(get) K
( flattendict ) p
(exch) K
( /cp ) p
(exch) K
( ) p
(put) K n
(        cpath addtopath }) p n
(    /line {) N
(        ) S
(dup) K
( /data ) p
(get) K
( flattendict ) p
(exch) K
( /cp ) p
(exch) K
( ) p
(put) K n
(        cpath addtopath }) p n
(    /curve {) N
(        chopcurve) N
(        ) S
(%dup /data get 4 2 getinterval flattendict exch /cp exch put) c n
(        ) p
(%<< /data 3 2 roll /data get 4 2 getinterval /cmd /line >>) c n
(        ) p
(%cpath addtopath) c n
(    }) p n
(    /close {) N
(        ) S
(dup) K
( /data ) p
(get) K
( flattendict ) p
(exch) K
( /cp ) p
(exch) K
( ) p
(put) K n
(        cpath addtopath }) p n
(>> ) S
(def) K n
() p n
(/flattenpath) L
( {) p n
(    cpath ) S
(length) K
( 0 ) p
(gt) K
( {) p n
(        cpath ) S
(newpath) K n
(        0 1 2 ) p
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( { ) p
(% path i) c n
(            2 ) p
(copy) K
( ) p
(get) K
(             ) p
(% path i subpath_i) c n
(            0 1 2 ) p
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( { ) p
(% p i sp_i j) c n
(                2 ) p
(copy) K
( ) p
(get) K
(             ) p
(% p i sp_i j sp_i_j) c n
(g.ps) (Page 9/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                flattendict 1 ) p
(index) K
( /cmd ) p
(get) K
( ) p
(get) K
( exec) p n
(                ) S
(pop) K
(                    ) p
(% p i sp_i) c n
(            } ) p
(for) K n
(            ) p
(pop) K
( ) p
(pop) K n
(        } ) p
(for) K n
(        ) p
(pop) K n
(    } ) p
(if) K n
(} ) p
(def) K n
() p n
(/reversedict <<) N
(    /close { ) S
(% p i sp_i j sp_i_j) c n
(        dopending) p n
(        reversedict /pending /line ) S
(put) K n
(        reversedict /isclosed ) p
(true) k
( ) p
(put) K n
(    }) p n
(    /line {) N
(        dopending) N
(        reversedict /pending /line ) S
(put) K n
(    }) p n
(    /curve {) N
(        ) S
(dup) K
( /data ) p
(get) K
( ) p
(exch) K n
(        dopending) p n
(        reversedict /pending /curve ) S
(put) K n
(        reversedict /curvedata 3 2 ) p
(roll) K
( ) p
(put) K n
(    }) p n
(    /move {) N
(        reversedict /isclosed ) S
(get) K
( {) p n
(            ) S
(pop) K
( ) p
(closepath) K n
(        }{) p n
(            dopending) N
(        } ) S
(ifelse) K n
(    }) p n
(>> ) S
(def) K n
() p n
(/pendingdict <<) N
(    /move {) N
(        ) S
(dup) K
( /cmd /move ) p
(put) K n
(        ) p
(dup) K
( /data 2 ) p
(copy) K
( ) p
(get) K
( ) p
(dup) K
( ) p
(length) K
( 2 ) p
(sub) K
( 2 getinterval ) p
(put) K
( ) p
(%final point if ) c n
(curve) N
(    }) p n
(    /line {) N
(        ) S
(dup) K
( /cmd /line ) p
(put) K n
(        ) p
(dup) K
( /data 2 ) p
(copy) K
( ) p
(get) K
( ) p
(dup) K
( ) p
(length) K
( 2 ) p
(sub) K
( 2 getinterval ) p
(put) K
( ) p
(%final point if ) c n
(curve) N
(    }) p n
(    /curve {) N
(        ) S
(dup) K
( /cmd /curve ) p
(put) K n
(        ) p
(dup) K
( /data 2 ) p
(copy) K
( ) p
(get) K n
(        ) p
(dup) K
( ) p
(length) K
( 2 ) p
(sub) K
( 2 getinterval aload ) p
(pop) K
( ) p
(% el el /data x y) c n
(        reversedict /curvedata ) p
(get) K
(               ) p
(% el el /data x y arr) c n
(        aload ) p
(pop) K
( ) p
(pop) K
( ) p
(pop) K
( 4 2 ) p
(roll) K
( 6 4 ) p
(roll) K n
(        6 ) p
(array) K
( astore                           ) p
(% el el /data arr) c n
(        ) p
(put) K
(                                      ) p
(% el) c n
(    }) p n
(    /close { }) N
(>> ) S
(def) K n
(/dopending) L
( {) p n
(    pendingdict reversedict /pending ) S
(get) K
( ) p
(get) K
( exec) p n
(    cpath addtopath) N
(} ) S
(def) K n
() p n
(/reversepath) L
( {) p n
(    cpath ) S
(length) K
( 0 ) p
(gt) K
( {) p n
(        cpath ) S
(newpath) K n
(        0 1 2 ) p
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( { ) p
(% path i) c n
(            2 ) p
(copy) K
( ) p
(get) K
(             ) p
(% path i subpath_i) c n
(            reversedict /pending /move ) p
(put) K n
(            reversedict /isclosed ) p
(false) k
( ) p
(put) K n
(            ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( -1 0 { ) p
(% p i sp_i j) c n
(g.ps) (Page 10/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (75/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 76
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                2 ) p
(copy) K
( ) p
(get) K
(          ) p
(% p i sp_i j sp_i_j) c n
(                reversedict 1 ) p
(index) K
( /cmd ) p
(get) K
( ) p
(get) K
( exec) p n
(                ) S
(pop) K
(                 ) p
(% p i sp_i) c n
(            } ) p
(for) K n
(            ) p
(pop) K
( ) p
(pop) K n
(        } ) p
(for) K n
(        ) p
(pop) K n
(    } ) p
(if) K n
(} ) p
(def) K n
() p n
(/ptdiff) L
( { ) p
(% P0 P1) c n
(    3 -1 ) p
(roll) K
( ) p
(sub) K n
(    3 1 ) p
(roll) K
( ) p
(exch) K
( ) p
(sub) K
( ) p
(exch) K
( ) p
(% dx dy) c n
(} ) p
(def) K n
() p n
(/magang) L
( { ) p
(% dx dy  .  rad ang) c n
(    2 ) p
(copy) K
( ) p n
(    ) S
(dup) K
( ) p
(mul) K
( ) p
(exch) K
( ) p
(dup) K
( ) p
(mul) K
( ) p
(add) K
( sqrt) p n
(    3 1 ) S
(roll) K
( ) p
(exch) K
( atan) p n
(} ) S
(def) K n
() p n
(/ravec) L
( { ) p
(% rad ang  .  dx dy) c n
(    ) p
(dup) K
( cos 2 ) p
(index) K
( ) p
(mul) K
(  ) p
(% rad ang rad*cos\(ang\)) c n
(    3 1 ) p
(roll) K
( sin ) p
(mul) K
(     ) p
(% rad*cos\(ang\) rad*sin\(ang\)) c n
(} ) p
(def) K n
() p n
(/strokedict <<) N
(    /move {) N
(        strokedict /cp 2 ) S
(index) K
( /data ) p
(get) K
( ) p
(put) K n
(        cpath addtopath) p n
(    }) N
(    /line {) N
(        strokedict /cp ) S
(get) K
( aload ) p
(pop) K
(       ) p
(% el x0 y0) c n
(        2 ) p
(index) K
( /data ) p
(get) K
( aload ) p
(pop) K
(        ) p
(% el x0 y0 x1 y1) c n
(        2 ) p
(copy) K
( 2 ) p
(array) K
( astore strokedict /cp 3 2 ) p
(roll) K
( ) p
(put) K n
(        ptdiff                             ) p
(% el dx dy) c n
(        magang                             ) p
(% el rad ang) c n
(        currentlinewidth .5 ) p
(mul) K
( 1 ) p
(index) K
( 90 ) p
(sub) K
( ) p
(% el rad ang .5lw ang_perp) c n
(        ravec itransform ) p
(rmoveto) K
(           ) p
(% el rad ang      %rmoveto) c n
(        ) p
(%cpath ===) c n
(        2 ) p
(copy) K
( ravec itransform ) p
(rlineto) K
(    ) p
(% el rad ang      %rlineto) c n
(        ) p
(%cpath ===) c n
(        currentlinewidth 1 ) p
(index) K
( 90 ) p
(add) K
(    ) p
(% el rad ang lw -ang_perp) c n
(        ravec itransform ) p
(rlineto) K
(           ) p
(% el rad ang      %rlineto) c n
(        ) p
(%cpath ===) c n
(        180 ) p
(add) K
( ravec itransform ) p
(rlineto) K
(   ) p
(% el rad ang      %rlineto) c n
(        ) p
(%cpath ===) c n
(        ) p
(closepath) K
(                          ) p
(% el              %closepath) c n
(        ) p
(%cpath ===) c n
(        ) p
(%dup /cmd /move put) c n
(        ) p
(%cpath addtopath) c n
(        ) p
(%/data get aload pop itransform moveto) c n
(        ) p
(pop) K n
(        strokedict /cp ) p
(get) K n
(        ) p
(%aload pop) c n
(        ) p
(%itransform moveto) c n
(        << /data 3 2 ) p
(roll) K
( /cmd /move >> cpath addtopath) p n
(        ) S
(%cpath ===) c n
(    }) p n
(    /close 1 ) S
(index) K
( ) p
(%{ pop }) c n
(    /curve { ) p
(pop) K
( }) p n
(>> ) S
(def) K n
() p n
(/strokepath) L
( {) p n
(    cpath ) S
(length) K
( 0 ) p
(gt) K
( {) p n
(        cpath ) S
(newpath) K n
(        0 1 2 ) p
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( { ) p
(% path i) c n
(            2 ) p
(copy) K
( ) p
(get) K
(             ) p
(% path i subpath_i) c n
(            ) p
(dup) K
( ) p
(length) K
( 0 ) p
(gt) K
( {) p n
(g.ps) (Page 11/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(                0 1 2 ) p
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( { ) p
(% p i sp_i j) c n
(                    2 ) p
(copy) K
( ) p
(get) K
(             ) p
(% p i sp_i j sp_i_j) c n
(                    strokedict 1 ) p
(index) K
( /cmd ) p
(get) K
( ) p
(get) K
( exec) p n
(                    ) S
(pop) K
(                    ) p
(% p i sp_i) c n
(                } ) p
(for) K
(              ) p
(% p i sp_i) c n
(            } ) p
(if) K n
(            ) p
(pop) K
( ) p
(pop) K
(                ) p
(% path) c n
(        } ) p
(for) K n
(        ) p
(pop) K n
(    } ) p
(if) K n
(} ) p
(def) K n
() p n
(/maxmin) L
( {) p n
(    2 ) S
(copy) K n
(    ) p
(dup) K
( maxy ) p
(gt) K
( { /maxy ) p
(exch) K
( ) p
(def) K
( }{ ) p
(pop) K
( } ) p
(ifelse) K n
(    ) p
(dup) K
( maxx ) p
(gt) K
( { /maxx ) p
(exch) K
( ) p
(def) K
( }{ ) p
(pop) K
( } ) p
(ifelse) K n
(    ) p
(dup) K
( miny ) p
(lt) K
( { /miny ) p
(exch) K
( ) p
(def) K
( }{ ) p
(pop) K
( } ) p
(ifelse) K n
(    ) p
(dup) K
( minx ) p
(lt) K
( { /minx ) p
(exch) K
( ) p
(def) K
( }{ ) p
(pop) K
( } ) p
(ifelse) K n
(} ) p
(def) K n
() p n
(/clippath) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K n
(        ) p
(dup) K
( /clipregion ) p
(get) K n
(        /currpath ) p
(exch) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(/pathbbox) L
( {) p n
(    cpath ) S
(length) K
( 0 ) p
(eq) K
( {) p n
(        0 0 0 0) N
(    }{) N
(        << /minx 16#7fffffff /miny 1 ) S
(index) K n
(            /maxx 1 ) p
(index) K
( ) p
(neg) K
( /maxy 1 ) p
(index) K
( >> ) p
(begin) K n
(        cpath) p n
(        0 1 2 ) S
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( {) p n
(            2 ) S
(copy) K
( ) p
(get) K n
(            0 1 2 ) p
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( {) p n
(                2 ) S
(copy) K
( ) p
(get) K n
(                /data ) p
(get) K n
(                aload ) p
(length) K
( 2 idiv) p n
(                { maxmin } repeat) N
(                ) S
(pop) K n
(            } ) p
(for) K n
(            ) p
(pop) K
( ) p
(pop) K n
(        } ) p
(for) K n
(        ) p
(pop) K n
(        minx miny maxx maxy) p n
(        ) S
(end) K n
(    } ) p
(ifelse) K n
(} ) p
(def) K n
() p n
(% move line curve close  pathforall  -) c n
(% enumerate current path) N
(/pathforall) L
( {) p n
(5 ) S
(dict) K
( ) p
(begin) K n
(    {close curve line move}{) p
(exch) K
( ) p
(def) K
(}) p
(forall) K n
(    0 1 cpath ) p
(length) K
( 1 ) p
(sub) K
( {) p n
(        /cp ) S
(exch) K
( ) p
(def) K n
(        0 1 cpath cp ) p
(get) K
( ) p
(% subpath) c n
(        ) p
(length) K
( 1 ) p
(sub) K
( {) p n
(            cpath cp ) S
(get) K
( ) p
(exch) K
( ) p
(get) K
( ) p
(% elem) c n
(            ) p
(dup) K
( /cmd ) p
(get) K
( /close ne {) p n
(                ) S
(dup) K
( /data ) p
(get) K
( ) p
(% elem [data]) c n
(                aload ) p
(length) K
(  ) p
(% elem d a t a n) c n
(                1 ) p
(add) K
( -1 ) p
(roll) K
( ) p
(% d a t a elem) c n
(            } ) p
(if) K n
(            /cmd ) p
(get) K
( cvx exec) p n
(        } ) S
(for) K n
(    } ) p
(for) K n
(end) N
(g.ps) (Page 12/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (76/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 77
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(} ) p
(def) K n
() p n
(/initclip) L
( {) p n
(    graphicsdict /currgstate ) S
(get) K
( ) p n
(        ) S
(dup) K
( /currpath ) p
(get) K
(   ) p
(% currpath) c n
(        ) p
(exch) K
( /currmatrix ) p
(get) K
( ) p
(% currmatrix) c n
() p n
(    ) S
(newpath) K n
(    matrix setmatrix) p n
(    DEVICE /dimensions ) S
(get) K n
(    aload ) p
(pop) K n
(    0 0 ) p
(moveto) K n
(    1 ) p
(index) K
( 0 ) p
(rlineto) K n
(    0 ) p
(exch) K
( ) p
(rlineto) K n
(    ) p
(neg) K
( 0 ) p
(rlineto) K n
(    ) p
(closepath) K n
() p n
(    graphicsdict /currgstate ) S
(get) K n
(        ) p
(dup) K
( ) p
(dup) K
( /currpath ) p
(get) K
( /clipregion ) p
(exch) K
( ) p
(put) K n
(        ) p
(dup) K
( 3 2 ) p
(roll) K
( /currmatrix ) p
(exch) K
( ) p
(put) K n
(        ) p
(exch) K
( /currpath ) p
(exch) K
( ) p
(put) K n
(} ) p
(def) K n
() p n
(/clip) L
( {) p n
(    doclip) N
(    graphicsdict /currgstate ) S
(get) K n
(    ) p
(dup) K
( /currpath ) p
(get) K
( /clipregion ) p
(exch) K
( ) p
(put) K n
(    ) p
(newpath) K n
(} ) p
(def) K n
() p n
(\() S
(clip.ps) str
(\)run) p n
() N
(%clip the current path by the clipregion) c n
(% convert the path to an array of polygons \(arrays of points\)) N
(% convert clipregion to array of polygons) N
(% traverse the clipregion) N
(%    convert line to [A B C] form) N
(%    feed polygon and line to hodgman-sutherland,) N
(%       receiving new polygon.) N
(/doclip) L
( { 4 ) p
(dict) K
( ) p
(begin) K n
() p n
(    ) S
(closepath) K n
(    flattenpath) p n
(    [ { 2 ) S
(array) K
( astore [ ) p
(exch) K
( } { 2 ) p
(array) K
( astore } {} {]} pathforall ]) p n
(    /PA ) S
(exch) K
( ) p
(def) K
( ) p
(% polygon array) c n
() p n
(    clippath) N
(    [ { 2 ) S
(array) K
( astore [ ) p
(exch) K
( } { 2 ) p
(array) K
( astore } {} {]} pathforall ]) p n
(    /CR ) S
(exch) K
( ) p
(def) K
( ) p
(% clippath array) c n
() p n
(    \() S
(PA: ) str
(\)print PA ==) p n
(    \() S
(CR: ) str
(\)print CR ==) p n
() N
(    CR { ) S
(% one clipping polygon) c n
(        ) p
(dup) K
( ) p
(dup) K
( ) p
(length) K
( 1 ) p
(sub) K
( ) p
(get) K
( ) p
(% polygon final-point) c n
(        /U ) p
(exch) K
( ) p
(def) K n
(        {) p n
(            /V ) S
(exch) K
( ) p
(def) K n
(            [ U aload ) p
(pop) K
( V aload ) p
(pop) K
( p2abc ]  ) p
(% clip-line) c n
(            /CL ) p
(exch) K
( ) p
(def) K n
(            CL ==) p n
() N
(            /PA [ PA { ) S
(% one subject polygon) c n
(                CL hodgman-sutherland) p n
(            } ) S
(forall) K
( ] ) p
(def) K n
() p n
(            /U V ) S
(def) K n
(        } ) p
(forall) K n
(    } ) p
(forall) K n
(g.ps) (Page 13/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(newpath) K n
(    PA ==) p n
(    PA {) N
(        ) S
(dup) K
( ) p
(length) K
( 0 ) p
(gt) K
( {) p n
(            ) S
(dup) K
( 0 ) p
(get) K
( << /data 3 2 ) p
(roll) K
( /cmd /move >> cpath addtopath) p n
(            1 1 ) S
(index) K
( ) p
(length) K
( 1 ) p
(sub) K
( getinterval {) p n
(                << /data 3 2 ) S
(roll) K
( /cmd /line >> cpath addtopath) p n
(            } ) S
(forall) K n
(            ) p
(closepath) K n
(        }{) p n
(            ) S
(pop) K n
(        } ) p
(ifelse) K n
(    } ) p
(forall) K n
() p n
(end) K
( } ) p
(def) K n
() p n
(% Painting Operators) c n
() p n
(% -  erasepage  -) c n
(% paint current page white) N
(/erasepage) L
( {) p n
(    ) S
(gsave) K n
(        0 ) p
(setgray) K n
(        clippath ) p
(fill) K n
(    ) p
(grestore) K n
(} ) p
(def) K n
() p n
(% -  fill  -) c n
(% fill current path with current color) N
(/fill) L
( {) p n
(    doclip) N
(} ) S
(def) K n
() p n
(% -  eofill  -) c n
(% fill using even-odd rule) N
(/eofill) L
( {) p n
(} ) S
(def) K n
() p n
(% -  stroke  -) c n
(% draw line along current path) N
(/stroke) L
( {) p n
(    strokepath ) S
(fill) K n
(} ) p
(def) K n
() p n
(/TESTGRAPHICS ) S
(where) K
( {) p
(pop) K
(}{ currentfile flushfile} ) p
(ifelse) K n
() p n
(initgraphics) N
() N
(%currentfile flushfile) c n
(5 5 ) p
(moveto) K
( currentpoint pstack clear) p n
(90 matrix ) S
(rotate) K
( pstack clear) p n
(10 10 matrix ) S
(scale) K
( pstack clear) p n
(300 400 matrix ) S
(translate) K
( pstack clear) p n
(matrix matrix matrix concatmatrix pstack clear) N
() N
(2 0 ) S
(translate) K n
(1 1 ) p
(moveto) K n
(.25 .25 ) p
(scale) K n
(90 ) p
(rotate) K
( currentpoint pstack clear) p n
(90 ) S
(rotate) K
( currentpoint pstack clear) p n
(90 ) S
(rotate) K
( currentpoint pstack clear) p n
(90 ) S
(rotate) K
( currentpoint pstack clear) p n
() N
(/args) L
({-1 1{-1 ) p
(roll) K
( =}) p
(for) K
(}) p
(def) K n
() p n
(20 20 ) S
(scale) K n
(10 10 ) p
(lineto) K n
(20 20 ) p
(rlineto) K n
(0 0 1 1 2 0 rcurveto) p n
(g.ps) (Page 14/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (77/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 78
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(closepath) K n
() p n
(newpath) K n
(0 0 ) p
(moveto) K n
(20 20 40 20 60 0 ) p
(curveto) K n
(closepath) N
() p n
(newpath) K n
(0 0 ) p
(moveto) K n
(50 50 ) p
(lineto) K n
(100 0 ) p
(lineto) K n
(closepath) N
() p n
(\(\)=) N
({ \() S
(moveto) str
(\) 3 args }) p n
({ \() S
(lineto) str
(\) 3 args }) p n
({ \() S
(curveto) str
(\) 7 args }) p n
({ \() S
(closepath) str
(\) 1 args }) p n
(4 ) S
(copy) K
( ) p n
(\() S
(pathforall) str
(\)=) p n
(pathforall) N
() N
(gsave) K n
(    \() p
(newpath) str
(\)=) p n
(    ) S
(newpath) K n
(    \() p
(pathforall) str
(\)=) p n
(    4 ) S
(copy) K
( pathforall) p n
(grestore) K n
() p n
(\() S
(pathforall) str
(\)=) p n
(4 ) S
(copy) K
( pathforall) p n
() N
(\() S
(flattenpath) str
(\)=) p n
(flattenpath) N
(\() S
(pathforall) str
(\)=) p n
(4 ) S
(copy) K
( pathforall) p n
() N
(\() S
(reversepath) str
(\)=) p n
(reversepath) N
(\() S
(pathforall) str
(\)=) p n
(4 ) S
(copy) K
( pathforall) p n
() N
(\() S
(strokepath) str
(\)=) p n
(strokepath) N
(\() S
(pathforall) str
(\)=) p n
(pathforall) N
() N
(clear pathbbox pstack clear) N
() N
() N
(initclip) N
() N
(newpath) K n
(0 0 ) p
(moveto) K n
(10 0 ) p
(lineto) K n
(10 10 ) p
(lineto) K n
(0 10 ) p
(lineto) K n
(closepath) N
(\() p
(clip) str
(\)=) p n
(clip) K n
() p n
(\() S
(newpath) str
(\)=) p n
(newpath) K n
(5 -1 ) p
(moveto) K n
(11 5 ) p
(lineto) K n
(5 11 ) p
(lineto) K n
(-1 5 ) p
(lineto) K n
(closepath) N
() p n
(g.ps) (Page 15/16) (Sep 04, 13 0:16) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(\() p
(doclip) str
(\)=) p n
(doclip) N
(\() S
(pathforall) str
(\)=) p n
({ \() S
(moveto) str
(\) 3 args }) p n
({ \() S
(lineto) str
(\) 3 args }) p n
({ \() S
(curveto) str
(\) 7 args }) p n
({ \() S
(closepath) str
(\) 1 args }) p n
(pathforall) N
() N
() N
(g.ps) (Page 16/16) (Sep 04, 13 0:16) title
border
grestore
(Printed by U-Z1\\josh) rhead
(g.ps) (78/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 79
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/p2abc { ) S
(% x0 y0 x1 y1) c n
(    ) p
(exch) K
( 3 ) p
(index) K
( ) p
(sub) K n
(    ) p
(exch) K
( 2 ) p
(index) K
( ) p
(sub) K
( ) p
(% x0 y0 dx dy) c n
(    ) p
(exch) K
(         ) p
(% x0 y0 A B) c n
(    ) p
(neg) K n
(    2 ) p
(copy) K
( 6 2 ) p
(roll) K
(  ) p
(% A B x0 y0 A B) c n
(    3 -1 ) p
(roll) K
( ) p
(mul) K
(    ) p
(% A B x0 A By0) c n
(    3 1 ) p
(roll) K
( ) p
(mul) K
(     ) p
(% A B By0 Ax0) c n
(    ) p
(add) K
( ) p
(neg) K
(          ) p
(% A B C) c n
(} ) p
(def) K n
() p n
(% following code is from Bill Casselman's Mathematical Illustrations, ch. 5.) c n
() p n
(/evaluate) L
( { ) p
(%    x y [A B C]) c n
(    aload ) p
(pop) K
(    ) p
(% x y A B C) c n
(    5 1 ) p
(roll) K
(     ) p
(% C x y A B) c n
(    3 2 ) p
(roll) K
( ) p
(mul) K
( ) p
(% C x A By) c n
(    3 1 ) p
(roll) K
( ) p
(mul) K
( ) p
(% C By Ax) c n
(    ) p
(add) K
( ) p
(add) K n
(} ) p
(def) K n
() p n
(% polygon [A B C]  .  new-polygon) c n
(/hodgman-sutherland) L
( { 4 ) p
(dict) K
( ) p
(begin) K n
(    /f ) p
(exch) K
( ) p
(def) K n
(    /p ) p
(exch) K
( ) p
(def) K n
(    /n p ) p
(length) K
( ) p
(def) K n
(    \() p
(n=) str
(\)print n =) p n
(    n 0 ) S
(gt) K
( {) p n
() N
(    /P p n 1 ) S
(sub) K
( ) p
(get) K
( ) p
(def) K n
(    /d P ) p
(length) K
( 1 ) p
(sub) K
( ) p
(def) K n
(    /fP P aload ) p
(pop) K
( f evaluate ) p
(def) K n
(    [) p n
(        p {) N
(            /Q ) S
(exch) K
( ) p
(def) K n
(            /fQ Q aload ) p
(pop) K
( f evaluate ) p
(def) K n
(            \() p
(P=) str
(\)print P ==) p n
(            \() S
(Q=) str
(\)print Q ==) p n
(            \() S
(fP=) str
(\)print fP ==) p n
(            \() S
(fQ=) str
(\)print fQ ==) p n
(            fP 0 ) S
(le) K
( {) p n
(                fQ 0 ) S
(le) K
( {) p n
(                    Q) N
(                    \() S
(Q) str
(\)=) p n
(                }{) N
(                    fP 0 ) S
(lt) K
( {) p n
(                        /QP fQ fP ) S
(sub) K
( ) p
(def) K n
(                        [) p n
(                            fQ P 0 ) S
(get) K
( ) p
(mul) K
( fP Q 0 ) p
(get) K
( ) p
(mul) K
( ) p
(sub) K
( QP ) p
(div) K n
(                            fQ P 1 ) p
(get) K
( ) p
(mul) K
( fP Q 1 ) p
(get) K
( ) p
(mul) K
( ) p
(sub) K
( QP ) p
(div) K n
(                        ]) p n
(                        \() S
(I) str
(\)=) p n
(                    } ) S
(if) K n
(                } ) p
(ifelse) K n
(            }{) p n
(                fQ 0 ) S
(le) K
( {) p n
(                    fQ 0 ) S
(lt) K
( {) p n
(                        /QP fQ fP ) S
(sub) K
( ) p
(def) K n
(                        [) p n
(                            fQ P 0 ) S
(get) K
( ) p
(mul) K
( fP Q 0 ) p
(get) K
( ) p
(mul) K
( ) p
(sub) K
( QP ) p
(div) K n
(                            fQ P 1 ) p
(get) K
( ) p
(mul) K
( fP Q 1 ) p
(get) K
( ) p
(mul) K
( ) p
(sub) K
( QP ) p
(div) K n
(                        ]) p n
(                        \() S
(I) str
(\)=) p n
(                    } ) S
(if) K n
(                    Q) p n
(                    \() S
(Q) str
(\)=) p n
(                } ) S
(if) K n
(            } ) p
(ifelse) K n
(clip.ps) (Page 1/2) (Aug 22, 13 22:48) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(            /P Q ) p
(def) K n
(            /fP fQ ) p
(def) K n
(        } ) p
(forall) K n
(    ]) p n
() N
(    }{ ) S
(% n==0) c n
(        p) p n
(    } ) S
(ifelse) K n
() p n
(end) K
( } ) p
(def) K n
() p n
(clip.ps) (Page 2/2) (Aug 22, 13 22:48) title
border
grestore
(Printed by U-Z1\\josh) rhead
(clip.ps) (79/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 80
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(%test.ps) c n
(% testing examples borrowed from the Operator Details in the PLRM, 1ed.) N
(%traceon) N
(/break) L
( { currentfile flushfile } ) p
(def) K n
() p n
(/failcount 0 ) S
(def) K n
(/fail) L
( {) p n
(    \() S
(FAIL\\n) str
(\) print) p n
(    /failcount failcount 1 ) S
(add) K
( ) p
(def) K n
(    ) p
(%break) c n
(} ) p
(def) K n
(/check) L
( {) p n
(    {} ) S
(%{ \(success\\n\) print }) c n
(    //fail) p n
(    ) S
(ifelse) K n
(} ) p
(def) K n
() p n
(\() S
(test: loading graphics...) str
(\)=) p n
(\() S
(g.ps) str
(\)run) p n
(initgraphics) N
() N
() N
([ ] ==) N
([ ] type /arraytype ) S
(eq) K
( check) p n
({ ] } stopped { $error /errorname ) S
(get) K
( /unmatchedmark ) p
(eq) K
( check }{ fail } ) p
(ifelse) K n
() p n
(/= cvx =) N
({ = } stopped { $error /errorname ) S
(get) K
( /stackunderflow ) p
(eq) K
( check }{ fail } ) p
(ifelse) K n
() p n
(/== cvx ==) N
({ == } stopped { $error /errorname ) S
(get) K
( /stackunderflow ne {fail} ) p
(if) K
( }{ fail } ) p
(if) K n
(else) N
() p n
(\() S
(abs) str
(\)=) p n
(4.5 abs 4.5 ) S
(eq) K
( check) p n
(-3 abs 3 ) S
(eq) K
( check) p n
(0 abs 0 ) S
(eq) K
( check) p n
() N
(\() S
(add) str
(\)=) p n
(3 4 ) S
(add) K
( 7 ) p
(eq) K
( check) p n
(9.9 1.1 ) S
(add) K
( 11.0 ) p
(eq) K
( check) p n
() N
(\() S
(aload) str
(\)=) p n
([23 \() S
(ab) str
(\) -6] aload) p n
(    type /arraytype ) S
(eq) K
( ) p
(exch) K n
(    type /integertype ) p
(eq) K
( and ) p
(exch) K n
(    type /stringtype ) p
(eq) K
( and ) p
(exch) K n
(    type /integertype ) p
(eq) K
( and check) p n
() N
(\() S
(anchorsearch) str
(\)=) p n
(%\(1\)=) c n
(\() p
(abbc) str
(\) \() p
(ab) str
(\) anchorsearch ) p n
(    ) S
(true) k
( ) p
(eq) K
( ) p
(exch) K n
(    \() p
(ab) str
(\) ) p
(eq) K
( and ) p
(exch) K n
(    \() p
(bc) str
(\) ) p
(eq) K
( and check) p n
(%\(2\)=) c n
(\() p
(abbc) str
(\) \() p
(bb) str
(\) anchorsearch) p n
(    ) S
(false) k
( ) p
(eq) K
( ) p
(exch) K n
(    \() p
(abbc) str
(\) ) p
(eq) K
( and check) p n
(%\(3\)=) c n
(\() p
(abbc) str
(\) \() p
(bc) str
(\) anchorsearch) p n
(    ) S
(false) k
( ) p
(eq) K
( ) p
(exch) K n
(    \() p
(abbc) str
(\) ) p
(eq) K
( and check) p n
(%\(4\)=) c n
(\() p
(abbc) str
(\) \() p
(B) str
(\) anchorsearch) p n
(    ) S
(false) k
( ) p
(eq) K
( ) p
(exch) K n
(    \() p
(abbc) str
(\) ) p
(eq) K
( and check) p n
() N
(\() S
(and) str
(\)=) p n
(test.ps) (Page 1/12) (Aug 30, 13 4:27) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(true) k
( ) p
(true) k
( and ) p
(true) k
( ) p
(eq) K
( check) p n
(true) k
( ) p
(false) k
( and ) p
(false) k
( ) p
(eq) K
( check) p n
(false) k
( ) p
(true) k
( and ) p
(false) k
( ) p
(eq) K
( check) p n
(false) k
( ) p
(false) k
( and ) p
(false) k
( ) p
(eq) K
( check) p n
(99 1 and 1 ) S
(eq) K
( check) p n
(52 7 and 4 ) S
(eq) K
( check) p n
() N
(%arc) c n
(%arcn) N
(%arcto) N
() p n
(\() S
(array) str
(\)=) p n
(3 ) S
(array) K
( ) p
(dup) K
( type /arraytype ) p
(eq) K
( check) p n
(    aload ) S
(pop) K
( null ) p
(eq) K
( ) p
(exch) K n
(    null ) p
(eq) K
( and ) p
(exch) K n
(    null ) p
(eq) K
( and check) p n
() N
(%ashow) c n
() p n
(\() S
(astore) str
(\)=) p n
(\() S
(a) str
(\) \() p
(bcd) str
(\) \() p
(ef) str
(\) 3 ) p
(array) K
( astore type /arraytype ) p
(eq) K
( check) p n
() N
(\() S
(atan) str
(\)=) p n
(%\(1\)=) c n
(0 1 atan 0.0 ) p
(eq) K
( check) p n
(%\(2\)=) c n
(1 0 atan 90.0 ) p
(eq) K
( check) p n
(%\(3\)=) c n
(-100 0 atan 270.0 ) p
(eq) K
( check) p n
(%\(4\)=) c n
(4 4 atan 45.0 ) p
(eq) K
( check) p n
() N
(%awidthshow) c n
(%banddevice) N
() p n
(\() S
(begin) str
(\)=) p n
(2 ) S
(dict) K
( ) p
(dup) K
( ) p
(begin) K
( ) p
(currentdict) K
( ) p
(eq) K
( check) p n
() N
(\() S
(bind) str
(\)=) p n
({ ) S
(add) K
( } ) p
(bind) K
( 0 ) p
(get) K
( type /operatortype ) p
(eq) K
( check) p n
() N
(\() S
(bitshift) str
(\)=) p n
(7 3 bitshift 56 ) S
(eq) K
( check) p n
(142 -3 bitshift 17 ) S
(eq) K
( check) p n
() N
(\() S
(bytesavailable) str
(\)=) p n
(currentfile bytesavailable =) N
() N
(%cachestatus) c n
() p n
(\() S
(ceiling) str
(\)=) p n
(3.2 ceiling 4.0 ) S
(eq) K
( check) p n
(-4.8 ceiling -4.0 ) S
(eq) K
( check) p n
(99 ceiling 99 ) S
(eq) K
( check) p n
() N
(%charpath) c n
() p n
(\() S
(clear) str
(\)=) p n
(7 8 6 7  5 9 0 7 6 4 6 8 77  8 6 9  7 8 6 clear) N
(count 0 ) S
(eq) K
( check) p n
() N
(\() S
(cleartomark) str
(\)=) p n
(777 [ 8 7 6 5 4 cleartomark) N
(777 ) S
(eq) K
( check) p n
() N
(%clip) c n
() p n
(\() S
(clippath) str
(\)=) p n
(clear clippath {}{}{}{} pathforall) N
(test.ps) (Page 2/12) (Aug 30, 13 4:27) title
border
grestore
(Printed by U-Z1\\josh) rhead
(test.ps) (80/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 81
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(count 0 ) p
(gt) K
( check) p n
(clear) N
() N
(%\(closefile\)=) c n
() p n
(%closepath) c n
(%concat) N
() p n
(\() S
(concatmatrix) str
(\)=) p n
(matrix matrix matrix concatmatrix) N
(aload ) S
(pop) K n
(    0 ) p
(eq) K
( check) p n
(    0 ) S
(eq) K
( check) p n
(    1 ) S
(eq) K
( check) p n
(    0 ) S
(eq) K
( check) p n
(    0 ) S
(eq) K
( check) p n
(    1 ) S
(eq) K
( check) p n
() N
(\() S
(copy) str
(\)=) p n
(1 2 3 2 ) S
(copy) K
( ) p n
(    count 5 ) S
(eq) K
( check) p n
(    3 ) S
(eq) K
( check) p n
(    2 ) S
(eq) K
( check) p n
(    3 ) S
(eq) K
( check) p n
(    2 ) S
(eq) K
( check) p n
(    1 ) S
(eq) K
( check) p n
(1 2 3 0 ) S
(copy) K n
(    count 3 ) p
(eq) K
( check) p n
(    clear) N
(/a1 [1 2 3] ) S
(def) K n
(a1 ) p
(dup) K
( ) p
(length) K
( ) p
(array) K
( ) p
(copy) K
( aload ) p
(pop) K n
(    3 ) p
(eq) K
( check) p n
(    2 ) S
(eq) K
( check) p n
(    1 ) S
(eq) K
( check) p n
() N
(%copypage) c n
() p n
(\() S
(cos) str
(\)=) p n
(0 cos 1.0 ) S
(eq) K
( check) p n
(90 cos 0.0 ) S
(eq) K
( check) p n
() N
(\() S
(count) str
(\)=) p n
(clear count 0 ) S
(eq) K
( check) p n
(clear 1 2 3 count 3 ) S
(eq) K
( check) p n
(clear) N
() N
(\() S
(countdictstack) str
(\)=) p n
(countdictstack =) N
() N
(\() S
(countexecstack) str
(\)=) p n
(countexecstack =) N
() N
(\() S
(counttomark) str
(\)=) p n
(1 mark 2 3 counttomark 2 ) S
(eq) K
( check) p n
(clear) N
(1 mark counttomark 0 ) S
(eq) K
( check) p n
(clear) N
() N
(%currentcacheparams) c n
(%currentdash) N
() p n
(\() S
(currentdict) str
(\)=) p n
(currentdict) K
( ==) p n
() N
(\() S
(currentfile) str
(\)=) p n
(currentfile ==) N
() N
(\() S
(currentflat) str
(\)=) p n
(currentflat 0 ne check) N
(test.ps) (Page 3/12) (Aug 30, 13 4:27) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(%currentfont) c n
(%currentgray) N
(%currenthsbcolor) N
(%currentlinecap) N
(%currentlinejoin) N
() p n
(\() S
(currentlinewidth) str
(\)=) p n
(currentlinewidth 0 ) S
(ge) K
( check) p n
() N
(\() S
(currentmatrix) str
(\)=) p n
(matrix currentmatrix) N
(false) k
( ) p
(exch) K
( {) p n
(    0 ne or) N
(} ) S
(forall) K
( ) p
(true) k
( ) p
(eq) K
( check ) p
(% at least one non-zero value) c n
() p n
(%currentmiterlimit) c n
(%currentpacking) N
() p n
(\() S
(currentpoint) str
(\)=) p n
(currentpoint count 2 ) S
(eq) K
( check) p n
(clear) N
() N
(%currentrgbcolor) c n
(%currentscreen) N
(%currenttransfer) N
() p n
(%curveto) c n
() p n
(\() S
(cvi) str
(\)=) p n
(\() S
(1: \(3.3E1) str
(\) cvi 33 ) p
(eq) K
( check\)=) p n
(\() S
(3.3E1) str
(\) cvi 33 ) p
(eq) K
( check) p n
(\() S
(2: -47.8 cvi -47 eq check) str
(\)=) p n
(-47.8 cvi -47 ) S
(eq) K
( check) p n
(\() S
(3: 520.9 cvi 520 eq check) str
(\)=) p n
(520.9 cvi 520 ) S
(eq) K
( check) p n
() N
(\() S
(cvlit) str
(\)=) p n
({) S
(mul) K
(} cvlit xcheck ) p
(false) k
( ) p
(eq) K
( check) p n
() N
(\() S
(cvn) str
(\)=) p n
(\() S
(abc) str
(\) cvn /abc ) p
(eq) K
( check) p n
(\() S
(abc) str
(\) cvx cvn xcheck check) p n
() N
(\() S
(cvr) str
(\)=) p n
(\() S
(3.3E1) str
(\) cvr 33.0 ) p
(eq) K
( check) p n
() N
(\() S
(cvrs) str
(\)=) p n
(/str 10 string ) S
(def) K n
(100 8 str cvrs \() p
(144) str
(\) ) p
(eq) K
( check) p n
(200 16 str cvrs ) S
(dup) K
( \() p
(C8) str
(\) ) p
(eq) K
( ) p
(exch) K
( \() p
(c8) str
(\) ) p
(eq) K
( or check) p n
() N
(\() S
(cvs) str
(\)=) p n
(/str 20 string ) S
(def) K n
(\() p
(1: 123 456 add str cvs \(579) str
(\) ) p
(eq) K
( check\)=) p n
(123 456 ) S
(add) K
( str cvs \() p
(579) str
(\) ) p
(eq) K
( check) p n
(\() S
(2: mark str cvs \(-nostringval-) str
(\) ) p
(eq) K
(\)=) p n
(mark str cvs \() S
(-nostringval-) str
(\) ) p
(eq) K n
(\() p
(2: mark str cvs \(--nostringval--) str
(\) ) p
(eq) K
(\)=) p n
(mark str cvs \() S
(--nostringval--) str
(\) ) p
(eq) K n
(\() p
(2: mark str cvs \(-mark-) str
(\) ) p
(eq) K
( or or check\)=) p n
(mark str cvs \() S
(-mark-) str
(\) ) p
(eq) K n
(    or or check) p n
() N
(\() S
(cvx) str
(\)=) p n
([/) S
(mul) K
( cvx]cvx xcheck ) p
(true) k
( ) p
(eq) K
( check) p n
() N
(\() S
(def) str
(\)=) p n
(/ncnt 1 ) S
(def) K
( ncnt 1 ) p
(eq) K
( check) p n
(test.ps) (Page 4/12) (Aug 30, 13 4:27) title
border
grestore
(Printed by U-Z1\\josh) rhead
(test.ps) (81/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 82
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/ncnt ncnt 1 ) p
(add) K
( ) p
(def) K
( ncnt 2 ) p
(eq) K
( check) p n
() N
(\() S
(defaultmatrix) str
(\)=) p n
(matrix defaultmatrix) N
(false) k
( ) p
(exch) K
( {) p n
(    0 ne or) N
(} ) S
(forall) K
( ) p
(true) k
( ) p
(eq) K
( check ) p
(% at least one non-zero value) c n
() p n
(%definefont) c n
() p n
(\() S
(dict) str
(\)=) p n
(1 ) S
(dict) K
( type /dicttype ) p
(eq) K
( check) p n
() N
(%/dictfull) c n
() p n
(%\(dictstack\)=) c n
(%/dictstackoverflow) N
(%/dictstackunderflow) N
() p n
(\() S
(div) str
(\)=) p n
(\() S
(1: 3 2 div 1.5 eq check) str
(\)=) p n
(3 2 ) S
(div) K
( 1.5 ) p
(eq) K
( check) p n
(\() S
(2: 4 2 div 2.0 eq check) str
(\)=) p n
(4 2 ) S
(div) K
( 2.0 ) p
(eq) K
( check) p n
() N
(%dtransform) c n
(1 1 matrix dtransform) p n
(    1 ) S
(eq) K
( check) p n
(    1 ) S
(eq) K
( check) p n
() N
(\() S
(dup) str
(\)=) p n
(5 ) S
(dup) K
( 5 ) p
(eq) K
( check) p n
(    5 ) S
(eq) K
( check) p n
() N
(%\(echo\)=) c n
() p n
(\() S
(end) str
(\)=) p n
(end) K
( ) p
(%currentdict userdict eq check) c n
() p n
(%eoclip) c n
(%eofill) N
() p n
(\() S
(eq) str
(\)=) p n
(\() S
(1: 4.0 4 eq check) str
(\)=) p n
(4.0 4 ) S
(eq) K
( check) p n
(\() S
(2: \(abc) str
(\) \() p
(abc) str
(\) ) p
(eq) K
( check\)=) p n
(\() S
(abc) str
(\) \() p
(abc) str
(\) ) p
(eq) K
( check) p n
(\() S
(3: \(abc) str
(\) /abc ) p
(eq) K
( check\)=) p n
(\() S
(abc) str
(\) /abc ) p
(eq) K
( check) p n
(\() S
(4: [1 2 3] dup eq check) str
(\)=) p n
([1 2 3] ) S
(dup) K
( ) p
(eq) K
( check) p n
(\() S
(5: [1 2 3] [1 2 3] eq check) str
(\)=) p n
([1 2 3] [1 2 3] ) S
(eq) K
( ) p
(false) k
( ) p
(eq) K
( check) p n
() N
(%erasepage) c n
() p n
(\() S
(errordict) str
(\)=) p n
(errordict type /dicttype ) S
(eq) K
( check) p n
() N
(\() S
(exch) str
(\)=) p n
(1 2 ) S
(exch) K n
(    1 ) p
(eq) K
( {) p n
(        2 ) S
(eq) K
( check) p n
(    }{) N
(        ) S
(pop) K
( fail) p n
(    } ) S
(ifelse) K n
() p n
(\() S
(exec) str
(\)=) p n
(\() S
(3 2 add) str
(\) cvx exec 5 ) p
(eq) K
( check) p n
(test.ps) (Page 5/12) (Aug 30, 13 4:27) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(3 2 /) p
(add) K
( exec) p n
(    /) S
(add) K
( ) p
(eq) K
( ) p
(exch) K n
(    2 ) p
(eq) K
( and ) p
(exch) K n
(    3 ) p
(eq) K
( and check) p n
(3 2 /) S
(add) K
( cvx exec 5 ) p
(eq) K
( check) p n
() N
(%\(execstack\)=) c n
(%execstackoverflow) N
() p n
(\() S
(executeonly) str
(\)=) p n
(\() S
(string) str
(\) executeonly rcheck ) p
(false) k
( ) p
(eq) K
( check) p n
() N
(\() S
(exit) str
(\)=) p n
({exit ) S
(false) k
( check}loop) p n
() N
(\() S
(exp) str
(\)=) p n
(\() S
(1: 9 0.5 exp 3.0 eq check) str
(\)=) p n
(9 0.5 exp 3.0 ) S
(eq) K
( check) p n
(\() S
(2: -9 -1 exp -0.111111 eq check) str
(\)=) p n
(-9 -1 exp -0.111111 ) S
(eq) K
( check) p n
() N
(\() S
(false) str
(\)=) p n
(false) k
( not check) p n
() N
(%\(file\)=) c n
() p n
(%fill) c n
(%findfont) N
(%flattenpath) N
() p n
(\() S
(floor) str
(\)=) p n
(3.2 floor 3.0 ) S
(eq) K
( check) p n
(-4.8 floor -5.0 ) S
(eq) K
( check) p n
(99 floor 99 ) S
(eq) K
( check) p n
() N
(%\(flush\)=) c n
(%\(flushfile\)=) N
(%FontDirectory) N
() p n
(\() S
(for) str
(\)=) p n
(\() S
(1: 0 1 1 4 {add} for 10 eq check) str
(\)=) p n
(0 1 1 4 {) S
(add) K
(} ) p
(for) K
( 10 ) p
(eq) K
( check) p n
(\() S
(2: 1 2 6 {} for) str
(\)=) p n
(1 2 6 {} ) S
(for) K n
(    5 ) p
(eq) K
( ) p
(exch) K n
(    3 ) p
(eq) K
( and ) p
(exch) K n
(    1 ) p
(eq) K
( and check) p n
(\() S
(3: 3 -.5 1 {} for) str
(\)=) p n
(3 -.5 1 {} ) S
(for) K n
(    1.0 ) p
(eq) K
( ) p
(exch) K n
(    1.5 ) p
(eq) K
( and ) p
(exch) K n
(    2.0 ) p
(eq) K
( and ) p
(exch) K n
(    2.5 ) p
(eq) K
( and ) p
(exch) K n
(    3.0 ) p
(eq) K
( and check) p n
() N
(\() S
(forall) str
(\)=) p n
(\() S
(1: 0 [13 29 3 -8 21] {add} forall 58 eq check) str
(\)=) p n
(0 [13 29 3 -8 21] {) S
(add) K
(} ) p
(forall) K
( 58 ) p
(eq) K
( check) p n
(/d 2 ) S
(dict) K
( ) p
(def) K n
(d /abc 123 ) p
(put) K n
(d /xyz \() p
(test) str
(\) ) p
(put) K n
(\() p
(2: d {} forall) str
(\)=) p n
(d {} ) S
(forall) K n
(    ) p
(dup) K
( 123 ) p
(eq) K
( {) p n
(        ) S
(pop) K n
(        /abc ) p
(eq) K
( ) p
(exch) K n
(        \() p
(test) str
(\) ) p
(eq) K
( and ) p
(exch) K n
(        /xyz ) p
(eq) K
( and check) p n
(    }{) N
(test.ps) (Page 6/12) (Aug 30, 13 4:27) title
border
grestore
(Printed by U-Z1\\josh) rhead
(test.ps) (82/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 83
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(        \() p
(test) str
(\) ) p
(eq) K
( ) p
(exch) K n
(        /xyz ) p
(eq) K
( and ) p
(exch) K n
(        123 ) p
(eq) K
( and ) p
(exch) K n
(        /abc ) p
(eq) K
( and check) p n
(    } ) S
(ifelse) K n
() p n
(%framedevice) c n
() p n
(\() S
(ge) str
(\)=) p n
(\() S
(1: 4.2 4 ge check) str
(\)=) p n
(4.2 4 ) S
(ge) K
( check) p n
(\() S
(2: \(abc) str
(\) \() p
(d) str
(\) ) p
(ge) K
( check\)=) p n
(\() S
(abc) str
(\) \() p
(d) str
(\) ) p
(ge) K
( check) p n
(\() S
(3: \(aba) str
(\) \() p
(ab) str
(\) ) p
(ge) K
( check\)=) p n
(\() S
(aba) str
(\) \() p
(ab) str
(\) ) p
(ge) K
( check) p n
(\() S
(4: \(aba) str
(\) \() p
(aba) str
(\) ) p
(ge) K
( check\)=) p n
(\() S
(aba) str
(\) \() p
(aba) str
(\) ) p
(ge) K
( check) p n
() N
(\() S
(get) str
(\)=) p n
([31 41 59] 0 ) S
(get) K
( 31 ) p
(eq) K
( check) p n
([0 \() S
(a mixed-type array) str
(\) [] {) p
(add) K
( 2 ) p
(div) K
(}] 2 ) p
(get) K
( ) p
(length) K
( 0 ) p
(eq) K
( check) p n
(/mykey \() S
(myvalue) str
(\) ) p
(def) K n
(currentdict) S
( /mykey ) p
(get) K
( \() p
(myvalue) str
(\) ) p
(eq) K
( check) p n
(\() S
(abc) str
(\) 1 ) p
(get) K
( 98 ) p
(eq) K
( check) p n
(\() S
(a) str
(\) 0 ) p
(get) K
( 97 ) p
(eq) K
( check) p n
() N
(\() S
(getinterval) str
(\)=) p n
([9 8 7 6 5] 1 3 getinterval aload ) S
(pop) K
( ) p n
(    6 ) S
(eq) K
( ) p
(exch) K n
(    7 ) p
(eq) K
( and ) p
(exch) K n
(    8 ) p
(eq) K
( and check) p n
(\() S
(abcde) str
(\) 1 3 getinterval \() p
(bcd) str
(\) ) p
(eq) K
( check) p n
(\() S
(abcde) str
(\) 0 0 getinterval \(\) ) p
(eq) K
( check) p n
() N
(\() S
(grestore grestoreall gsave) str
(\)=) p n
(matrix currentmatrix aload ) S
(pop) K n
(gsave) S
( ) p
(gsave) K
( 2 2 matrix ) p
(scale) K
( setmatrix) p n
(grestore) K
( grestoreall) p n
(matrix currentmatrix aload ) S
(pop) K n
(%pstack) c n
(    7 -1 ) p
(roll) K
( ) p
(eq) K
( check) p n
(    6 -1 ) S
(roll) K
( ) p
(eq) K
( check) p n
(    5 -1 ) S
(roll) K
( ) p
(eq) K
( check) p n
(    4 -1 ) S
(roll) K
( ) p
(eq) K
( check) p n
(    3 -1 ) S
(roll) K
( ) p
(eq) K
( check) p n
(    ) S
(eq) K
( check) p n
() N
(%\(gt\)=) c n
() p n
(%handleerror) c n
(%identmatrix) N
() p n
(\() S
(idiv) str
(\)=) p n
(3 2 idiv 1 ) S
(eq) K
( check) p n
(4 2 idiv 2 ) S
(eq) K
( check) p n
(-5 2 idiv -2 ) S
(eq) K
( check) p n
() N
(%idtransform) c n
() p n
(\() S
(if) str
(\)=) p n
(3 4 ) S
(lt) K
( {\() p
(3 is less than 4) str
(\)} ) p
(if) K n
(    \() p
(3 is less than 4) str
(\) { ) p
(eq) K
( check } stopped not check) p n
() N
(\() S
(ifelse) str
(\)=) p n
(4 3 ) S
(lt) K
( {\() p
(TruePart) str
(\)} {\() p
(FalsePart) str
(\)} ) p
(ifelse) K n
(    \() p
(FalsePart) str
(\) ) p
(eq) K
( check) p n
() N
(%image) c n
(%imagemask) N
(test.ps) (Page 7/12) (Aug 30, 13 4:27) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(\() S
(index) str
(\)=) p n
(\() S
(a) str
(\)\() p
(b) str
(\)\() p
(c) str
(\)\() p
(d) str
(\) 0 ) p
(index) K
( \() p
(d) str
(\) ) p
(eq) K
( check) p n
(    3 ) S
(index) K
( \() p
(a) str
(\) ) p
(eq) K
( check) p n
(    clear) N
() N
(%initclip) c n
(%initgraphics) N
(%initmatrix) N
() p n
(%interrupt) c n
(%invalidaccess) N
(%invalidfileaccess) N
(%invalidfont) N
(%invalidrestore) N
() p n
(%invertmatrix) c n
() p n
(%ioerror) c n
() p n
(%itransform) c n
() p n
(\() S
(known) str
(\)=) p n
(/mydict 5 ) S
(dict) K
( ) p
(def) K n
(mydict /total 0 ) p
(put) K n
(mydict /total ) p
(known) K
( check) p n
(mydict /badname ) S
(known) K
( not check) p n
() N
(%kshow) c n
() p n
(%\(le\)=) c n
() p n
(\() S
(length) str
(\)=) p n
([1 2 4] ) S
(length) K
( 3 ) p
(eq) K
( check) p n
([] ) S
(length) K
( 0 ) p
(eq) K
( check) p n
(/ar 20 ) S
(array) K
( ) p
(def) K
( ar ) p
(length) K
( 20 ) p
(eq) K
( check) p n
(/mydict 5 ) S
(dict) K
( ) p
(def) K n
(mydict ) p
(length) K
( 0 ) p
(eq) K
( check) p n
(mydict /firstkey \() S
(firstvalue) str
(\) ) p
(put) K n
(mydict ) p
(length) K
( 1 ) p
(eq) K
( check) p n
(\() S
(abc\\n) str
(\) ) p
(length) K
( 4 ) p
(eq) K
( check) p n
(\(\) ) S
(length) K
( 0 ) p
(eq) K
( check) p n
() N
(%limitcheck) c n
(%lineto) N
() p n
(\() S
(ln) str
(\)=) p n
(10 ln 2.30259 ) S
(eq) K
( check) p n
(100 ln 4.60517 ) S
(eq) K
( check) p n
() N
(\() S
(load) str
(\)=) p n
(/avg) L
( {) p
(add) K
( 2 ) p
(div) K
(} ) p
(def) K n
(/avg load 1 ) p
(get) K
( 2 ) p
(eq) K
( check) p n
() N
(\() S
(log) str
(\)=) p n
(10 log 1.0 ) S
(eq) K
( check) p n
(100 log 2.0 ) S
(eq) K
( check) p n
() N
(%\(loop\)=) c n
(%\(lt\)=) N
(%makefont) N
() p n
(\() S
(mark) str
(\)=) p n
(mark [ ) S
(eq) K
( check) p n
() N
(%matrix) c n
() p n
(\() S
(maxlength) str
(\)=) p n
(/mydict 5 ) S
(dict) K
( ) p
(def) K n
(test.ps) (Page 8/12) (Aug 30, 13 4:27) title
border
grestore
(Printed by U-Z1\\josh) rhead
(test.ps) (83/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 84
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(mydict ) p
(length) K
( 0 ) p
(eq) K
( check) p n
(mydict maxlength 5 ) S
(eq) K
( check) p n
() N
(\() S
(mod) str
(\)=) p n
(5 3 mod 2 ) S
(eq) K
( check) p n
(5 2 mod 1 ) S
(eq) K
( check) p n
(-5 3 mod -2 ) S
(eq) K
( check) p n
() N
(%moveto) c n
(%\(mul\)=) N
(%\(ne\)=) N
() p n
(\() S
(neg) str
(\)=) p n
(4.5 ) S
(neg) K
( -4.5 ) p
(eq) K
( check) p n
(-3 ) S
(neg) K
( 3 ) p
(eq) K
( check) p n
() N
(%newpath) c n
(%\(noaccess\)=) N
(%nocurrentpoint) N
() p n
(\() S
(not) str
(\)=) p n
(\() S
(1:) str
(\)=) p n
(true) k
( not ) p
(false) k
( ) p
(eq) K
( check) p n
(\() S
(2:) str
(\)=) p n
(false) k
( not ) p
(true) k
( ) p
(eq) K
( check) p n
(\() S
(3:) str
(\)=) p n
(52 not -53 ) S
(eq) K
( check) p n
() N
(\() S
(null) str
(\)=) p n
(null 1 ) S
(array) K
( 0 ) p
(get) K
( ) p
(eq) K
( check) p n
() N
(%nulldevice) c n
() p n
(\() S
(or) str
(\)=) p n
(true) k
( ) p
(true) k
( or ) p
(true) k
( ) p
(eq) K
( check) p n
(true) k
( ) p
(false) k
( or ) p
(true) k
( ) p
(eq) K
( check) p n
(false) k
( ) p
(true) k
( or ) p
(true) k
( ) p
(eq) K
( check) p n
(false) k
( ) p
(false) k
( or ) p
(false) k
( ) p
(eq) K
( check) p n
(17 5 or 21 ) S
(eq) K
( check) p n
() N
(%packedarray) c n
(%pathbbox) N
(%pathforall) N
() p n
(\() S
(pop) str
(\)=) p n
(1 2 3 ) S
(pop) K
( 2 ) p
(eq) K
( check clear) p n
(1 2 3 ) S
(pop) K
( ) p
(pop) K
( 1 ) p
(eq) K
( check) p n
() N
(%\(print\)=) c n
(%\(prompt\)=) N
(%\(pstack\)=) N
() p n
(\() S
(put) str
(\)=) p n
(\() S
(1:) str
(\)=) p n
(/ar [5 17 3 8] ) S
(def) K n
(ar 2 \() p
(abcd) str
(\) ) p
(put) K n
(ar aload ) p
(pop) K n
(    8 ) p
(eq) K
( ) p
(exch) K n
(    \() p
(abcd) str
(\) ) p
(eq) K
( and check clear) p n
(\() S
(2:) str
(\)=) p n
(/d 5 ) S
(dict) K
( ) p
(def) K n
(d /abc 123 ) p
(put) K n
(d {} ) p
(forall) K n
(    123 ) p
(eq) K
( ) p
(exch) K n
(    /abc ) p
(eq) K
( and check) p n
(\() S
(3:) str
(\)=) p n
(/st \() S
(abc) str
(\) ) p
(def) K n
(st 0 65 ) p
(put) K n
(st \() p
(Abc) str
(\) ) p
(eq) K
( check) p n
(test.ps) (Page 9/12) (Aug 30, 13 4:27) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(\() S
(putinterval) str
(\)=) p n
(\() S
(1:) str
(\)=) p n
(/ar [5 8 2 7 3] ) S
(def) K n
(ar 1 [\() p
(a) str
(\) \() p
(b) str
(\) \() p
(c) str
(\)] putinterval) p n
(ar aload ) S
(pop) K n
(    3 ) p
(eq) K
( ) p
(exch) K n
(    \() p
(c) str
(\) ) p
(eq) K
( and ) p
(exch) K n
(    \() p
(b) str
(\) ) p
(eq) K
( and ) p
(exch) K n
(    \() p
(a) str
(\) ) p
(eq) K
( and ) p
(exch) K n
(    5 ) p
(eq) K
( and check) p n
(\() S
(2:) str
(\)=) p n
(/st \() S
(abc) str
(\) ) p
(def) K n
(st 1 \() p
(de) str
(\) putinterval) p n
(st \() S
(ade) str
(\) ) p
(eq) K
( check) p n
() N
(%\(quit\)=) c n
() p n
(\() S
(rand) str
(\)=) p n
(rand type /integertype ) S
(eq) K
( check) p n
(rand rand ) S
(eq) K
( not check) p n
() N
(%rangecheck) c n
(%\(rcheck\)=) N
(%rcurveto) N
(%\(read\)=) N
(%\(readhexstring\)=) N
(%\(readline\)=) N
(%\(readonly\)=) N
(%\(readstring\)=) N
(%renderbands) N
() p n
(\() S
(repeat) str
(\)=) p n
(4{\() S
(abc) str
(\)}repeat count 4 ) p
(eq) K
( check) p n
(1 2 3 4 3 {) S
(pop) K
(} repeat 1 ) p
(eq) K
( check) p n
(4 {} repeat \() S
(abc) str
(\) ) p
(eq) K
( check) p n
(mark 0 {\() S
(won't happen) str
(\)} repeat mark ) p
(eq) K
( check) p n
(clear) N
() N
(%resetfile) c n
() p n
(%\(restore\)=) c n
() p n
(%reversepath) c n
(%rlineto) N
(%rmoveto) N
() p n
(\() S
(roll) str
(\)=) p n
(\() S
(a) str
(\)\() p
(b) str
(\)\() p
(c) str
(\) 3 -1 ) p
(roll) K
( \() p
(a) str
(\) ne {fail} ) p
(if) K
( clear) p n
(\() S
(a) str
(\)\() p
(b) str
(\)\() p
(c) str
(\) 3 1 ) p
(roll) K
( \() p
(b) str
(\) ne {fail} ) p
(if) K
( clear) p n
(\() S
(a) str
(\)\() p
(b) str
(\)\() p
(c) str
(\) 3 0 ) p
(roll) K
( \() p
(c) str
(\) ne {fail} ) p
(if) K
( clear) p n
() N
(%rotate) c n
() p n
(\() S
(round) str
(\)=) p n
(\() S
(1: 3.2 round 3.0 ne check) str
(\)=) p n
(3.2 round 3.0 ) S
(eq) K
( check) p n
(\() S
(2: 6.5 round 7.0 ne check) str
(\)=) p n
(6.5 round 7.0 ) S
(eq) K
( check) p n
(\() S
(3: -4.8 round -5.0 ne check) str
(\)=) p n
(-4.8 round -5.0 ) S
(eq) K
( check) p n
(\() S
(4: -6.5 round -6.0 ne check) str
(\)=) p n
(-6.5 round -6.0 ) S
(eq) K
( check) p n
(\() S
(5: 99 round 99 ne check) str
(\)=) p n
(99 round 99 ) S
(eq) K
( check) p n
() N
(%\(rrand\)=) c n
(%\(run\)=) N
() p n
(test.ps) (Page 10/12) (Aug 30, 13 4:27) title
border
grestore
(Printed by U-Z1\\josh) rhead
(test.ps) (84/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 85
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(\() p
(save) str
(\)=) p n
(/saveobj ) S
(save) K
( ) p
(def) K n
(saveobj ) p
(restore) K n
() p n
(%scale) c n
(%scalefont) N
() p n
(\() S
(search) str
(\)=) p n
(\() S
(1: \(abbc) str
(\) \() p
(ab) str
(\) search {fail} ) p
(if) K
( clear\)=) p n
(\() S
(abbc) str
(\) \() p
(ab) str
(\) search not {fail} ) p
(if) K
( clear) p n
(\() S
(2: \(abbc) str
(\) \() p
(bb) str
(\) search not {fail} ) p
(if) K
( clear\)=) p n
(\() S
(abbc) str
(\) \() p
(bb) str
(\) search not {fail} ) p
(if) K
( clear) p n
(\() S
(3: \(abbc) str
(\) \() p
(bc) str
(\) search not {fail} ) p
(if) K
( clear\)=) p n
(\() S
(abbc) str
(\) \() p
(bc) str
(\) search not {fail} ) p
(if) K
( clear) p n
(\() S
(4: \(abbc) str
(\) \() p
(B) str
(\) search {fail} ) p
(if) K
( clear\)=) p n
(\() S
(abbc) str
(\) \() p
(B) str
(\) search {fail} ) p
(if) K
( clear) p n
() N
(%setcachedevice) c n
(%setcachelimit) N
(%setcacheparams) N
(%setcharwidth) N
(%setdash) N
(%setflat) N
(%setfont) N
(%setgray) N
(%sethsbcolor) N
(%setlinecap) N
(%setlinejoin) N
(%setlinewidth) N
(%setmatrix) N
(%setmiterlimit) N
(%setpacking) N
(%setrgbcolor) N
(%setscreen) N
(%settransfer) N
(%show) N
(%showpage) N
() p n
(%\(sin\)=) c n
(%\(sqrt\)=) N
(%\(srand\)=) N
(%\(stack\)=) N
(%stackoverflow) N
(%stackunderflow) N
(%StandardEncoding) N
(%\(start\)=) N
(%status) N
(%stop) N
() p n
(\() S
(stopped) str
(\)=) p n
({ ... } stopped check) N
() N
(\() S
(store) str
(\)=) p n
(/abc 123 store) N
(/abc ) S
(where) K
( {}{) p
(currentdict) K
(} ) p
(ifelse) K
( /abc 123 ) p
(put) K n
(abc 123 ne {fail} ) p
(if) K n
() p n
(%\(string\)=) c n
(%stringwidth) N
(%stroke) N
(%strokepath) N
(%\(sub\)=) N
(%syntaxerror) N
(%\(systemdict\)=) N
(%timeout) N
() p n
(\() S
(token) str
(\)=) p n
(\() S
(15\(St1) str
(\) {1 2 ) p
(add) K
(}\) token not {fail} ) p
(if) K
( 15 ) p
(eq) K
( check) p n
(token not {fail} ) S
(if) K
( \() p
(St1) str
(\) ) p
(eq) K
( check) p n
(test.ps) (Page 11/12) (Aug 30, 13 4:27) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(token not {fail} ) p
(if) K
( type /arraytype ) p
(eq) K
( check) p n
(token not check) N
() N
(%transform) c n
(%translate) N
(%\(true\)=) N
() p n
(\() S
(truncate) str
(\)=) p n
(3.2 truncate 3.0 ) S
(eq) K
( check) p n
(-4.8 truncate -4.0 ) S
(eq) K
( check) p n
(99 truncate 99 ) S
(eq) K
( check) p n
() N
(%\(type\)=) c n
(%typecheck) N
(%undefined) N
(%undefinedfilename) N
(%undefinedresult) N
(%unmatchedmark) N
(%unregistered) N
(%\(userdict\)=) N
(%usertime) N
(%version) N
(%VMerror) N
(%vmstatus) N
(%\(wcheck\)=) N
() p n
(%\(where\)=) c n
(%widthshow) N
(%\(write\)=) N
(%\(writehexstring\)=) N
(%\(writestring\)=) N
(%\(xcheck\)=) N
() p n
(\() S
(xor) str
(\)=) p n
(true) k
( ) p
(true) k
( ) p
(xor) K
( ) p
(false) k
( ) p
(eq) K
( check) p n
(true) k
( ) p
(false) k
( ) p
(xor) K
( ) p
(true) k
( ) p
(eq) K
( check) p n
(false) k
( ) p
(true) k
( ) p
(xor) K
( ) p
(true) k
( ) p
(eq) K
( check) p n
(false) k
( ) p
(false) k
( ) p
(xor) K
( ) p
(false) k
( ) p
(eq) K
( check) p n
(7 3 ) S
(xor) K
( 4 ) p
(eq) K
( check) p n
(12 3 ) S
(xor) K
( 15 ) p
(eq) K
( check) p n
() N
(failcount 0 ) S
(eq) K
( {) p n
(    \() S
(SUCCESS) str
(\)=) p n
(}{) N
(    failcount =only \() S
( FAILs) str
(\) =) p n
(} ) S
(ifelse) K n
() p n
(%traceon) c n
() p n
(test.ps) (Page 12/12) (Aug 30, 13 4:27) title
border
grestore
(Printed by U-Z1\\josh) rhead
(test.ps) (85/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1) 86
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Table of Contents) K n
( 1 ) p
(makefile............) k
( sheets   1 to   1 \( 1\) pages   1-  2   84 lines) p n
( 2 ) S
(ar.h................) k
( sheets   2 to   2 \( 1\) pages   3-  3   33 lines) p n
( 3 ) S
(di.h................) k
( sheets   2 to   2 \( 1\) pages   4-  4   64 lines) p n
( 4 ) S
(err.h...............) k
( sheets   3 to   3 \( 1\) pages   5-  5   55 lines) p n
( 5 ) S
(f.h.................) k
( sheets   3 to   3 \( 1\) pages   6-  6   18 lines) p n
( 6 ) S
(gc.h................) k
( sheets   4 to   4 \( 1\) pages   7-  7   23 lines) p n
( 7 ) S
(itp.h...............) k
( sheets   4 to   4 \( 1\) pages   8-  8   48 lines) p n
( 8 ) S
(m.h.................) k
( sheets   5 to   5 \( 1\) pages   9- 10  131 lines) p n
( 9 ) S
(nm.h................) k
( sheets   6 to   6 \( 1\) pages  11- 11   20 lines) p n
(10 ) S
(ob.h................) k
( sheets   6 to   7 \( 2\) pages  12- 14  161 lines) p n
(11 ) S
(op.h................) k
( sheets   8 to   8 \( 1\) pages  15- 15   61 lines) p n
(12 ) S
(opar.h..............) k
( sheets   8 to   8 \( 1\) pages  16- 16    6 lines) p n
(13 ) S
(opb.h...............) k
( sheets   9 to   9 \( 1\) pages  17- 17    4 lines) p n
(14 ) S
(opc.h...............) k
( sheets   9 to   9 \( 1\) pages  18- 18    4 lines) p n
(15 ) S
(opdi.h..............) k
( sheets  10 to  10 \( 1\) pages  19- 19    8 lines) p n
(16 ) S
(opf.h...............) k
( sheets  10 to  10 \( 1\) pages  20- 20    4 lines) p n
(17 ) S
(opm.h...............) k
( sheets  11 to  11 \( 1\) pages  21- 21    4 lines) p n
(18 ) S
(oppa.h..............) k
( sheets  11 to  11 \( 1\) pages  22- 22    5 lines) p n
(19 ) S
(ops.h...............) k
( sheets  12 to  12 \( 1\) pages  23- 23   12 lines) p n
(20 ) S
(opst.h..............) k
( sheets  12 to  12 \( 1\) pages  24- 24    5 lines) p n
(21 ) S
(opt.h...............) k
( sheets  13 to  13 \( 1\) pages  25- 25    4 lines) p n
(22 ) S
(optok.h.............) k
( sheets  13 to  13 \( 1\) pages  26- 26    4 lines) p n
(23 ) S
(opv.h...............) k
( sheets  14 to  14 \( 1\) pages  27- 27    4 lines) p n
(24 ) S
(opx.h...............) k
( sheets  14 to  14 \( 1\) pages  28- 28    4 lines) p n
(25 ) S
(osunix.h............) k
( sheets  15 to  15 \( 1\) pages  29- 29    5 lines) p n
(26 ) S
(s.h.................) k
( sheets  15 to  15 \( 1\) pages  30- 30   46 lines) p n
(27 ) S
(st.h................) k
( sheets  16 to  16 \( 1\) pages  31- 31   14 lines) p n
(28 ) S
(v.h.................) k
( sheets  16 to  16 \( 1\) pages  32- 32   35 lines) p n
(29 ) S
(ar.c................) k
( sheets  17 to  18 \( 2\) pages  33- 35  143 lines) p n
(30 ) S
(di.c................) k
( sheets  18 to  21 \( 4\) pages  36- 42  469 lines) p n
(31 ) S
(err.c...............) k
( sheets  22 to  22 \( 1\) pages  43- 44  110 lines) p n
(32 ) S
(f.c.................) k
( sheets  23 to  24 \( 2\) pages  45- 48  218 lines) p n
(33 ) S
(gc.c................) k
( sheets  25 to  28 \( 4\) pages  49- 55  417 lines) p n
(34 ) S
(itp.c...............) k
( sheets  28 to  32 \( 5\) pages  56- 63  492 lines) p n
(35 ) S
(m.c.................) k
( sheets  32 to  35 \( 4\) pages  64- 69  396 lines) p n
(36 ) S
(nm.c................) k
( sheets  35 to  37 \( 3\) pages  70- 73  253 lines) p n
(37 ) S
(ob.c................) k
( sheets  37 to  38 \( 2\) pages  74- 75  138 lines) p n
(38 ) S
(op.c................) k
( sheets  38 to  40 \( 3\) pages  76- 80  339 lines) p n
(39 ) S
(opar.c..............) k
( sheets  41 to  42 \( 2\) pages  81- 83  151 lines) p n
(40 ) S
(opb.c...............) k
( sheets  42 to  43 \( 2\) pages  84- 85  132 lines) p n
(41 ) S
(opc.c...............) k
( sheets  43 to  44 \( 2\) pages  86- 88  193 lines) p n
(42 ) S
(opdi.c..............) k
( sheets  45 to  47 \( 3\) pages  89- 93  308 lines) p n
(43 ) S
(opf.c...............) k
( sheets  47 to  49 \( 3\) pages  94- 97  261 lines) p n
(44 ) S
(opm.c...............) k
( sheets  49 to  51 \( 3\) pages  98-102  278 lines) p n
(45 ) S
(oppa.c..............) k
( sheets  52 to  52 \( 1\) pages 103-103   53 lines) p n
(46 ) S
(ops.c...............) k
( sheets  52 to  53 \( 2\) pages 104-106  171 lines) p n
(47 ) S
(opst.c..............) k
( sheets  54 to  55 \( 2\) pages 107-109  143 lines) p n
(48 ) S
(opt.c...............) k
( sheets  55 to  57 \( 3\) pages 110-114  282 lines) p n
(49 ) S
(optok.c.............) k
( sheets  58 to  60 \( 3\) pages 115-120  350 lines) p n
(50 ) S
(opv.c...............) k
( sheets  61 to  61 \( 1\) pages 121-122   77 lines) p n
(51 ) S
(opx.c...............) k
( sheets  62 to  62 \( 1\) pages 123-124  118 lines) p n
(52 ) S
(osunix.c............) k
( sheets  63 to  63 \( 1\) pages 125-125   19 lines) p n
(53 ) S
(s.c.................) k
( sheets  63 to  65 \( 3\) pages 126-129  264 lines) p n
(54 ) S
(st.c................) k
( sheets  65 to  66 \( 2\) pages 130-131   83 lines) p n
(55 ) S
(v.c.................) k
( sheets  66 to  67 \( 2\) pages 132-134  165 lines) p n
(56 ) S
(init.ps.............) k
( sheets  68 to  69 \( 2\) pages 135-138  222 lines) p n
(57 ) S
(err.ps..............) k
( sheets  70 to  70 \( 1\) pages 139-140  101 lines) p n
(58 ) S
(g.ps................) k
( sheets  71 to  78 \( 8\) pages 141-156 1040 lines) p n
(59 ) S
(clip.ps.............) k
( sheets  79 to  79 \( 1\) pages 157-158   81 lines) p n
(60 ) S
(test.ps.............) k
( sheets  80 to  85 \( 6\) pages 159-170  808 lines) p n
(Table of Content) (Page 1/1) (Sep 09, 13 1:13) title
border
grestore
(Printed by U-Z1\\josh) rhead
(Table of Content) (86/86) (Monday September 09, 2013) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
